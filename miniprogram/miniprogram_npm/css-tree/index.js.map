{"version":3,"sources":["index.js","syntax/index.js","syntax/create.js","common/List.js","common/SyntaxError.js","utils/createCustomError.js","common/TokenStream.js","tokenizer/const.js","tokenizer/utils.js","tokenizer/char-code-definitions.js","lexer/Lexer.js","lexer/error.js","definition-syntax/generate.js","utils/names.js","lexer/generic.js","tokenizer/index.js","common/adopt-buffer.js","lexer/generic-an-plus-b.js","lexer/generic-urange.js","definition-syntax/parse.js","definition-syntax/tokenizer.js","definition-syntax/SyntaxError.js","definition-syntax/walk.js","lexer/prepare-tokens.js","lexer/match-graph.js","lexer/match.js","lexer/trace.js","lexer/search.js","lexer/structure.js","definition-syntax/index.js","parser/create.js","common/OffsetToLocation.js","parser/sequence.js","generator/create.js","generator/sourceMap.js","convertor/create.js","walker/create.js","utils/clone.js","syntax/config/mix.js","syntax/config/lexer.js","../data/index.js","../data/patch.json","syntax/node/index.js","syntax/node/AnPlusB.js","syntax/node/Atrule.js","syntax/node/Raw.js","syntax/node/AtrulePrelude.js","syntax/node/AttributeSelector.js","syntax/node/Block.js","syntax/node/Brackets.js","syntax/node/CDC.js","syntax/node/CDO.js","syntax/node/ClassSelector.js","syntax/node/Combinator.js","syntax/node/Comment.js","syntax/node/Declaration.js","syntax/node/DeclarationList.js","syntax/node/Dimension.js","syntax/node/Function.js","syntax/node/HexColor.js","syntax/node/Identifier.js","syntax/node/IdSelector.js","syntax/node/MediaFeature.js","syntax/node/MediaQuery.js","syntax/node/MediaQueryList.js","syntax/node/Nth.js","syntax/node/Number.js","syntax/node/Operator.js","syntax/node/Parentheses.js","syntax/node/Percentage.js","syntax/node/PseudoClassSelector.js","syntax/node/PseudoElementSelector.js","syntax/node/Ratio.js","syntax/node/Rule.js","syntax/node/Selector.js","syntax/node/SelectorList.js","syntax/node/String.js","syntax/node/StyleSheet.js","syntax/node/TypeSelector.js","syntax/node/UnicodeRange.js","syntax/node/Url.js","syntax/node/Value.js","syntax/node/WhiteSpace.js","syntax/config/parser.js","syntax/scope/index.js","syntax/scope/atrulePrelude.js","syntax/scope/default.js","syntax/scope/selector.js","syntax/scope/value.js","syntax/function/element.js","syntax/function/expression.js","syntax/function/var.js","syntax/atrule/index.js","syntax/atrule/font-face.js","syntax/atrule/import.js","syntax/atrule/media.js","syntax/atrule/page.js","syntax/atrule/supports.js","syntax/pseudo/index.js","syntax/pseudo/dir.js","syntax/pseudo/has.js","syntax/pseudo/lang.js","syntax/pseudo/matches.js","syntax/pseudo/common/selectorList.js","syntax/pseudo/not.js","syntax/pseudo/nth-child.js","syntax/pseudo/common/nthWithOfClause.js","syntax/pseudo/nth-last-child.js","syntax/pseudo/nth-last-of-type.js","syntax/pseudo/common/nth.js","syntax/pseudo/nth-of-type.js","syntax/pseudo/slotted.js","syntax/config/walker.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;;ACDA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA;AELA,ACHA,AFMA,ADGA,AIZA;AFOA,ACHA,AFMA,ADGA,AIZA;AFOA,ACHA,AFMA,ADGA,AIZA;AFOA,ACHA,AENA,AJYA,ADGA,AIZA;AFOA,ACHA,AENA,AJYA,ADGA,AIZA;AFOA,ACHA,AENA,AJYA,ADGA,AIZA;AFOA,ACHA,AENA,AJYA,ADGA,AMlBA,AFMA;AFOA,ACHA,AENA,AJYA,ADGA,AMlBA,AFMA;AFOA,ACHA,AENA,AJYA,ADGA,AMlBA,AFMA;AFOA,ACHA,AENA,AJYA,AKfA,ACHA,AHSA;AFOA,ACHA,AENA,AJYA,AKfA,ACHA,AHSA;AFOA,ACHA,AENA,AJYA,AKfA,ACHA,AHSA;AFOA,ACHA,AENA,AJYA,AOrBA,AFMA,ACHA,AHSA;AFOA,ACHA,AENA,AJYA,AOrBA,AFMA,ACHA,AHSA;AFOA,ACHA,AENA,AJYA,AOrBA,AFMA,ACHA,AHSA;AFOA,ACHA,AENA,AIZA,ARwBA,AOrBA,AFMA,ACHA,AHSA;AFOA,ACHA,AENA,AIZA,ARwBA,AOrBA,AFMA,ACHA,AHSA;AFOA,ACHA,AENA,AIZA,ARwBA,AOrBA,AFMA,ACHA,AHSA;AFOA,ACHA,AENA,AIZA,ACHA,AT2BA,AOrBA,AFMA,ACHA;ALgBA,ACHA,AENA,AIZA,ACHA,AT2BA,AOrBA,AFMA,ACHA;ALgBA,ACHA,AENA,AIZA,ACHA,AT2BA,AOrBA,AFMA,ACHA;ALgBA,ACHA,AENA,AMlBA,AFMA,ACHA,AT2BA,AOrBA,AFMA,ACHA;ALgBA,ACHA,AENA,AMlBA,AFMA,ACHA,AT2BA,AOrBA,AFMA,ACHA;ALgBA,ACHA,AENA,AMlBA,AFMA,ACHA,AT2BA,AOrBA,AFMA,ACHA;ALgBA,ACHA,AENA,AMlBA,AFMA,ACHA,AT2BA,AOrBA,AFMA,ACHA,AKfA;AV+BA,ACHA,AENA,AMlBA,AFMA,ACHA,AT2BA,AOrBA,AFMA,ACHA,AKfA;AV+BA,ACHA,AENA,AMlBA,AFMA,ACHA,AT2BA,AOrBA,AFMA,ACHA,AKfA;AV+BA,ACHA,AENA,AMlBA,AFMA,ACHA,AGTA,AZoCA,AOrBA,AFMA,ACHA,AKfA;AV+BA,ACHA,AENA,AMlBA,AFMA,ACHA,AGTA,AZoCA,AOrBA,AFMA,ACHA,AKfA;AV+BA,ACHA,AENA,AMlBA,AFMA,ACHA,AGTA,AZoCA,AOrBA,AFMA,ACHA,AKfA;AV+BA,ACHA,AENA,AMlBA,AFMA,ACHA,AGTA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AFMA,ACHA,AGTA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AFMA,ACHA,AGTA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AFMA,ACHA,AGTA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AFMA,ACHA,AGTA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AFMA,ACHA,AGTA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AFMA,ACHA,AMlBA,AHSA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AFMA,ACHA,AMlBA,AHSA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AFMA,ACHA,AMlBA,AHSA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AFMA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AFMA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AFMA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AOrBA,AT2BA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AU9BA,AJYA,AOrBA,AT2BA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,AT2BA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AV8BA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AV8BA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AFMA,AQxBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AV8BA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AV8BA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AV8BA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AV8BA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AZoCA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AS3BA,ArB+DA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AS3BA,ArB+DA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AS3BA,ArB+DA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ADGA,ArB+DA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ADGA,ArB+DA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ADGA,ArB+DA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,ArB+DA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,ArB+DA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,Ae7CA,AT2BA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,ArB+DA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AGTA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AGTA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AGTA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ADGA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ADGA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ADGA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AiBnDA,AV8BA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AiBnDA,AV8BA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AiBnDA,AV8BA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AxBwEA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AiBnDA,AV8BA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,A5BoFA,AOrBA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AiBnDA,AV8BA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,ArB+DA,AMlBA,APqBA,AKfA;AV+BA,ACHA,AENA,AMlBA,AiBnDA,AV8BA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,ArB+DA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,A3BiFA,AENA,AMlBA,AiBnDA,AV8BA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,ArB+DA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,A3BiFA,AENA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,ArB+DA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,ArB+DA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AZoCA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AWjCA,AvBqEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AWjCA,AvBqEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AWjCA,AvBqEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,AMlBA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA;AV+BA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,AKfA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AvBqEA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,ACHA,AENA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,AGTA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,AGTA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AOrBA,ADGA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,AGTA,AWjCA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AOrBA,ADGA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AjCoGA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AOrBA,ADGA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ArC+GA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AOrBA,ADGA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ArC+GA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AOrBA,ADGA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ArC+GA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AOrBA,ADGA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AOrBA,ADGA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AOrBA,ADGA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AOrBA,ADGA,A7BuFA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,ACHA,AMlBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AIZA,AjCmGA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AIZA,AjCmGA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AIZA,AjCmGA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ADGA,AjCmGA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ADGA,AjCmGA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ADGA,AjCmGA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AFMA,AjCmGA,AMlBA,APqBA,A6BvFA,AxBwEA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,A6BvFA,AvBqEA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AFMA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AFMA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,ACHA,AHSA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,ACHA,AHSA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,ACHA,AHSA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ADGA,AHSA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ADGA,AHSA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ADGA,AHSA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,AFMA,AHSA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AFMA,AIZA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,AFMA,AHSA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AENA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,AFMA,AHSA,AjCmGA,AMlBA,APqBA,AKfA,AuBrEA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AENA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,ACHA,AHSA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AENA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,ACHA,AHSA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AENA,ACHA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,ACHA,AHSA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AJYA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AJYA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AJYA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AENA,AMlBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ALeA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ANkBA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AIXA,ACHA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ANkBA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ANkBA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,APqBA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AFMA,AIZA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,APqBA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,APqBA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ARwBA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AT2BA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AT2BA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AT2BA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AMlBA,AOrBA,Ac1CA,ACHA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AV8BA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA,AHSA,AjCmGA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AXiCA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,AZoCA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AbuCA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AbuCA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AbuCA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Ad0CA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Ad0CA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Ad0CA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Af6CA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Af6CA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,Af6CA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,Af6CA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,A4BpFA,AzB2EA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,Af6CA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,Af6CA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AjBmDA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AjBmDA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,AjBmDA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AENA,ACHA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AlBsDA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AlBsDA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,AlBsDA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AnByDA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AnByDA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,AnByDA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ApB4DA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ApB4DA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,Ae7CA,AxBwEA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ApB4DA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ArB+DA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ArB+DA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,ACHA,ACHA,ACHA,AENA,ADGA,AENA,ACHA,ACHA,ACHA,ACHA,ArB+DA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtBkEA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtBkEA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtBkEA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvBqEA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvBqEA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvBqEA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AQxBA,AKfA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxBwEA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzB2EA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzB2EA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzB2EA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,ACHA,AJYA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1B8EA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AKfA,AENA,ACHA,AENA,AIZA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1B8EA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A1B8EA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,ACHA,AMlBA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,A3BiFA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,ACHA,AMlBA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3BiFA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3BiFA,ApC4GA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3BiFA,A4BpFA,AhEgMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3BiFA,A4BpFA,AhEgMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3BiFA,A4BpFA,AhEgMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,A3BiFA,A4BpFA,ACHA,AjEmMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjEmMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AjEmMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlEsMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlEsMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AGTA,AavCA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AlEsMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,ACHA,ACHA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnEyMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnEyMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AnEyMA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApE4MA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApE4MA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ApE4MA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,AENA,AGTA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArE+MA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,ACHA,AOrBA,AOrBA,ACHA,AENA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArE+MA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ArE+MA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtEkNA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AGTA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtEkNA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,ACHA,AGTA,AQxBA,AOrBA,ACHA,AENA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AtEkNA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,AIZA,AQxBA,AOrBA,ACHA,AENA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvEqNA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,AIZA,AQxBA,AOrBA,ACHA,AENA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvEqNA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,AIZA,AQxBA,AOrBA,ACHA,AENA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AvEqNA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,AIZA,AQxBA,AOrBA,ACHA,AENA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxEwNA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,AIZA,AQxBA,AOrBA,ACHA,AENA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxEwNA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,AIZA,AQxBA,AOrBA,ACHA,AENA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AxEwNA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,AIZA,AQxBA,AOrBA,ACHA,AENA,AKfA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,ACHA,AzE2NA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AGTA,AENA,AavCA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AzE2NA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AavCA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AzE2NA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AzE2NA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AzE2NA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AzE2NA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,A3EiOA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,A3EiOA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AENA,A3EiOA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ADGA,A3EiOA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ADGA,A3EiOA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,ACHA,AOrBA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ADGA,A3EiOA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,AQxBA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AGTA,ACHA,A7EuOA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,AQxBA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,A7EuOA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,AQxBA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,A7EuOA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,AQxBA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,ACHA,A9E0OA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,AOrBA,AQxBA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,ACHA,ACHA,AIZA,ACHA,A9E0OA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,Ae7CA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,A9E0OA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,Ae7CA,ACHA,ACHA,ACHA,AENA,AENA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,A/E6OA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,Ae7CA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,A/E6OA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AxCwHA,AIZA,AQxBA,Ae7CA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,A/E6OA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AMlBA,A9C0IA,AIZA,AQxBA,Ae7CA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,A/E6OA,AMlBA,APqBA,A4BpFA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AMlBA,A9C0IA,AIZA,AQxBA,Ae7CA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,A/E6OA,AMlBA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AMlBA,A9C0IA,AIZA,AQxBA,Ae7CA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,A/E6OA,AMlBA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AMlBA,ACHA,A/C6IA,AIZA,AQxBA,Ae7CA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,A/E6OA,AMlBA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AMlBA,ACHA,A/C6IA,AIZA,AQxBA,Ae7CA,ACHA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,ACHA,A/E6OA,AMlBA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AMlBA,ACHA,A/C6IA,AIZA,AQxBA,AgBhDA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,AENA,AIZA,ACHA,A9E0OA,AMlBA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AMlBA,ACHA,ACHA,AhDgJA,AIZA,AQxBA,AgBhDA,ACHA,ACHA,AIZA,ACHA,ACHA,ACHA,AMlBA,ACHA,A9E0OA,AMlBA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,AqD/JA,AMlBA,ACHA,ACHA,AhDgJA,AIZA,AQxBA,AgBhDA,ACHA,AKfA,ACHA,ACHA,ACHA,AMlBA,ACHA,A9E0OA,AMlBA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A2DjLA,ACHA,ACHA,AhDgJA,AIZA,AQxBA,AgBhDA,ACHA,AKfA,ACHA,ACHA,ACHA,AMlBA,ACHA,A9E0OA,AMlBA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A8D1LA,AHSA,ACHA,ACHA,AhDgJA,AIZA,AQxBA,AiBnDA,AKfA,ACHA,ACHA,ACHA,AMlBA,ACHA,A9E0OA,AMlBA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A8D1LA,AHSA,ACHA,ACHA,AhDgJA,AIZA,AQxBA,AiBnDA,AKfA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A8D1LA,AHSA,AENA,AhDgJA,AIZA,AQxBA,AiBnDA,AKfA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A+D7LA,ADGA,AHSA,AENA,AhDgJA,AIZA,AQxBA,AiBnDA,AKfA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A+D7LA,ADGA,AHSA,AENA,AhDgJA,AIZA,AQxBA,AiBnDA,AKfA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A+D7LA,ADGA,ADGA,AhDgJA,AIZA,AQxBA,AiBnDA,AKfA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A+D7LA,ACHA,AFMA,ADGA,AhDgJA,AIZA,AQxBA,AiBnDA,AKfA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A+D7LA,ACHA,AFMA,ADGA,AhDgJA,AIZA,AQxBA,AsBlEA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A+D7LA,ACHA,AHSA,AhDgJA,AIZA,AQxBA,AsBlEA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A+D7LA,ACHA,ACHA,AJYA,AhDgJA,AIZA,AQxBA,AsBlEA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A+D7LA,ACHA,ACHA,AJYA,AhDgJA,AIZA,AQxBA,AsBlEA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AOrBA,AHSA,AU9BA,ACHA,AKfA,A+D7LA,ACHA,ACHA,AJYA,AhDgJA,AIZA,AQxBA,AsBlEA,ACHA,ACHA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ALeA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ALeA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ALeA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ACHA,ANkBA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ACHA,ANkBA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ACHA,ANkBA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AMlBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ACHA,ANkBA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AkBtDA,AZoCA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ACHA,ANkBA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AkBtDA,AZoCA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ACHA,ANkBA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AkBtDA,AZoCA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,ACHA,ACHA,ACHA,ANkBA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AmBzDA,ADGA,AZoCA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AENA,ACHA,ANkBA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AmBzDA,ADGA,AZoCA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AENA,ACHA,ANkBA,AhDgJA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AmBzDA,ADGA,AZoCA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AENA,ACHA,AtDkKA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AmBzDA,ACHA,AFMA,AZoCA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AmBzDA,ACHA,AFMA,AZoCA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AmBzDA,ACHA,AFMA,AZoCA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AmBzDA,ACHA,AFMA,AGTA,Af6CA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AmBzDA,ACHA,AFMA,AGTA,Af6CA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AoB5DA,AFMA,AGTA,Af6CA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AIZA,AQxBA,AsBlEA,AENA,ACHA,AoB5DA,AFMA,AGTA,ACHA,AhBgDA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AsBlEA,AENA,ACHA,AoB5DA,ACHA,ACHA,AhBgDA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AsBlEA,AENA,ACHA,AqB/DA,Af6CA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AsBlEA,AENA,ACHA,AuBrEA,AFMA,Af6CA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AsBlEA,AENA,AwBxEA,AFMA,Af6CA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AsBlEA,AENA,AwBxEA,AjBmDA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AsBlEA,AENA,AwBxEA,ACHA,AlBsDA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AwBxEA,AwBxEA,ACHA,AlBsDA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AwBxEA,AwBxEA,AjBmDA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AwBxEA,AwBxEA,AENA,AnByDA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AwBxEA,AwBxEA,AENA,AnByDA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AwBxEA,AOrBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AYpCA,AwBxEA,A2BjFA,ApB4DA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AoC5GA,A2BjFA,ApB4DA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AoC5GA,A2BjFA,ApB4DA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AoC5GA,A2BjFA,ACHA,ArB+DA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AgEhMA,AGTA,AtDkKA,AoC5GA,A2BjFA,ACHA,ArB+DA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A2BjFA,ApB4DA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A2BjFA,AENA,AtBkEA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A2BjFA,AENA,AtBkEA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A2BjFA,ApB4DA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A8B1FA,AHSA,ApB4DA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A8B1FA,AvBqEA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A8B1FA,AvBqEA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A8B1FA,ACHA,AxBwEA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A8B1FA,ACHA,AxBwEA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A8B1FA,AvBqEA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A8B1FA,AENA,AzB2EA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A8B1FA,AENA,AzB2EA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,A8B1FA,AENA,AzB2EA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,Ae7CA,ArE+MA,AoC5GA,A8B1FA,AENA,AzB2EA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,Ae7CA,ArE+MA,AoC5GA,AgChGA,AzB2EA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,Ae7CA,ArE+MA,AoC5GA,AgChGA,AzB2EA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,Ae7CA,ArE+MA,AoC5GA,AgChGA,AzB2EA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AgChGA,AzB2EA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AOrBA,ACHA,AxEwNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AOrBA,AvEqNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AOrBA,AvEqNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AOrBA,AvEqNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AOrBA,AvEqNA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,AT2BA,AIZA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA,AqB/DA;AKdA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AKfA,AmEzMA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AwExNA,AtDkKA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,AoC5GA,AhEgMA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AkBtDA,A5BoFA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AU9BA,ACHA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtCkHA,AgBhDA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,AtBkEA,ALeA,AWjCA,AV8BA;A0B7EA,A3BiFA,AWjCA,AV8BA;A0B7EA,A3BiFA,AWjCA,AV8BA;A0B7EA,AhBgDA,AV8BA;A0B7EA,AhBgDA,AV8BA;A0B7EA,AhBgDA,AV8BA;A0B7EA,AhBgDA,AV8BA;A0B7EA,AhBgDA,AV8BA;A0B7EA,AhBgDA,AV8BA;A0B7EA,AhBgDA,AV8BA;A0B7EA,AhBgDA,AV8BA;A0B7EA,AhBgDA,AV8BA;A0B7EA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA,AhBgDA;AgB/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./syntax');\n","function merge() {\n    var dest = {};\n\n    for (var i = 0; i < arguments.length; i++) {\n        var src = arguments[i];\n        for (var key in src) {\n            dest[key] = src[key];\n        }\n    }\n\n    return dest;\n}\n\nmodule.exports = require('./create').create(\n    merge(\n        require('./config/lexer'),\n        require('./config/parser'),\n        require('./config/walker')\n    )\n);\n","var List = require('../common/List');\nvar SyntaxError = require('../common/SyntaxError');\nvar TokenStream = require('../common/TokenStream');\nvar Lexer = require('../lexer/Lexer');\nvar definitionSyntax = require('../definition-syntax');\nvar tokenize = require('../tokenizer');\nvar createParser = require('../parser/create');\nvar createGenerator = require('../generator/create');\nvar createConvertor = require('../convertor/create');\nvar createWalker = require('../walker/create');\nvar clone = require('../utils/clone');\nvar names = require('../utils/names');\nvar mix = require('./config/mix');\n\nfunction assign(dest, src) {\n    for (var key in src) {\n        dest[key] = src[key];\n    }\n\n    return dest;\n}\n\nfunction createSyntax(config) {\n    var parse = createParser(config);\n    var walk = createWalker(config);\n    var generate = createGenerator(config);\n    var convert = createConvertor(walk);\n\n    var syntax = {\n        List: List,\n        SyntaxError: SyntaxError,\n        TokenStream: TokenStream,\n        Lexer: Lexer,\n\n        vendorPrefix: names.vendorPrefix,\n        keyword: names.keyword,\n        property: names.property,\n        isCustomProperty: names.isCustomProperty,\n\n        definitionSyntax: definitionSyntax,\n        lexer: null,\n        createLexer: function(config) {\n            return new Lexer(config, syntax, syntax.lexer.structure);\n        },\n\n        tokenize: tokenize,\n        parse: parse,\n        walk: walk,\n        generate: generate,\n\n        find: walk.find,\n        findLast: walk.findLast,\n        findAll: walk.findAll,\n\n        clone: clone,\n        fromPlainObject: convert.fromPlainObject,\n        toPlainObject: convert.toPlainObject,\n\n        createSyntax: function(config) {\n            return createSyntax(mix({}, config));\n        },\n        fork: function(extension) {\n            var base = mix({}, config); // copy of config\n            return createSyntax(\n                typeof extension === 'function'\n                    ? extension(base, assign)\n                    : mix(base, extension)\n            );\n        }\n    };\n\n    syntax.lexer = new Lexer({\n        generic: true,\n        types: config.types,\n        properties: config.properties,\n        node: config.node\n    }, syntax);\n\n    return syntax;\n};\n\nexports.create = function(config) {\n    return createSyntax(mix({}, config));\n};\n","//\n//                              list\n//                            ┌──────┐\n//             ┌──────────────┼─head │\n//             │              │ tail─┼──────────────┐\n//             │              └──────┘              │\n//             ▼                                    ▼\n//            item        item        item        item\n//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐\n//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │\n//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null\n//          ├──────┤    ├──────┤    ├──────┤    ├──────┤\n//          │ data │    │ data │    │ data │    │ data │\n//          └──────┘    └──────┘    └──────┘    └──────┘\n//\n\nfunction createItem(data) {\n    return {\n        prev: null,\n        next: null,\n        data: data\n    };\n}\n\nfunction allocateCursor(node, prev, next) {\n    var cursor;\n\n    if (cursors !== null) {\n        cursor = cursors;\n        cursors = cursors.cursor;\n        cursor.prev = prev;\n        cursor.next = next;\n        cursor.cursor = node.cursor;\n    } else {\n        cursor = {\n            prev: prev,\n            next: next,\n            cursor: node.cursor\n        };\n    }\n\n    node.cursor = cursor;\n\n    return cursor;\n}\n\nfunction releaseCursor(node) {\n    var cursor = node.cursor;\n\n    node.cursor = cursor.cursor;\n    cursor.prev = null;\n    cursor.next = null;\n    cursor.cursor = cursors;\n    cursors = cursor;\n}\n\nvar cursors = null;\nvar List = function() {\n    this.cursor = null;\n    this.head = null;\n    this.tail = null;\n};\n\nList.createItem = createItem;\nList.prototype.createItem = createItem;\n\nList.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {\n    var cursor = this.cursor;\n\n    while (cursor !== null) {\n        if (cursor.prev === prevOld) {\n            cursor.prev = prevNew;\n        }\n\n        if (cursor.next === nextOld) {\n            cursor.next = nextNew;\n        }\n\n        cursor = cursor.cursor;\n    }\n};\n\nList.prototype.getSize = function() {\n    var size = 0;\n    var cursor = this.head;\n\n    while (cursor) {\n        size++;\n        cursor = cursor.next;\n    }\n\n    return size;\n};\n\nList.prototype.fromArray = function(array) {\n    var cursor = null;\n\n    this.head = null;\n\n    for (var i = 0; i < array.length; i++) {\n        var item = createItem(array[i]);\n\n        if (cursor !== null) {\n            cursor.next = item;\n        } else {\n            this.head = item;\n        }\n\n        item.prev = cursor;\n        cursor = item;\n    }\n\n    this.tail = cursor;\n\n    return this;\n};\n\nList.prototype.toArray = function() {\n    var cursor = this.head;\n    var result = [];\n\n    while (cursor) {\n        result.push(cursor.data);\n        cursor = cursor.next;\n    }\n\n    return result;\n};\n\nList.prototype.toJSON = List.prototype.toArray;\n\nList.prototype.isEmpty = function() {\n    return this.head === null;\n};\n\nList.prototype.first = function() {\n    return this.head && this.head.data;\n};\n\nList.prototype.last = function() {\n    return this.tail && this.tail.data;\n};\n\nList.prototype.each = function(fn, context) {\n    var item;\n\n    if (context === undefined) {\n        context = this;\n    }\n\n    // push cursor\n    var cursor = allocateCursor(this, null, this.head);\n\n    while (cursor.next !== null) {\n        item = cursor.next;\n        cursor.next = item.next;\n\n        fn.call(context, item.data, item, this);\n    }\n\n    // pop cursor\n    releaseCursor(this);\n};\n\nList.prototype.forEach = List.prototype.each;\n\nList.prototype.eachRight = function(fn, context) {\n    var item;\n\n    if (context === undefined) {\n        context = this;\n    }\n\n    // push cursor\n    var cursor = allocateCursor(this, this.tail, null);\n\n    while (cursor.prev !== null) {\n        item = cursor.prev;\n        cursor.prev = item.prev;\n\n        fn.call(context, item.data, item, this);\n    }\n\n    // pop cursor\n    releaseCursor(this);\n};\n\nList.prototype.forEachRight = List.prototype.eachRight;\n\nList.prototype.nextUntil = function(start, fn, context) {\n    if (start === null) {\n        return;\n    }\n\n    var item;\n\n    if (context === undefined) {\n        context = this;\n    }\n\n    // push cursor\n    var cursor = allocateCursor(this, null, start);\n\n    while (cursor.next !== null) {\n        item = cursor.next;\n        cursor.next = item.next;\n\n        if (fn.call(context, item.data, item, this)) {\n            break;\n        }\n    }\n\n    // pop cursor\n    releaseCursor(this);\n};\n\nList.prototype.prevUntil = function(start, fn, context) {\n    if (start === null) {\n        return;\n    }\n\n    var item;\n\n    if (context === undefined) {\n        context = this;\n    }\n\n    // push cursor\n    var cursor = allocateCursor(this, start, null);\n\n    while (cursor.prev !== null) {\n        item = cursor.prev;\n        cursor.prev = item.prev;\n\n        if (fn.call(context, item.data, item, this)) {\n            break;\n        }\n    }\n\n    // pop cursor\n    releaseCursor(this);\n};\n\nList.prototype.some = function(fn, context) {\n    var cursor = this.head;\n\n    if (context === undefined) {\n        context = this;\n    }\n\n    while (cursor !== null) {\n        if (fn.call(context, cursor.data, cursor, this)) {\n            return true;\n        }\n\n        cursor = cursor.next;\n    }\n\n    return false;\n};\n\nList.prototype.map = function(fn, context) {\n    var result = new List();\n    var cursor = this.head;\n\n    if (context === undefined) {\n        context = this;\n    }\n\n    while (cursor !== null) {\n        result.appendData(fn.call(context, cursor.data, cursor, this));\n        cursor = cursor.next;\n    }\n\n    return result;\n};\n\nList.prototype.filter = function(fn, context) {\n    var result = new List();\n    var cursor = this.head;\n\n    if (context === undefined) {\n        context = this;\n    }\n\n    while (cursor !== null) {\n        if (fn.call(context, cursor.data, cursor, this)) {\n            result.appendData(cursor.data);\n        }\n        cursor = cursor.next;\n    }\n\n    return result;\n};\n\nList.prototype.clear = function() {\n    this.head = null;\n    this.tail = null;\n};\n\nList.prototype.copy = function() {\n    var result = new List();\n    var cursor = this.head;\n\n    while (cursor !== null) {\n        result.insert(createItem(cursor.data));\n        cursor = cursor.next;\n    }\n\n    return result;\n};\n\nList.prototype.prepend = function(item) {\n    //      head\n    //    ^\n    // item\n    this.updateCursors(null, item, this.head, item);\n\n    // insert to the beginning of the list\n    if (this.head !== null) {\n        // new item <- first item\n        this.head.prev = item;\n\n        // new item -> first item\n        item.next = this.head;\n    } else {\n        // if list has no head, then it also has no tail\n        // in this case tail points to the new item\n        this.tail = item;\n    }\n\n    // head always points to new item\n    this.head = item;\n\n    return this;\n};\n\nList.prototype.prependData = function(data) {\n    return this.prepend(createItem(data));\n};\n\nList.prototype.append = function(item) {\n    return this.insert(item);\n};\n\nList.prototype.appendData = function(data) {\n    return this.insert(createItem(data));\n};\n\nList.prototype.insert = function(item, before) {\n    if (before !== undefined && before !== null) {\n        // prev   before\n        //      ^\n        //     item\n        this.updateCursors(before.prev, item, before, item);\n\n        if (before.prev === null) {\n            // insert to the beginning of list\n            if (this.head !== before) {\n                throw new Error('before doesn\\'t belong to list');\n            }\n\n            // since head points to before therefore list doesn't empty\n            // no need to check tail\n            this.head = item;\n            before.prev = item;\n            item.next = before;\n\n            this.updateCursors(null, item);\n        } else {\n\n            // insert between two items\n            before.prev.next = item;\n            item.prev = before.prev;\n\n            before.prev = item;\n            item.next = before;\n        }\n    } else {\n        // tail\n        //      ^\n        //      item\n        this.updateCursors(this.tail, item, null, item);\n\n        // insert to the ending of the list\n        if (this.tail !== null) {\n            // last item -> new item\n            this.tail.next = item;\n\n            // last item <- new item\n            item.prev = this.tail;\n        } else {\n            // if list has no tail, then it also has no head\n            // in this case head points to new item\n            this.head = item;\n        }\n\n        // tail always points to new item\n        this.tail = item;\n    }\n\n    return this;\n};\n\nList.prototype.insertData = function(data, before) {\n    return this.insert(createItem(data), before);\n};\n\nList.prototype.remove = function(item) {\n    //      item\n    //       ^\n    // prev     next\n    this.updateCursors(item, item.prev, item, item.next);\n\n    if (item.prev !== null) {\n        item.prev.next = item.next;\n    } else {\n        if (this.head !== item) {\n            throw new Error('item doesn\\'t belong to list');\n        }\n\n        this.head = item.next;\n    }\n\n    if (item.next !== null) {\n        item.next.prev = item.prev;\n    } else {\n        if (this.tail !== item) {\n            throw new Error('item doesn\\'t belong to list');\n        }\n\n        this.tail = item.prev;\n    }\n\n    item.prev = null;\n    item.next = null;\n\n    return item;\n};\n\nList.prototype.push = function(data) {\n    this.insert(createItem(data));\n};\n\nList.prototype.pop = function() {\n    if (this.tail !== null) {\n        return this.remove(this.tail);\n    }\n};\n\nList.prototype.unshift = function(data) {\n    this.prepend(createItem(data));\n};\n\nList.prototype.shift = function() {\n    if (this.head !== null) {\n        return this.remove(this.head);\n    }\n};\n\nList.prototype.prependList = function(list) {\n    return this.insertList(list, this.head);\n};\n\nList.prototype.appendList = function(list) {\n    return this.insertList(list);\n};\n\nList.prototype.insertList = function(list, before) {\n    // ignore empty lists\n    if (list.head === null) {\n        return this;\n    }\n\n    if (before !== undefined && before !== null) {\n        this.updateCursors(before.prev, list.tail, before, list.head);\n\n        // insert in the middle of dist list\n        if (before.prev !== null) {\n            // before.prev <-> list.head\n            before.prev.next = list.head;\n            list.head.prev = before.prev;\n        } else {\n            this.head = list.head;\n        }\n\n        before.prev = list.tail;\n        list.tail.next = before;\n    } else {\n        this.updateCursors(this.tail, list.tail, null, list.head);\n\n        // insert to end of the list\n        if (this.tail !== null) {\n            // if destination list has a tail, then it also has a head,\n            // but head doesn't change\n\n            // dest tail -> source head\n            this.tail.next = list.head;\n\n            // dest tail <- source head\n            list.head.prev = this.tail;\n        } else {\n            // if list has no a tail, then it also has no a head\n            // in this case points head to new item\n            this.head = list.head;\n        }\n\n        // tail always start point to new item\n        this.tail = list.tail;\n    }\n\n    list.head = null;\n    list.tail = null;\n\n    return this;\n};\n\nList.prototype.replace = function(oldItem, newItemOrList) {\n    if ('head' in newItemOrList) {\n        this.insertList(newItemOrList, oldItem);\n    } else {\n        this.insert(newItemOrList, oldItem);\n    }\n\n    this.remove(oldItem);\n};\n\nmodule.exports = List;\n","var createCustomError = require('../utils/createCustomError');\nvar MAX_LINE_LENGTH = 100;\nvar OFFSET_CORRECTION = 60;\nvar TAB_REPLACEMENT = '    ';\n\nfunction sourceFragment(error, extraLines) {\n    function processLines(start, end) {\n        return lines.slice(start, end).map(function(line, idx) {\n            var num = String(start + idx + 1);\n\n            while (num.length < maxNumLength) {\n                num = ' ' + num;\n            }\n\n            return num + ' |' + line;\n        }).join('\\n');\n    }\n\n    var lines = error.source.split(/\\r\\n?|\\n|\\f/);\n    var line = error.line;\n    var column = error.column;\n    var startLine = Math.max(1, line - extraLines) - 1;\n    var endLine = Math.min(line + extraLines, lines.length + 1);\n    var maxNumLength = Math.max(4, String(endLine).length) + 1;\n    var cutLeft = 0;\n\n    // column correction according to replaced tab before column\n    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\\t/g) || []).length;\n\n    if (column > MAX_LINE_LENGTH) {\n        cutLeft = column - OFFSET_CORRECTION + 3;\n        column = OFFSET_CORRECTION - 2;\n    }\n\n    for (var i = startLine; i <= endLine; i++) {\n        if (i >= 0 && i < lines.length) {\n            lines[i] = lines[i].replace(/\\t/g, TAB_REPLACEMENT);\n            lines[i] =\n                (cutLeft > 0 && lines[i].length > cutLeft ? '\\u2026' : '') +\n                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +\n                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\\u2026' : '');\n        }\n    }\n\n    return [\n        processLines(startLine, line),\n        new Array(column + maxNumLength + 2).join('-') + '^',\n        processLines(line, endLine)\n    ].filter(Boolean).join('\\n');\n}\n\nvar SyntaxError = function(message, source, offset, line, column) {\n    var error = createCustomError('SyntaxError', message);\n\n    error.source = source;\n    error.offset = offset;\n    error.line = line;\n    error.column = column;\n\n    error.sourceFragment = function(extraLines) {\n        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);\n    };\n    Object.defineProperty(error, 'formattedMessage', {\n        get: function() {\n            return (\n                'Parse error: ' + error.message + '\\n' +\n                sourceFragment(error, 2)\n            );\n        }\n    });\n\n    // for backward capability\n    error.parseError = {\n        offset: offset,\n        line: line,\n        column: column\n    };\n\n    return error;\n};\n\nmodule.exports = SyntaxError;\n","module.exports = function createCustomError(name, message) {\n    // use Object.create(), because some VMs prevent setting line/column otherwise\n    // (iOS Safari 10 even throws an exception)\n    var error = Object.create(SyntaxError.prototype);\n    var errorStack = new Error();\n\n    error.name = name;\n    error.message = message;\n\n    Object.defineProperty(error, 'stack', {\n        get: function() {\n            return (errorStack.stack || '').replace(/^(.+\\n){1,3}/, name + ': ' + message + '\\n');\n        }\n    });\n\n    return error;\n};\n","var constants = require('../tokenizer/const');\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\n\nvar utils = require('../tokenizer/utils');\nvar cmpStr = utils.cmpStr;\n\nvar EOF = TYPE.EOF;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\n\nvar OFFSET_MASK = 0x00FFFFFF;\nvar TYPE_SHIFT = 24;\n\nvar TokenStream = function() {\n    this.offsetAndType = null;\n    this.balance = null;\n\n    this.reset();\n};\n\nTokenStream.prototype = {\n    reset: function() {\n        this.eof = false;\n        this.tokenIndex = -1;\n        this.tokenType = 0;\n        this.tokenStart = this.firstCharOffset;\n        this.tokenEnd = this.firstCharOffset;\n    },\n\n    lookupType: function(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset] >> TYPE_SHIFT;\n        }\n\n        return EOF;\n    },\n    lookupOffset: function(offset) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return this.offsetAndType[offset - 1] & OFFSET_MASK;\n        }\n\n        return this.source.length;\n    },\n    lookupValue: function(offset, referenceStr) {\n        offset += this.tokenIndex;\n\n        if (offset < this.tokenCount) {\n            return cmpStr(\n                this.source,\n                this.offsetAndType[offset - 1] & OFFSET_MASK,\n                this.offsetAndType[offset] & OFFSET_MASK,\n                referenceStr\n            );\n        }\n\n        return false;\n    },\n    getTokenStart: function(tokenIndex) {\n        if (tokenIndex === this.tokenIndex) {\n            return this.tokenStart;\n        }\n\n        if (tokenIndex > 0) {\n            return tokenIndex < this.tokenCount\n                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK\n                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;\n        }\n\n        return this.firstCharOffset;\n    },\n\n    // TODO: -> skipUntilBalanced\n    getRawLength: function(startToken, mode) {\n        var cursor = startToken;\n        var balanceEnd;\n        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;\n        var type;\n\n        loop:\n        for (; cursor < this.tokenCount; cursor++) {\n            balanceEnd = this.balance[cursor];\n\n            // stop scanning on balance edge that points to offset before start token\n            if (balanceEnd < startToken) {\n                break loop;\n            }\n\n            type = this.offsetAndType[cursor] >> TYPE_SHIFT;\n\n            // check token is stop type\n            switch (mode(type, this.source, offset)) {\n                case 1:\n                    break loop;\n\n                case 2:\n                    cursor++;\n                    break loop;\n\n                default:\n                    offset = this.offsetAndType[cursor] & OFFSET_MASK;\n\n                    // fast forward to the end of balanced block\n                    if (this.balance[balanceEnd] === cursor) {\n                        cursor = balanceEnd;\n                    }\n            }\n        }\n\n        return cursor - this.tokenIndex;\n    },\n    isBalanceEdge: function(pos) {\n        return this.balance[this.tokenIndex] < pos;\n    },\n    isDelim: function(code, offset) {\n        if (offset) {\n            return (\n                this.lookupType(offset) === TYPE.Delim &&\n                this.source.charCodeAt(this.lookupOffset(offset)) === code\n            );\n        }\n\n        return (\n            this.tokenType === TYPE.Delim &&\n            this.source.charCodeAt(this.tokenStart) === code\n        );\n    },\n\n    getTokenValue: function() {\n        return this.source.substring(this.tokenStart, this.tokenEnd);\n    },\n    getTokenLength: function() {\n        return this.tokenEnd - this.tokenStart;\n    },\n    substrToCursor: function(start) {\n        return this.source.substring(start, this.tokenStart);\n    },\n\n    skipWS: function() {\n        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {\n            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {\n                break;\n            }\n        }\n\n        if (skipTokenCount > 0) {\n            this.skip(skipTokenCount);\n        }\n    },\n    skipSC: function() {\n        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {\n            this.next();\n        }\n    },\n    skip: function(tokenCount) {\n        var next = this.tokenIndex + tokenCount;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.next();\n        }\n    },\n    next: function() {\n        var next = this.tokenIndex + 1;\n\n        if (next < this.tokenCount) {\n            this.tokenIndex = next;\n            this.tokenStart = this.tokenEnd;\n            next = this.offsetAndType[next];\n            this.tokenType = next >> TYPE_SHIFT;\n            this.tokenEnd = next & OFFSET_MASK;\n        } else {\n            this.tokenIndex = this.tokenCount;\n            this.eof = true;\n            this.tokenType = EOF;\n            this.tokenStart = this.tokenEnd = this.source.length;\n        }\n    },\n\n    dump: function() {\n        var offset = this.firstCharOffset;\n\n        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {\n            var start = offset;\n            var end = item & OFFSET_MASK;\n\n            offset = end;\n\n            return {\n                idx: idx,\n                type: NAME[item >> TYPE_SHIFT],\n                chunk: this.source.substring(start, end),\n                balance: this.balance[idx]\n            };\n        }, this);\n    }\n};\n\nmodule.exports = TokenStream;\n","// CSS Syntax Module Level 3\n// https://www.w3.org/TR/css-syntax-3/\nvar TYPE = {\n    EOF: 0,                 // <EOF-token>\n    Ident: 1,               // <ident-token>\n    Function: 2,            // <function-token>\n    AtKeyword: 3,           // <at-keyword-token>\n    Hash: 4,                // <hash-token>\n    String: 5,              // <string-token>\n    BadString: 6,           // <bad-string-token>\n    Url: 7,                 // <url-token>\n    BadUrl: 8,              // <bad-url-token>\n    Delim: 9,               // <delim-token>\n    Number: 10,             // <number-token>\n    Percentage: 11,         // <percentage-token>\n    Dimension: 12,          // <dimension-token>\n    WhiteSpace: 13,         // <whitespace-token>\n    CDO: 14,                // <CDO-token>\n    CDC: 15,                // <CDC-token>\n    Colon: 16,              // <colon-token>     :\n    Semicolon: 17,          // <semicolon-token> ;\n    Comma: 18,              // <comma-token>     ,\n    LeftSquareBracket: 19,  // <[-token>\n    RightSquareBracket: 20, // <]-token>\n    LeftParenthesis: 21,    // <(-token>\n    RightParenthesis: 22,   // <)-token>\n    LeftCurlyBracket: 23,   // <{-token>\n    RightCurlyBracket: 24,  // <}-token>\n    Comment: 25\n};\n\nvar NAME = Object.keys(TYPE).reduce(function(result, key) {\n    result[TYPE[key]] = key;\n    return result;\n}, {});\n\nmodule.exports = {\n    TYPE: TYPE,\n    NAME: NAME\n};\n","var charCodeDef = require('./char-code-definitions');\nvar isDigit = charCodeDef.isDigit;\nvar isHexDigit = charCodeDef.isHexDigit;\nvar isUppercaseLetter = charCodeDef.isUppercaseLetter;\nvar isName = charCodeDef.isName;\nvar isWhiteSpace = charCodeDef.isWhiteSpace;\nvar isValidEscape = charCodeDef.isValidEscape;\n\nfunction getCharCode(source, offset) {\n    return offset < source.length ? source.charCodeAt(offset) : 0;\n}\n\nfunction getNewlineLength(source, offset, code) {\n    if (code === 13 /* \\r */ && getCharCode(source, offset + 1) === 10 /* \\n */) {\n        return 2;\n    }\n\n    return 1;\n}\n\nfunction cmpChar(testStr, offset, referenceCode) {\n    var code = testStr.charCodeAt(offset);\n\n    // code.toLowerCase() for A..Z\n    if (isUppercaseLetter(code)) {\n        code = code | 32;\n    }\n\n    return code === referenceCode;\n}\n\nfunction cmpStr(testStr, start, end, referenceStr) {\n    if (end - start !== referenceStr.length) {\n        return false;\n    }\n\n    if (start < 0 || end > testStr.length) {\n        return false;\n    }\n\n    for (var i = start; i < end; i++) {\n        var testCode = testStr.charCodeAt(i);\n        var referenceCode = referenceStr.charCodeAt(i - start);\n\n        // testCode.toLowerCase() for A..Z\n        if (isUppercaseLetter(testCode)) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction findWhiteSpaceStart(source, offset) {\n    for (; offset >= 0; offset--) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset + 1;\n}\n\nfunction findWhiteSpaceEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isWhiteSpace(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\nfunction findDecimalNumberEnd(source, offset) {\n    for (; offset < source.length; offset++) {\n        if (!isDigit(source.charCodeAt(offset))) {\n            break;\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.7. Consume an escaped code point\nfunction consumeEscaped(source, offset) {\n    // It assumes that the U+005C REVERSE SOLIDUS (\\) has already been consumed and\n    // that the next input code point has already been verified to be part of a valid escape.\n    offset += 2;\n\n    // hex digit\n    if (isHexDigit(getCharCode(source, offset - 1))) {\n        // Consume as many hex digits as possible, but no more than 5.\n        // Note that this means 1-6 hex digits have been consumed in total.\n        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {\n            if (!isHexDigit(getCharCode(source, offset))) {\n                break;\n            }\n        }\n\n        // If the next input code point is whitespace, consume it as well.\n        var code = getCharCode(source, offset);\n        if (isWhiteSpace(code)) {\n            offset += getNewlineLength(source, offset, code);\n        }\n    }\n\n    return offset;\n}\n\n// §4.3.11. Consume a name\n// Note: This algorithm does not do the verification of the first few code points that are necessary\n// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,\n// ensure that the stream starts with an identifier before calling this algorithm.\nfunction consumeName(source, offset) {\n    // Let result initially be an empty string.\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        var code = source.charCodeAt(offset);\n\n        // name code point\n        if (isName(code)) {\n            // Append the code point to result.\n            continue;\n        }\n\n        // the stream starts with a valid escape\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point. Append the returned code point to result.\n            offset = consumeEscaped(source, offset) - 1;\n            continue;\n        }\n\n        // anything else\n        // Reconsume the current input code point. Return result.\n        break;\n    }\n\n    return offset;\n}\n\n// §4.3.12. Consume a number\nfunction consumeNumber(source, offset) {\n    var code = source.charCodeAt(offset);\n\n    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),\n    // consume it and append it to repr.\n    if (code === 0x002B || code === 0x002D) {\n        code = source.charCodeAt(offset += 1);\n    }\n\n    // 3. While the next input code point is a digit, consume it and append it to repr.\n    if (isDigit(code)) {\n        offset = findDecimalNumberEnd(source, offset + 1);\n        code = source.charCodeAt(offset);\n    }\n\n    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:\n    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {\n        // 4.1 Consume them.\n        // 4.2 Append them to repr.\n        code = source.charCodeAt(offset += 2);\n\n        // 4.3 Set type to \"number\".\n        // TODO\n\n        // 4.4 While the next input code point is a digit, consume it and append it to repr.\n\n        offset = findDecimalNumberEnd(source, offset);\n    }\n\n    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)\n    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:\n    if (cmpChar(source, offset, 101 /* e */)) {\n        var sign = 0;\n        code = source.charCodeAt(offset + 1);\n\n        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...\n        if (code === 0x002D || code === 0x002B) {\n            sign = 1;\n            code = source.charCodeAt(offset + 2);\n        }\n\n        // ... followed by a digit\n        if (isDigit(code)) {\n            // 5.1 Consume them.\n            // 5.2 Append them to repr.\n\n            // 5.3 Set type to \"number\".\n            // TODO\n\n            // 5.4 While the next input code point is a digit, consume it and append it to repr.\n            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);\n        }\n    }\n\n    return offset;\n}\n\n// § 4.3.14. Consume the remnants of a bad url\n// ... its sole use is to consume enough of the input stream to reach a recovery point\n// where normal tokenizing can resume.\nfunction consumeBadUrlRemnants(source, offset) {\n    // Repeatedly consume the next input code point from the stream:\n    for (; offset < source.length; offset++) {\n        var code = source.charCodeAt(offset);\n\n        // U+0029 RIGHT PARENTHESIS ())\n        // EOF\n        if (code === 0x0029) {\n            // Return.\n            offset++;\n            break;\n        }\n\n        if (isValidEscape(code, getCharCode(source, offset + 1))) {\n            // Consume an escaped code point.\n            // Note: This allows an escaped right parenthesis (\"\\)\") to be encountered\n            // without ending the <bad-url-token>. This is otherwise identical to\n            // the \"anything else\" clause.\n            offset = consumeEscaped(source, offset);\n        }\n    }\n\n    return offset;\n}\n\nmodule.exports = {\n    consumeEscaped: consumeEscaped,\n    consumeName: consumeName,\n    consumeNumber: consumeNumber,\n    consumeBadUrlRemnants: consumeBadUrlRemnants,\n\n    cmpChar: cmpChar,\n    cmpStr: cmpStr,\n\n    getNewlineLength: getNewlineLength,\n    findWhiteSpaceStart: findWhiteSpaceStart,\n    findWhiteSpaceEnd: findWhiteSpaceEnd\n};\n","var EOF = 0;\n\n// https://drafts.csswg.org/css-syntax-3/\n// § 4.2. Definitions\n\n// digit\n// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).\nfunction isDigit(code) {\n    return code >= 0x0030 && code <= 0x0039;\n}\n\n// hex digit\n// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),\n// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).\nfunction isHexDigit(code) {\n    return (\n        isDigit(code) || // 0 .. 9\n        (code >= 0x0041 && code <= 0x0046) || // A .. F\n        (code >= 0x0061 && code <= 0x0066)    // a .. f\n    );\n}\n\n// uppercase letter\n// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).\nfunction isUppercaseLetter(code) {\n    return code >= 0x0041 && code <= 0x005A;\n}\n\n// lowercase letter\n// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).\nfunction isLowercaseLetter(code) {\n    return code >= 0x0061 && code <= 0x007A;\n}\n\n// letter\n// An uppercase letter or a lowercase letter.\nfunction isLetter(code) {\n    return isUppercaseLetter(code) || isLowercaseLetter(code);\n}\n\n// non-ASCII code point\n// A code point with a value equal to or greater than U+0080 <control>.\nfunction isNonAscii(code) {\n    return code >= 0x0080;\n}\n\n// name-start code point\n// A letter, a non-ASCII code point, or U+005F LOW LINE (_).\nfunction isNameStart(code) {\n    return isLetter(code) || isNonAscii(code) || code === 0x005F;\n}\n\n// name code point\n// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).\nfunction isName(code) {\n    return isNameStart(code) || isDigit(code) || code === 0x002D;\n}\n\n// non-printable code point\n// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,\n// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.\nfunction isNonPrintable(code) {\n    return (\n        (code >= 0x0000 && code <= 0x0008) ||\n        (code === 0x000B) ||\n        (code >= 0x000E && code <= 0x001F) ||\n        (code === 0x007F)\n    );\n}\n\n// newline\n// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,\n// as they are converted to U+000A LINE FEED during preprocessing.\n// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED\nfunction isNewline(code) {\n    return code === 0x000A || code === 0x000D || code === 0x000C;\n}\n\n// whitespace\n// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.\nfunction isWhiteSpace(code) {\n    return isNewline(code) || code === 0x0020 || code === 0x0009;\n}\n\n// § 4.3.8. Check if two code points are a valid escape\nfunction isValidEscape(first, second) {\n    // If the first code point is not U+005C REVERSE SOLIDUS (\\), return false.\n    if (first !== 0x005C) {\n        return false;\n    }\n\n    // Otherwise, if the second code point is a newline or EOF, return false.\n    if (isNewline(second) || second === EOF) {\n        return false;\n    }\n\n    // Otherwise, return true.\n    return true;\n}\n\n// § 4.3.9. Check if three code points would start an identifier\nfunction isIdentifierStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002D HYPHEN-MINUS\n    if (first === 0x002D) {\n        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,\n        // or the second and third code points are a valid escape, return true. Otherwise, return false.\n        return (\n            isNameStart(second) ||\n            second === 0x002D ||\n            isValidEscape(second, third)\n        );\n    }\n\n    // name-start code point\n    if (isNameStart(first)) {\n        // Return true.\n        return true;\n    }\n\n    // U+005C REVERSE SOLIDUS (\\)\n    if (first === 0x005C) {\n        // If the first and second code points are a valid escape, return true. Otherwise, return false.\n        return isValidEscape(first, second);\n    }\n\n    // anything else\n    // Return false.\n    return false;\n}\n\n// § 4.3.10. Check if three code points would start a number\nfunction isNumberStart(first, second, third) {\n    // Look at the first code point:\n\n    // U+002B PLUS SIGN (+)\n    // U+002D HYPHEN-MINUS (-)\n    if (first === 0x002B || first === 0x002D) {\n        // If the second code point is a digit, return true.\n        if (isDigit(second)) {\n            return 2;\n        }\n\n        // Otherwise, if the second code point is a U+002E FULL STOP (.)\n        // and the third code point is a digit, return true.\n        // Otherwise, return false.\n        return second === 0x002E && isDigit(third) ? 3 : 0;\n    }\n\n    // U+002E FULL STOP (.)\n    if (first === 0x002E) {\n        // If the second code point is a digit, return true. Otherwise, return false.\n        return isDigit(second) ? 2 : 0;\n    }\n\n    // digit\n    if (isDigit(first)) {\n        // Return true.\n        return 1;\n    }\n\n    // anything else\n    // Return false.\n    return 0;\n}\n\n//\n// Misc\n//\n\n// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)\nfunction isBOM(code) {\n    // UTF-16BE\n    if (code === 0xFEFF) {\n        return 1;\n    }\n\n    // UTF-16LE\n    if (code === 0xFFFE) {\n        return 1;\n    }\n\n    return 0;\n}\n\n// Fast code category\n//\n// https://drafts.csswg.org/css-syntax/#tokenizer-definitions\n// > non-ASCII code point\n// >   A code point with a value equal to or greater than U+0080 <control>\n// > name-start code point\n// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).\n// > name code point\n// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)\n// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only\nvar CATEGORY = new Array(0x80);\ncharCodeCategory.Eof = 0x80;\ncharCodeCategory.WhiteSpace = 0x82;\ncharCodeCategory.Digit = 0x83;\ncharCodeCategory.NameStart = 0x84;\ncharCodeCategory.NonPrintable = 0x85;\n\nfor (var i = 0; i < CATEGORY.length; i++) {\n    switch (true) {\n        case isWhiteSpace(i):\n            CATEGORY[i] = charCodeCategory.WhiteSpace;\n            break;\n\n        case isDigit(i):\n            CATEGORY[i] = charCodeCategory.Digit;\n            break;\n\n        case isNameStart(i):\n            CATEGORY[i] = charCodeCategory.NameStart;\n            break;\n\n        case isNonPrintable(i):\n            CATEGORY[i] = charCodeCategory.NonPrintable;\n            break;\n\n        default:\n            CATEGORY[i] = i || charCodeCategory.Eof;\n    }\n}\n\nfunction charCodeCategory(code) {\n    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;\n};\n\nmodule.exports = {\n    isDigit: isDigit,\n    isHexDigit: isHexDigit,\n    isUppercaseLetter: isUppercaseLetter,\n    isLowercaseLetter: isLowercaseLetter,\n    isLetter: isLetter,\n    isNonAscii: isNonAscii,\n    isNameStart: isNameStart,\n    isName: isName,\n    isNonPrintable: isNonPrintable,\n    isNewline: isNewline,\n    isWhiteSpace: isWhiteSpace,\n    isValidEscape: isValidEscape,\n    isIdentifierStart: isIdentifierStart,\n    isNumberStart: isNumberStart,\n\n    isBOM: isBOM,\n    charCodeCategory: charCodeCategory\n};\n","var SyntaxReferenceError = require('./error').SyntaxReferenceError;\nvar MatchError = require('./error').MatchError;\nvar names = require('../utils/names');\nvar generic = require('./generic');\nvar parse = require('../definition-syntax/parse');\nvar generate = require('../definition-syntax/generate');\nvar walk = require('../definition-syntax/walk');\nvar prepareTokens = require('./prepare-tokens');\nvar buildMatchGraph = require('./match-graph').buildMatchGraph;\nvar matchAsTree = require('./match').matchAsTree;\nvar trace = require('./trace');\nvar search = require('./search');\nvar getStructureFromConfig = require('./structure').getStructureFromConfig;\nvar cssWideKeywords = buildMatchGraph('inherit | initial | unset');\nvar cssWideKeywordsWithExpression = buildMatchGraph('inherit | initial | unset | <-ms-legacy-expression>');\n\nfunction dumpMapSyntax(map, compact, syntaxAsAst) {\n    var result = {};\n\n    for (var name in map) {\n        if (map[name].syntax) {\n            result[name] = syntaxAsAst\n                ? map[name].syntax\n                : generate(map[name].syntax, { compact: compact });\n        }\n    }\n\n    return result;\n}\n\nfunction valueHasVar(tokens) {\n    for (var i = 0; i < tokens.length; i++) {\n        if (tokens[i].value.toLowerCase() === 'var(') {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction buildMatchResult(match, error, iterations) {\n    return {\n        matched: match,\n        iterations: iterations,\n        error: error,\n        getTrace: trace.getTrace,\n        isType: trace.isType,\n        isProperty: trace.isProperty,\n        isKeyword: trace.isKeyword\n    };\n}\n\nfunction matchSyntax(lexer, syntax, value, useCommon) {\n    var tokens = prepareTokens(value, lexer.syntax);\n    var result;\n\n    if (valueHasVar(tokens)) {\n        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));\n    }\n\n    if (useCommon) {\n        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);\n    }\n\n    if (!useCommon || !result.match) {\n        result = matchAsTree(tokens, syntax.match, lexer);\n        if (!result.match) {\n            return buildMatchResult(\n                null,\n                new MatchError(result.reason, syntax.syntax, value, result),\n                result.iterations\n            );\n        }\n    }\n\n    return buildMatchResult(result.match, null, result.iterations);\n}\n\nvar Lexer = function(config, syntax, structure) {\n    this.valueCommonSyntax = cssWideKeywords;\n    this.syntax = syntax;\n    this.generic = false;\n    this.properties = {};\n    this.types = {};\n    this.structure = structure || getStructureFromConfig(config);\n\n    if (config) {\n        if (config.types) {\n            for (var name in config.types) {\n                this.addType_(name, config.types[name]);\n            }\n        }\n\n        if (config.generic) {\n            this.generic = true;\n            for (var name in generic) {\n                this.addType_(name, generic[name]);\n            }\n        }\n\n        if (config.properties) {\n            for (var name in config.properties) {\n                this.addProperty_(name, config.properties[name]);\n            }\n        }\n    }\n};\n\nLexer.prototype = {\n    structure: {},\n    checkStructure: function(ast) {\n        function collectWarning(node, message) {\n            warns.push({\n                node: node,\n                message: message\n            });\n        }\n\n        var structure = this.structure;\n        var warns = [];\n\n        this.syntax.walk(ast, function(node) {\n            if (structure.hasOwnProperty(node.type)) {\n                structure[node.type].check(node, collectWarning);\n            } else {\n                collectWarning(node, 'Unknown node type `' + node.type + '`');\n            }\n        });\n\n        return warns.length ? warns : false;\n    },\n\n    createDescriptor: function(syntax, type, name) {\n        var ref = {\n            type: type,\n            name: name\n        };\n        var descriptor = {\n            type: type,\n            name: name,\n            syntax: null,\n            match: null\n        };\n\n        if (typeof syntax === 'function') {\n            descriptor.match = buildMatchGraph(syntax, ref);\n        } else {\n            if (typeof syntax === 'string') {\n                // lazy parsing on first access\n                Object.defineProperty(descriptor, 'syntax', {\n                    get: function() {\n                        Object.defineProperty(descriptor, 'syntax', {\n                            value: parse(syntax)\n                        });\n\n                        return descriptor.syntax;\n                    }\n                });\n            } else {\n                descriptor.syntax = syntax;\n            }\n\n            // lazy graph build on first access\n            Object.defineProperty(descriptor, 'match', {\n                get: function() {\n                    Object.defineProperty(descriptor, 'match', {\n                        value: buildMatchGraph(descriptor.syntax, ref)\n                    });\n\n                    return descriptor.match;\n                }\n            });\n        }\n\n        return descriptor;\n    },\n    addProperty_: function(name, syntax) {\n        this.properties[name] = this.createDescriptor(syntax, 'Property', name);\n    },\n    addType_: function(name, syntax) {\n        this.types[name] = this.createDescriptor(syntax, 'Type', name);\n\n        if (syntax === generic['-ms-legacy-expression']) {\n            this.valueCommonSyntax = cssWideKeywordsWithExpression;\n        }\n    },\n\n    matchDeclaration: function(node) {\n        if (node.type !== 'Declaration') {\n            return buildMatchResult(null, new Error('Not a Declaration node'));\n        }\n\n        return this.matchProperty(node.property, node.value);\n    },\n    matchProperty: function(propertyName, value) {\n        var property = names.property(propertyName);\n\n        // don't match syntax for a custom property\n        if (property.custom) {\n            return buildMatchResult(null, new Error('Lexer matching doesn\\'t applicable for custom properties'));\n        }\n\n        var propertySyntax = property.vendor\n            ? this.getProperty(property.name) || this.getProperty(property.basename)\n            : this.getProperty(property.name);\n\n        if (!propertySyntax) {\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown property', propertyName));\n        }\n\n        return matchSyntax(this, propertySyntax, value, true);\n    },\n    matchType: function(typeName, value) {\n        var typeSyntax = this.getType(typeName);\n\n        if (!typeSyntax) {\n            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));\n        }\n\n        return matchSyntax(this, typeSyntax, value, false);\n    },\n    match: function(syntax, value) {\n        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {\n            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));\n        }\n\n        if (typeof syntax === 'string' || !syntax.match) {\n            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');\n        }\n\n        return matchSyntax(this, syntax, value, false);\n    },\n\n    findValueFragments: function(propertyName, value, type, name) {\n        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);\n    },\n    findDeclarationValueFragments: function(declaration, type, name) {\n        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);\n    },\n    findAllFragments: function(ast, type, name) {\n        var result = [];\n\n        this.syntax.walk(ast, {\n            visit: 'Declaration',\n            enter: function(declaration) {\n                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));\n            }.bind(this)\n        });\n\n        return result;\n    },\n\n    getProperty: function(name) {\n        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;\n    },\n    getType: function(name) {\n        return this.types.hasOwnProperty(name) ? this.types[name] : null;\n    },\n\n    validate: function() {\n        function validate(syntax, name, broken, descriptor) {\n            if (broken.hasOwnProperty(name)) {\n                return broken[name];\n            }\n\n            broken[name] = false;\n            if (descriptor.syntax !== null) {\n                walk(descriptor.syntax, function(node) {\n                    if (node.type !== 'Type' && node.type !== 'Property') {\n                        return;\n                    }\n\n                    var map = node.type === 'Type' ? syntax.types : syntax.properties;\n                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;\n\n                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {\n                        broken[name] = true;\n                    }\n                }, this);\n            }\n        }\n\n        var brokenTypes = {};\n        var brokenProperties = {};\n\n        for (var key in this.types) {\n            validate(this, key, brokenTypes, this.types[key]);\n        }\n\n        for (var key in this.properties) {\n            validate(this, key, brokenProperties, this.properties[key]);\n        }\n\n        brokenTypes = Object.keys(brokenTypes).filter(function(name) {\n            return brokenTypes[name];\n        });\n        brokenProperties = Object.keys(brokenProperties).filter(function(name) {\n            return brokenProperties[name];\n        });\n\n        if (brokenTypes.length || brokenProperties.length) {\n            return {\n                types: brokenTypes,\n                properties: brokenProperties\n            };\n        }\n\n        return null;\n    },\n    dump: function(syntaxAsAst, pretty) {\n        return {\n            generic: this.generic,\n            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),\n            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)\n        };\n    },\n    toString: function() {\n        return JSON.stringify(this.dump());\n    }\n};\n\nmodule.exports = Lexer;\n","var createCustomError = require('../utils/createCustomError');\nvar generate = require('../definition-syntax/generate');\n\nfunction fromMatchResult(matchResult) {\n    var tokens = matchResult.tokens;\n    var longestMatch = matchResult.longestMatch;\n    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;\n    var mismatchOffset = -1;\n    var entries = 0;\n    var css = '';\n\n    for (var i = 0; i < tokens.length; i++) {\n        if (i === longestMatch) {\n            mismatchOffset = css.length;\n        }\n\n        if (node !== null && tokens[i].node === node) {\n            if (i <= longestMatch) {\n                entries++;\n            } else {\n                entries = 0;\n            }\n        }\n\n        css += tokens[i].value;\n    }\n\n    return {\n        node: node,\n        css: css,\n        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,\n        last: node === null || entries > 1\n    };\n}\n\nfunction getLocation(node, point) {\n    var loc = node && node.loc && node.loc[point];\n\n    if (loc) {\n        return {\n            offset: loc.offset,\n            line: loc.line,\n            column: loc.column\n        };\n    }\n\n    return null;\n}\n\nvar SyntaxReferenceError = function(type, referenceName) {\n    var error = createCustomError(\n        'SyntaxReferenceError',\n        type + (referenceName ? ' `' + referenceName + '`' : '')\n    );\n\n    error.reference = referenceName;\n\n    return error;\n};\n\nvar MatchError = function(message, syntax, node, matchResult) {\n    var error = createCustomError('SyntaxMatchError', message);\n    var details = fromMatchResult(matchResult);\n    var mismatchOffset = details.mismatchOffset || 0;\n    var badNode = details.node || node;\n    var end = getLocation(badNode, 'end');\n    var start = details.last ? end : getLocation(badNode, 'start');\n    var css = details.css;\n\n    error.rawMessage = message;\n    error.syntax = syntax ? generate(syntax) : '<generic>';\n    error.css = css;\n    error.mismatchOffset = mismatchOffset;\n    error.loc = {\n        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',\n        start: start,\n        end: end\n    };\n    error.line = start ? start.line : undefined;\n    error.column = start ? start.column : undefined;\n    error.offset = start ? start.offset : undefined;\n    error.message = message + '\\n' +\n        '  syntax: ' + error.syntax + '\\n' +\n        '   value: ' + (error.css || '<empty string>') + '\\n' +\n        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';\n\n    return error;\n};\n\nmodule.exports = {\n    SyntaxReferenceError: SyntaxReferenceError,\n    MatchError: MatchError\n};\n","function noop(value) {\n    return value;\n}\n\nfunction generateMultiplier(multiplier) {\n    if (multiplier.min === 0 && multiplier.max === 0) {\n        return '*';\n    }\n\n    if (multiplier.min === 0 && multiplier.max === 1) {\n        return '?';\n    }\n\n    if (multiplier.min === 1 && multiplier.max === 0) {\n        return multiplier.comma ? '#' : '+';\n    }\n\n    if (multiplier.min === 1 && multiplier.max === 1) {\n        return '';\n    }\n\n    return (\n        (multiplier.comma ? '#' : '') +\n        (multiplier.min === multiplier.max\n            ? '{' + multiplier.min + '}'\n            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'\n        )\n    );\n}\n\nfunction generateTypeOpts(node) {\n    switch (node.type) {\n        case 'Range':\n            return (\n                ' [' +\n                (node.min === null ? '-∞' : node.min) +\n                ',' +\n                (node.max === null ? '∞' : node.max) +\n                ']'\n            );\n\n        default:\n            throw new Error('Unknown node type `' + node.type + '`');\n    }\n}\n\nfunction generateSequence(node, decorate, forceBraces, compact) {\n    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';\n    var result = node.terms.map(function(term) {\n        return generate(term, decorate, forceBraces, compact);\n    }).join(combinator);\n\n    if (node.explicit || forceBraces) {\n        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');\n    }\n\n    return result;\n}\n\nfunction generate(node, decorate, forceBraces, compact) {\n    var result;\n\n    switch (node.type) {\n        case 'Group':\n            result =\n                generateSequence(node, decorate, forceBraces, compact) +\n                (node.disallowEmpty ? '!' : '');\n            break;\n\n        case 'Multiplier':\n            // return since node is a composition\n            return (\n                generate(node.term, decorate, forceBraces, compact) +\n                decorate(generateMultiplier(node), node)\n            );\n\n        case 'Type':\n            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';\n            break;\n\n        case 'Property':\n            result = '<\\'' + node.name + '\\'>';\n            break;\n\n        case 'Keyword':\n            result = node.name;\n            break;\n\n        case 'AtKeyword':\n            result = '@' + node.name;\n            break;\n\n        case 'Function':\n            result = node.name + '(';\n            break;\n\n        case 'String':\n        case 'Token':\n            result = node.value;\n            break;\n\n        case 'Comma':\n            result = ',';\n            break;\n\n        default:\n            throw new Error('Unknown node type `' + node.type + '`');\n    }\n\n    return decorate(result, node);\n}\n\nmodule.exports = function(node, options) {\n    var decorate = noop;\n    var forceBraces = false;\n    var compact = false;\n\n    if (typeof options === 'function') {\n        decorate = options;\n    } else if (options) {\n        forceBraces = Boolean(options.forceBraces);\n        compact = Boolean(options.compact);\n        if (typeof options.decorate === 'function') {\n            decorate = options.decorate;\n        }\n    }\n\n    return generate(node, decorate, forceBraces, compact);\n};\n","var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar keywords = Object.create(null);\nvar properties = Object.create(null);\nvar HYPHENMINUS = 45; // '-'.charCodeAt()\n\nfunction isCustomProperty(str, offset) {\n    offset = offset || 0;\n\n    return str.length - offset >= 2 &&\n           str.charCodeAt(offset) === HYPHENMINUS &&\n           str.charCodeAt(offset + 1) === HYPHENMINUS;\n}\n\nfunction getVendorPrefix(str, offset) {\n    offset = offset || 0;\n\n    // verdor prefix should be at least 3 chars length\n    if (str.length - offset >= 3) {\n        // vendor prefix starts with hyper minus following non-hyper minus\n        if (str.charCodeAt(offset) === HYPHENMINUS &&\n            str.charCodeAt(offset + 1) !== HYPHENMINUS) {\n            // vendor prefix should contain a hyper minus at the ending\n            var secondDashIndex = str.indexOf('-', offset + 2);\n\n            if (secondDashIndex !== -1) {\n                return str.substring(offset, secondDashIndex + 1);\n            }\n        }\n    }\n\n    return '';\n}\n\nfunction getKeywordDescriptor(keyword) {\n    if (hasOwnProperty.call(keywords, keyword)) {\n        return keywords[keyword];\n    }\n\n    var name = keyword.toLowerCase();\n\n    if (hasOwnProperty.call(keywords, name)) {\n        return keywords[keyword] = keywords[name];\n    }\n\n    var custom = isCustomProperty(name, 0);\n    var vendor = !custom ? getVendorPrefix(name, 0) : '';\n\n    return keywords[keyword] = Object.freeze({\n        basename: name.substr(vendor.length),\n        name: name,\n        vendor: vendor,\n        prefix: vendor,\n        custom: custom\n    });\n}\n\nfunction getPropertyDescriptor(property) {\n    if (hasOwnProperty.call(properties, property)) {\n        return properties[property];\n    }\n\n    var name = property;\n    var hack = property[0];\n\n    if (hack === '/') {\n        hack = property[1] === '/' ? '//' : '/';\n    } else if (hack !== '_' &&\n               hack !== '*' &&\n               hack !== '$' &&\n               hack !== '#' &&\n               hack !== '+' &&\n               hack !== '&') {\n        hack = '';\n    }\n\n    var custom = isCustomProperty(name, hack.length);\n\n    // re-use result when possible (the same as for lower case)\n    if (!custom) {\n        name = name.toLowerCase();\n        if (hasOwnProperty.call(properties, name)) {\n            return properties[property] = properties[name];\n        }\n    }\n\n    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';\n    var prefix = name.substr(0, hack.length + vendor.length);\n\n    return properties[property] = Object.freeze({\n        basename: name.substr(prefix.length),\n        name: name.substr(hack.length),\n        hack: hack,\n        vendor: vendor,\n        prefix: prefix,\n        custom: custom\n    });\n}\n\nmodule.exports = {\n    keyword: getKeywordDescriptor,\n    property: getPropertyDescriptor,\n    isCustomProperty: isCustomProperty,\n    vendorPrefix: getVendorPrefix\n};\n","var tokenizer = require('../tokenizer');\nvar isIdentifierStart = tokenizer.isIdentifierStart;\nvar isHexDigit = tokenizer.isHexDigit;\nvar isDigit = tokenizer.isDigit;\nvar cmpStr = tokenizer.cmpStr;\nvar consumeNumber = tokenizer.consumeNumber;\nvar TYPE = tokenizer.TYPE;\nvar anPlusB = require('./generic-an-plus-b');\nvar urange = require('./generic-urange');\n\nvar cssWideKeywords = ['unset', 'initial', 'inherit'];\nvar calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];\n\n// https://www.w3.org/TR/css-values-3/#lengths\nvar LENGTH = {\n    // absolute length units\n    'px': true,\n    'mm': true,\n    'cm': true,\n    'in': true,\n    'pt': true,\n    'pc': true,\n    'q': true,\n\n    // relative length units\n    'em': true,\n    'ex': true,\n    'ch': true,\n    'rem': true,\n\n    // viewport-percentage lengths\n    'vh': true,\n    'vw': true,\n    'vmin': true,\n    'vmax': true,\n    'vm': true\n};\n\nvar ANGLE = {\n    'deg': true,\n    'grad': true,\n    'rad': true,\n    'turn': true\n};\n\nvar TIME = {\n    's': true,\n    'ms': true\n};\n\nvar FREQUENCY = {\n    'hz': true,\n    'khz': true\n};\n\n// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)\nvar RESOLUTION = {\n    'dpi': true,\n    'dpcm': true,\n    'dppx': true,\n    'x': true      // https://github.com/w3c/csswg-drafts/issues/461\n};\n\n// https://drafts.csswg.org/css-grid/#fr-unit\nvar FLEX = {\n    'fr': true\n};\n\n// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume\nvar DECIBEL = {\n    'db': true\n};\n\n// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch\nvar SEMITONES = {\n    'st': true\n};\n\n// safe char code getter\nfunction charCode(str, index) {\n    return index < str.length ? str.charCodeAt(index) : 0;\n}\n\nfunction eqStr(actual, expected) {\n    return cmpStr(actual, 0, actual.length, expected);\n}\n\nfunction eqStrAny(actual, expected) {\n    for (var i = 0; i < expected.length; i++) {\n        if (eqStr(actual, expected[i])) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\n// IE postfix hack, i.e. 123\\0 or 123px\\9\nfunction isPostfixIeHack(str, offset) {\n    if (offset !== str.length - 2) {\n        return false;\n    }\n\n    return (\n        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\\)\n        isDigit(str.charCodeAt(offset + 1))\n    );\n}\n\nfunction outOfRange(opts, value, numEnd) {\n    if (opts && opts.type === 'Range') {\n        var num = Number(\n            numEnd !== undefined && numEnd !== value.length\n                ? value.substr(0, numEnd)\n                : value\n        );\n\n        if (isNaN(num)) {\n            return true;\n        }\n\n        if (opts.min !== null && num < opts.min) {\n            return true;\n        }\n\n        if (opts.max !== null && num > opts.max) {\n            return true;\n        }\n    }\n\n    return false;\n}\n\nfunction consumeFunction(token, getNextToken) {\n    var startIdx = token.index;\n    var length = 0;\n\n    // balanced token consuming\n    do {\n        length++;\n\n        if (token.balance <= startIdx) {\n            break;\n        }\n    } while (token = getNextToken(length));\n\n    return length;\n}\n\n// TODO: implement\n// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed\n// https://drafts.csswg.org/css-values/#calc-notation\nfunction calc(next) {\n    return function(token, getNextToken, opts) {\n        if (token === null) {\n            return 0;\n        }\n\n        if (token.type === TYPE.Function && eqStrAny(token.value, calcFunctionNames)) {\n            return consumeFunction(token, getNextToken);\n        }\n\n        return next(token, getNextToken, opts);\n    };\n}\n\nfunction tokenType(expectedTokenType) {\n    return function(token) {\n        if (token === null || token.type !== expectedTokenType) {\n            return 0;\n        }\n\n        return 1;\n    };\n}\n\nfunction func(name) {\n    name = name + '(';\n\n    return function(token, getNextToken) {\n        if (token !== null && eqStr(token.value, name)) {\n            return consumeFunction(token, getNextToken);\n        }\n\n        return 0;\n    };\n}\n\n// =========================\n// Complex types\n//\n\n// https://drafts.csswg.org/css-values-4/#custom-idents\n// 4.2. Author-defined Identifiers: the <custom-ident> type\n// Some properties accept arbitrary author-defined identifiers as a component value.\n// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier\n// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.\n//\n// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident\nfunction customIdent(token) {\n    if (token === null || token.type !== TYPE.Ident) {\n        return 0;\n    }\n\n    var name = token.value.toLowerCase();\n\n    // The CSS-wide keywords are not valid <custom-ident>s\n    if (eqStrAny(name, cssWideKeywords)) {\n        return 0;\n    }\n\n    // The default keyword is reserved and is also not a valid <custom-ident>\n    if (eqStr(name, 'default')) {\n        return 0;\n    }\n\n    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)\n    // Specifications using <custom-ident> must specify clearly what other keywords\n    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords\n    // in that property’s value definition are excluded. Excluded keywords are excluded\n    // in all ASCII case permutations.\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-variables/#typedef-custom-property-name\n// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.\n// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier\n// that starts with two dashes, except -- itself, which is reserved for future use by CSS.\n// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.\nfunction customPropertyName(token) {\n    // ... defined as any valid identifier\n    if (token === null || token.type !== TYPE.Ident) {\n        return 0;\n    }\n\n    // ... that starts with two dashes (U+002D HYPHEN-MINUS)\n    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-color-4/#hex-notation\n// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.\n// In other words, a hex color is written as a hash character, \"#\", followed by some number of digits 0-9 or\n// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).\nfunction hexColor(token) {\n    if (token === null || token.type !== TYPE.Hash) {\n        return 0;\n    }\n\n    var length = token.value.length;\n\n    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)\n    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {\n        return 0;\n    }\n\n    for (var i = 1; i < length; i++) {\n        if (!isHexDigit(token.value.charCodeAt(i))) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\nfunction idSelector(token) {\n    if (token === null || token.type !== TYPE.Hash) {\n        return 0;\n    }\n\n    if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// https://drafts.csswg.org/css-syntax/#any-value\n// It represents the entirety of what a valid declaration can have as its value.\nfunction declarationValue(token, getNextToken) {\n    if (!token) {\n        return 0;\n    }\n\n    var length = 0;\n    var level = 0;\n    var startIdx = token.index;\n\n    // The <declaration-value> production matches any sequence of one or more tokens,\n    // so long as the sequence ...\n    scan:\n    do {\n        switch (token.type) {\n            // ... does not contain <bad-string-token>, <bad-url-token>,\n            case TYPE.BadString:\n            case TYPE.BadUrl:\n                break scan;\n\n            // ... unmatched <)-token>, <]-token>, or <}-token>,\n            case TYPE.RightCurlyBracket:\n            case TYPE.RightParenthesis:\n            case TYPE.RightSquareBracket:\n                if (token.balance > token.index || token.balance < startIdx) {\n                    break scan;\n                }\n\n                level--;\n                break;\n\n            // ... or top-level <semicolon-token> tokens\n            case TYPE.Semicolon:\n                if (level === 0) {\n                    break scan;\n                }\n\n                break;\n\n            // ... or <delim-token> tokens with a value of \"!\"\n            case TYPE.Delim:\n                if (token.value === '!' && level === 0) {\n                    break scan;\n                }\n\n                break;\n\n            case TYPE.Function:\n            case TYPE.LeftParenthesis:\n            case TYPE.LeftSquareBracket:\n            case TYPE.LeftCurlyBracket:\n                level++;\n                break;\n        }\n\n        length++;\n\n        // until balance closing\n        if (token.balance <= startIdx) {\n            break;\n        }\n    } while (token = getNextToken(length));\n\n    return length;\n}\n\n// https://drafts.csswg.org/css-syntax/#any-value\n// The <any-value> production is identical to <declaration-value>, but also\n// allows top-level <semicolon-token> tokens and <delim-token> tokens\n// with a value of \"!\". It represents the entirety of what valid CSS can be in any context.\nfunction anyValue(token, getNextToken) {\n    if (!token) {\n        return 0;\n    }\n\n    var startIdx = token.index;\n    var length = 0;\n\n    // The <any-value> production matches any sequence of one or more tokens,\n    // so long as the sequence ...\n    scan:\n    do {\n        switch (token.type) {\n            // ... does not contain <bad-string-token>, <bad-url-token>,\n            case TYPE.BadString:\n            case TYPE.BadUrl:\n                break scan;\n\n            // ... unmatched <)-token>, <]-token>, or <}-token>,\n            case TYPE.RightCurlyBracket:\n            case TYPE.RightParenthesis:\n            case TYPE.RightSquareBracket:\n                if (token.balance > token.index || token.balance < startIdx) {\n                    break scan;\n                }\n\n                break;\n        }\n\n        length++;\n\n        // until balance closing\n        if (token.balance <= startIdx) {\n            break;\n        }\n    } while (token = getNextToken(length));\n\n    return length;\n}\n\n// =========================\n// Dimensions\n//\n\nfunction dimension(type) {\n    return function(token, getNextToken, opts) {\n        if (token === null || token.type !== TYPE.Dimension) {\n            return 0;\n        }\n\n        var numberEnd = consumeNumber(token.value, 0);\n\n        // check unit\n        if (type !== null) {\n            // check for IE postfix hack, i.e. 123px\\0 or 123px\\9\n            var reverseSolidusOffset = token.value.indexOf('\\\\', numberEnd);\n            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)\n                ? token.value.substr(numberEnd)\n                : token.value.substring(numberEnd, reverseSolidusOffset);\n\n            if (type.hasOwnProperty(unit.toLowerCase()) === false) {\n                return 0;\n            }\n        }\n\n        // check range if specified\n        if (outOfRange(opts, token.value, numberEnd)) {\n            return 0;\n        }\n\n        return 1;\n    };\n}\n\n// =========================\n// Percentage\n//\n\n// §5.5. Percentages: the <percentage> type\n// https://drafts.csswg.org/css-values-4/#percentages\nfunction percentage(token, getNextToken, opts) {\n    // ... corresponds to the <percentage-token> production\n    if (token === null || token.type !== TYPE.Percentage) {\n        return 0;\n    }\n\n    // check range if specified\n    if (outOfRange(opts, token.value, token.value.length - 1)) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// =========================\n// Numeric\n//\n\n// https://drafts.csswg.org/css-values-4/#numbers\n// The value <zero> represents a literal number with the value 0. Expressions that merely\n// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;\n// only literal <number-token>s do.\nfunction zero(next) {\n    if (typeof next !== 'function') {\n        next = function() {\n            return 0;\n        };\n    }\n\n    return function(token, getNextToken, opts) {\n        if (token !== null && token.type === TYPE.Number) {\n            if (Number(token.value) === 0) {\n                return 1;\n            }\n        }\n\n        return next(token, getNextToken, opts);\n    };\n}\n\n// § 5.3. Real Numbers: the <number> type\n// https://drafts.csswg.org/css-values-4/#numbers\n// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.\n// ... It corresponds to the <number-token> production\nfunction number(token, getNextToken, opts) {\n    if (token === null) {\n        return 0;\n    }\n\n    var numberEnd = consumeNumber(token.value, 0);\n    var isNumber = numberEnd === token.value.length;\n    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {\n        return 0;\n    }\n\n    // check range if specified\n    if (outOfRange(opts, token.value, numberEnd)) {\n        return 0;\n    }\n\n    return 1;\n}\n\n// §5.2. Integers: the <integer> type\n// https://drafts.csswg.org/css-values-4/#integers\nfunction integer(token, getNextToken, opts) {\n    // ... corresponds to a subset of the <number-token> production\n    if (token === null || token.type !== TYPE.Number) {\n        return 0;\n    }\n\n    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.\n    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)\n            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)\n\n    // When written literally, an integer is one or more decimal digits 0 through 9 ...\n    for (; i < token.value.length; i++) {\n        if (!isDigit(token.value.charCodeAt(i))) {\n            return 0;\n        }\n    }\n\n    // check range if specified\n    if (outOfRange(opts, token.value, i)) {\n        return 0;\n    }\n\n    return 1;\n}\n\nmodule.exports = {\n    // token types\n    'ident-token': tokenType(TYPE.Ident),\n    'function-token': tokenType(TYPE.Function),\n    'at-keyword-token': tokenType(TYPE.AtKeyword),\n    'hash-token': tokenType(TYPE.Hash),\n    'string-token': tokenType(TYPE.String),\n    'bad-string-token': tokenType(TYPE.BadString),\n    'url-token': tokenType(TYPE.Url),\n    'bad-url-token': tokenType(TYPE.BadUrl),\n    'delim-token': tokenType(TYPE.Delim),\n    'number-token': tokenType(TYPE.Number),\n    'percentage-token': tokenType(TYPE.Percentage),\n    'dimension-token': tokenType(TYPE.Dimension),\n    'whitespace-token': tokenType(TYPE.WhiteSpace),\n    'CDO-token': tokenType(TYPE.CDO),\n    'CDC-token': tokenType(TYPE.CDC),\n    'colon-token': tokenType(TYPE.Colon),\n    'semicolon-token': tokenType(TYPE.Semicolon),\n    'comma-token': tokenType(TYPE.Comma),\n    '[-token': tokenType(TYPE.LeftSquareBracket),\n    ']-token': tokenType(TYPE.RightSquareBracket),\n    '(-token': tokenType(TYPE.LeftParenthesis),\n    ')-token': tokenType(TYPE.RightParenthesis),\n    '{-token': tokenType(TYPE.LeftCurlyBracket),\n    '}-token': tokenType(TYPE.RightCurlyBracket),\n\n    // token type aliases\n    'string': tokenType(TYPE.String),\n    'ident': tokenType(TYPE.Ident),\n\n    // complex types\n    'custom-ident': customIdent,\n    'custom-property-name': customPropertyName,\n    'hex-color': hexColor,\n    'id-selector': idSelector, // element( <id-selector> )\n    'an-plus-b': anPlusB,\n    'urange': urange,\n    'declaration-value': declarationValue,\n    'any-value': anyValue,\n\n    // dimensions\n    'dimension': calc(dimension(null)),\n    'angle': calc(dimension(ANGLE)),\n    'decibel': calc(dimension(DECIBEL)),\n    'frequency': calc(dimension(FREQUENCY)),\n    'flex': calc(dimension(FLEX)),\n    'length': calc(zero(dimension(LENGTH))),\n    'resolution': calc(dimension(RESOLUTION)),\n    'semitones': calc(dimension(SEMITONES)),\n    'time': calc(dimension(TIME)),\n\n    // percentage\n    'percentage': calc(percentage),\n\n    // numeric\n    'zero': zero(),\n    'number': calc(number),\n    'integer': calc(integer),\n\n    // old IE stuff\n    '-ms-legacy-expression': func('expression')\n};\n","var TokenStream = require('../common/TokenStream');\nvar adoptBuffer = require('../common/adopt-buffer');\n\nvar constants = require('./const');\nvar TYPE = constants.TYPE;\n\nvar charCodeDefinitions = require('./char-code-definitions');\nvar isNewline = charCodeDefinitions.isNewline;\nvar isName = charCodeDefinitions.isName;\nvar isValidEscape = charCodeDefinitions.isValidEscape;\nvar isNumberStart = charCodeDefinitions.isNumberStart;\nvar isIdentifierStart = charCodeDefinitions.isIdentifierStart;\nvar charCodeCategory = charCodeDefinitions.charCodeCategory;\nvar isBOM = charCodeDefinitions.isBOM;\n\nvar utils = require('./utils');\nvar cmpStr = utils.cmpStr;\nvar getNewlineLength = utils.getNewlineLength;\nvar findWhiteSpaceEnd = utils.findWhiteSpaceEnd;\nvar consumeEscaped = utils.consumeEscaped;\nvar consumeName = utils.consumeName;\nvar consumeNumber = utils.consumeNumber;\nvar consumeBadUrlRemnants = utils.consumeBadUrlRemnants;\n\nvar OFFSET_MASK = 0x00FFFFFF;\nvar TYPE_SHIFT = 24;\n\nfunction tokenize(source, stream) {\n    function getCharCode(offset) {\n        return offset < sourceLength ? source.charCodeAt(offset) : 0;\n    }\n\n    // § 4.3.3. Consume a numeric token\n    function consumeNumericToken() {\n        // Consume a number and let number be the result.\n        offset = consumeNumber(source, offset);\n\n        // If the next 3 input code points would start an identifier, then:\n        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {\n            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.\n            // Consume a name. Set the <dimension-token>’s unit to the returned value.\n            // Return the <dimension-token>.\n            type = TYPE.Dimension;\n            offset = consumeName(source, offset);\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.\n        if (getCharCode(offset) === 0x0025) {\n            // Create a <percentage-token> with the same value as number, and return it.\n            type = TYPE.Percentage;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.\n        type = TYPE.Number;\n    }\n\n    // § 4.3.4. Consume an ident-like token\n    function consumeIdentLikeToken() {\n        const nameStartOffset = offset;\n\n        // Consume a name, and let string be the result.\n        offset = consumeName(source, offset);\n\n        // If string’s value is an ASCII case-insensitive match for \"url\",\n        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {\n            // While the next two input code points are whitespace, consume the next input code point.\n            offset = findWhiteSpaceEnd(source, offset + 1);\n\n            // If the next one or two input code points are U+0022 QUOTATION MARK (\"), U+0027 APOSTROPHE ('),\n            // or whitespace followed by U+0022 QUOTATION MARK (\") or U+0027 APOSTROPHE ('),\n            // then create a <function-token> with its value set to string and return it.\n            if (getCharCode(offset) === 0x0022 ||\n                getCharCode(offset) === 0x0027) {\n                type = TYPE.Function;\n                offset = nameStartOffset + 4;\n                return;\n            }\n\n            // Otherwise, consume a url token, and return it.\n            consumeUrlToken();\n            return;\n        }\n\n        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.\n        // Create a <function-token> with its value set to string and return it.\n        if (getCharCode(offset) === 0x0028) {\n            type = TYPE.Function;\n            offset++;\n            return;\n        }\n\n        // Otherwise, create an <ident-token> with its value set to string and return it.\n        type = TYPE.Ident;\n    }\n\n    // § 4.3.5. Consume a string token\n    function consumeStringToken(endingCodePoint) {\n        // This algorithm may be called with an ending code point, which denotes the code point\n        // that ends the string. If an ending code point is not specified,\n        // the current input code point is used.\n        if (!endingCodePoint) {\n            endingCodePoint = getCharCode(offset++);\n        }\n\n        // Initially create a <string-token> with its value set to the empty string.\n        type = TYPE.String;\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            var code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // ending code point\n                case endingCodePoint:\n                    // Return the <string-token>.\n                    offset++;\n                    return;\n\n                // EOF\n                case charCodeCategory.Eof:\n                    // This is a parse error. Return the <string-token>.\n                    return;\n\n                // newline\n                case charCodeCategory.WhiteSpace:\n                    if (isNewline(code)) {\n                        // This is a parse error. Reconsume the current input code point,\n                        // create a <bad-string-token>, and return it.\n                        offset += getNewlineLength(source, offset, code);\n                        type = TYPE.BadString;\n                        return;\n                    }\n                    break;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the next input code point is EOF, do nothing.\n                    if (offset === source.length - 1) {\n                        break;\n                    }\n\n                    var nextCode = getCharCode(offset + 1);\n\n                    // Otherwise, if the next input code point is a newline, consume it.\n                    if (isNewline(nextCode)) {\n                        offset += getNewlineLength(source, offset + 1, nextCode);\n                    } else if (isValidEscape(code, nextCode)) {\n                        // Otherwise, (the stream starts with a valid escape) consume\n                        // an escaped code point and append the returned code point to\n                        // the <string-token>’s value.\n                        offset = consumeEscaped(source, offset) - 1;\n                    }\n                    break;\n\n                // anything else\n                // Append the current input code point to the <string-token>’s value.\n            }\n        }\n    }\n\n    // § 4.3.6. Consume a url token\n    // Note: This algorithm assumes that the initial \"url(\" has already been consumed.\n    // This algorithm also assumes that it’s being called to consume an \"unquoted\" value, like url(foo).\n    // A quoted value, like url(\"foo\"), is parsed as a <function-token>. Consume an ident-like token\n    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.\n    function consumeUrlToken() {\n        // Initially create a <url-token> with its value set to the empty string.\n        type = TYPE.Url;\n\n        // Consume as much whitespace as possible.\n        offset = findWhiteSpaceEnd(source, offset);\n\n        // Repeatedly consume the next input code point from the stream:\n        for (; offset < source.length; offset++) {\n            var code = source.charCodeAt(offset);\n\n            switch (charCodeCategory(code)) {\n                // U+0029 RIGHT PARENTHESIS ())\n                case 0x0029:\n                    // Return the <url-token>.\n                    offset++;\n                    return;\n\n                // EOF\n                case charCodeCategory.Eof:\n                    // This is a parse error. Return the <url-token>.\n                    return;\n\n                // whitespace\n                case charCodeCategory.WhiteSpace:\n                    // Consume as much whitespace as possible.\n                    offset = findWhiteSpaceEnd(source, offset);\n\n                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,\n                    // consume it and return the <url-token>\n                    // (if EOF was encountered, this is a parse error);\n                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {\n                        if (offset < source.length) {\n                            offset++;\n                        }\n                        return;\n                    }\n\n                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,\n                    // and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+0022 QUOTATION MARK (\")\n                // U+0027 APOSTROPHE (')\n                // U+0028 LEFT PARENTHESIS (()\n                // non-printable code point\n                case 0x0022:\n                case 0x0027:\n                case 0x0028:\n                case charCodeCategory.NonPrintable:\n                    // This is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // U+005C REVERSE SOLIDUS (\\)\n                case 0x005C:\n                    // If the stream starts with a valid escape, consume an escaped code point and\n                    // append the returned code point to the <url-token>’s value.\n                    if (isValidEscape(code, getCharCode(offset + 1))) {\n                        offset = consumeEscaped(source, offset) - 1;\n                        break;\n                    }\n\n                    // Otherwise, this is a parse error. Consume the remnants of a bad url,\n                    // create a <bad-url-token>, and return it.\n                    offset = consumeBadUrlRemnants(source, offset);\n                    type = TYPE.BadUrl;\n                    return;\n\n                // anything else\n                // Append the current input code point to the <url-token>’s value.\n            }\n        }\n    }\n\n    if (!stream) {\n        stream = new TokenStream();\n    }\n\n    // ensure source is a string\n    source = String(source || '');\n\n    var sourceLength = source.length;\n    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token\n    var balance = adoptBuffer(stream.balance, sourceLength + 1);\n    var tokenCount = 0;\n    var start = isBOM(getCharCode(0));\n    var offset = start;\n    var balanceCloseType = 0;\n    var balanceStart = 0;\n    var balancePrev = 0;\n\n    // https://drafts.csswg.org/css-syntax-3/#consume-token\n    // § 4.3.1. Consume a token\n    while (offset < sourceLength) {\n        var code = source.charCodeAt(offset);\n        var type = 0;\n\n        balance[tokenCount] = sourceLength;\n\n        switch (charCodeCategory(code)) {\n            // whitespace\n            case charCodeCategory.WhiteSpace:\n                // Consume as much whitespace as possible. Return a <whitespace-token>.\n                type = TYPE.WhiteSpace;\n                offset = findWhiteSpaceEnd(source, offset + 1);\n                break;\n\n            // U+0022 QUOTATION MARK (\")\n            case 0x0022:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0023 NUMBER SIGN (#)\n            case 0x0023:\n                // If the next input code point is a name code point or the next two input code points are a valid escape, then:\n                if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // Create a <hash-token>.\n                    type = TYPE.Hash;\n\n                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to \"id\".\n                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    //     // TODO: set id flag\n                    // }\n\n                    // Consume a name, and set the <hash-token>’s value to the returned string.\n                    offset = consumeName(source, offset + 1);\n\n                    // Return the <hash-token>.\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0027 APOSTROPHE (')\n            case 0x0027:\n                // Consume a string token and return it.\n                consumeStringToken();\n                break;\n\n            // U+0028 LEFT PARENTHESIS (()\n            case 0x0028:\n                // Return a <(-token>.\n                type = TYPE.LeftParenthesis;\n                offset++;\n                break;\n\n            // U+0029 RIGHT PARENTHESIS ())\n            case 0x0029:\n                // Return a <)-token>.\n                type = TYPE.RightParenthesis;\n                offset++;\n                break;\n\n            // U+002B PLUS SIGN (+)\n            case 0x002B:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+002C COMMA (,)\n            case 0x002C:\n                // Return a <comma-token>.\n                type = TYPE.Comma;\n                offset++;\n                break;\n\n            // U+002D HYPHEN-MINUS (-)\n            case 0x002D:\n                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.\n                    if (getCharCode(offset + 1) === 0x002D &&\n                        getCharCode(offset + 2) === 0x003E) {\n                        type = TYPE.CDC;\n                        offset = offset + 3;\n                    } else {\n                        // Otherwise, if the input stream starts with an identifier, ...\n                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                            // ... reconsume the current input code point, consume an ident-like token, and return it.\n                            consumeIdentLikeToken();\n                        } else {\n                            // Otherwise, return a <delim-token> with its value set to the current input code point.\n                            type = TYPE.Delim;\n                            offset++;\n                        }\n                    }\n                }\n                break;\n\n            // U+002E FULL STOP (.)\n            case 0x002E:\n                // If the input stream starts with a number, ...\n                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {\n                    // ... reconsume the current input code point, consume a numeric token, and return it.\n                    consumeNumericToken();\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+002F SOLIDUS (/)\n            case 0x002F:\n                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),\n                if (getCharCode(offset + 1) === 0x002A) {\n                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)\n                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.\n                    type = TYPE.Comment;\n                    offset = source.indexOf('*/', offset + 2) + 2;\n                    if (offset === 1) {\n                        offset = source.length;\n                    }\n                } else {\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+003A COLON (:)\n            case 0x003A:\n                // Return a <colon-token>.\n                type = TYPE.Colon;\n                offset++;\n                break;\n\n            // U+003B SEMICOLON (;)\n            case 0x003B:\n                // Return a <semicolon-token>.\n                type = TYPE.Semicolon;\n                offset++;\n                break;\n\n            // U+003C LESS-THAN SIGN (<)\n            case 0x003C:\n                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...\n                if (getCharCode(offset + 1) === 0x0021 &&\n                    getCharCode(offset + 2) === 0x002D &&\n                    getCharCode(offset + 3) === 0x002D) {\n                    // ... consume them and return a <CDO-token>.\n                    type = TYPE.CDO;\n                    offset = offset + 4;\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+0040 COMMERCIAL AT (@)\n            case 0x0040:\n                // If the next 3 input code points would start an identifier, ...\n                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {\n                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.\n                    type = TYPE.AtKeyword;\n                    offset = consumeName(source, offset + 1);\n                } else {\n                    // Otherwise, return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n\n                break;\n\n            // U+005B LEFT SQUARE BRACKET ([)\n            case 0x005B:\n                // Return a <[-token>.\n                type = TYPE.LeftSquareBracket;\n                offset++;\n                break;\n\n            // U+005C REVERSE SOLIDUS (\\)\n            case 0x005C:\n                // If the input stream starts with a valid escape, ...\n                if (isValidEscape(code, getCharCode(offset + 1))) {\n                    // ... reconsume the current input code point, consume an ident-like token, and return it.\n                    consumeIdentLikeToken();\n                } else {\n                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.\n                    type = TYPE.Delim;\n                    offset++;\n                }\n                break;\n\n            // U+005D RIGHT SQUARE BRACKET (])\n            case 0x005D:\n                // Return a <]-token>.\n                type = TYPE.RightSquareBracket;\n                offset++;\n                break;\n\n            // U+007B LEFT CURLY BRACKET ({)\n            case 0x007B:\n                // Return a <{-token>.\n                type = TYPE.LeftCurlyBracket;\n                offset++;\n                break;\n\n            // U+007D RIGHT CURLY BRACKET (})\n            case 0x007D:\n                // Return a <}-token>.\n                type = TYPE.RightCurlyBracket;\n                offset++;\n                break;\n\n            // digit\n            case charCodeCategory.Digit:\n                // Reconsume the current input code point, consume a numeric token, and return it.\n                consumeNumericToken();\n                break;\n\n            // name-start code point\n            case charCodeCategory.NameStart:\n                // Reconsume the current input code point, consume an ident-like token, and return it.\n                consumeIdentLikeToken();\n                break;\n\n            // EOF\n            case charCodeCategory.Eof:\n                // Return an <EOF-token>.\n                break;\n\n            // anything else\n            default:\n                // Return a <delim-token> with its value set to the current input code point.\n                type = TYPE.Delim;\n                offset++;\n        }\n\n        switch (type) {\n            case balanceCloseType:\n                balancePrev = balanceStart & OFFSET_MASK;\n                balanceStart = balance[balancePrev];\n                balanceCloseType = balanceStart >> TYPE_SHIFT;\n                balance[tokenCount] = balancePrev;\n                balance[balancePrev++] = tokenCount;\n                for (; balancePrev < tokenCount; balancePrev++) {\n                    if (balance[balancePrev] === sourceLength) {\n                        balance[balancePrev] = tokenCount;\n                    }\n                }\n                break;\n\n            case TYPE.LeftParenthesis:\n            case TYPE.Function:\n                balance[tokenCount] = balanceStart;\n                balanceCloseType = TYPE.RightParenthesis;\n                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;\n                break;\n\n            case TYPE.LeftSquareBracket:\n                balance[tokenCount] = balanceStart;\n                balanceCloseType = TYPE.RightSquareBracket;\n                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;\n                break;\n\n            case TYPE.LeftCurlyBracket:\n                balance[tokenCount] = balanceStart;\n                balanceCloseType = TYPE.RightCurlyBracket;\n                balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;\n                break;\n        }\n\n        offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | offset;\n    }\n\n    // finalize buffers\n    offsetAndType[tokenCount] = (TYPE.EOF << TYPE_SHIFT) | offset; // <EOF-token>\n    balance[tokenCount] = sourceLength;\n    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token\n    while (balanceStart !== 0) {\n        balancePrev = balanceStart & OFFSET_MASK;\n        balanceStart = balance[balancePrev];\n        balance[balancePrev] = sourceLength;\n    }\n\n    // update stream\n    stream.source = source;\n    stream.firstCharOffset = start;\n    stream.offsetAndType = offsetAndType;\n    stream.tokenCount = tokenCount;\n    stream.balance = balance;\n    stream.reset();\n    stream.next();\n\n    return stream;\n}\n\n// extend tokenizer with constants\nObject.keys(constants).forEach(function(key) {\n    tokenize[key] = constants[key];\n});\n\n// extend tokenizer with static methods from utils\nObject.keys(charCodeDefinitions).forEach(function(key) {\n    tokenize[key] = charCodeDefinitions[key];\n});\nObject.keys(utils).forEach(function(key) {\n    tokenize[key] = utils[key];\n});\n\nmodule.exports = tokenize;\n","var MIN_SIZE = 16 * 1024;\nvar SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported\n\nmodule.exports = function adoptBuffer(buffer, size) {\n    if (buffer === null || buffer.length < size) {\n        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));\n    }\n\n    return buffer;\n};\n","var isDigit = require('../tokenizer').isDigit;\nvar cmpChar = require('../tokenizer').cmpChar;\nvar TYPE = require('../tokenizer').TYPE;\n\nvar DELIM = TYPE.Delim;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar NUMBER = TYPE.Number;\nvar DIMENSION = TYPE.Dimension;\nvar PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nvar HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nvar N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\nvar DISALLOW_SIGN = true;\nvar ALLOW_SIGN = false;\n\nfunction isDelim(token, code) {\n    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;\n}\n\nfunction skipSC(token, offset, getNextToken) {\n    while (token !== null && (token.type === WHITESPACE || token.type === COMMENT)) {\n        token = getNextToken(++offset);\n    }\n\n    return offset;\n}\n\nfunction checkInteger(token, valueOffset, disallowSign, offset) {\n    if (!token) {\n        return 0;\n    }\n\n    var code = token.value.charCodeAt(valueOffset);\n\n    if (code === PLUSSIGN || code === HYPHENMINUS) {\n        if (disallowSign) {\n            // Number sign is not allowed\n            return 0;\n        }\n        valueOffset++;\n    }\n\n    for (; valueOffset < token.value.length; valueOffset++) {\n        if (!isDigit(token.value.charCodeAt(valueOffset))) {\n            // Integer is expected\n            return 0;\n        }\n    }\n\n    return offset + 1;\n}\n\n// ... <signed-integer>\n// ... ['+' | '-'] <signless-integer>\nfunction consumeB(token, offset_, getNextToken) {\n    var sign = false;\n    var offset = skipSC(token, offset_, getNextToken);\n\n    token = getNextToken(offset);\n\n    if (token === null) {\n        return offset_;\n    }\n\n    if (token.type !== NUMBER) {\n        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {\n            sign = true;\n            offset = skipSC(getNextToken(++offset), offset, getNextToken);\n            token = getNextToken(offset);\n\n            if (token === null && token.type !== NUMBER) {\n                return 0;\n            }\n        } else {\n            return offset_;\n        }\n    }\n\n    if (!sign) {\n        var code = token.value.charCodeAt(0);\n        if (code !== PLUSSIGN && code !== HYPHENMINUS) {\n            // Number sign is expected\n            return 0;\n        }\n    }\n\n    return checkInteger(token, sign ? 0 : 1, sign, offset);\n}\n\n// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\nmodule.exports = function anPlusB(token, getNextToken) {\n    /* eslint-disable brace-style*/\n    var offset = 0;\n\n    if (!token) {\n        return 0;\n    }\n\n    // <integer>\n    if (token.type === NUMBER) {\n        return checkInteger(token, 0, ALLOW_SIGN, offset); // b\n    }\n\n    // -n\n    // -n <signed-integer>\n    // -n ['+' | '-'] <signless-integer>\n    // -n- <signless-integer>\n    // <dashndashdigit-ident>\n    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS) {\n        // expect 1st char is N\n        if (!cmpChar(token.value, 1, N)) {\n            return 0;\n        }\n\n        switch (token.value.length) {\n            // -n\n            // -n <signed-integer>\n            // -n ['+' | '-'] <signless-integer>\n            case 2:\n                return consumeB(getNextToken(++offset), offset, getNextToken);\n\n            // -n- <signless-integer>\n            case 3:\n                if (token.value.charCodeAt(2) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                return checkInteger(token, 0, DISALLOW_SIGN, offset);\n\n            // <dashndashdigit-ident>\n            default:\n                if (token.value.charCodeAt(2) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                return checkInteger(token, 3, DISALLOW_SIGN, offset);\n        }\n    }\n\n    // '+'? n\n    // '+'? n <signed-integer>\n    // '+'? n ['+' | '-'] <signless-integer>\n    // '+'? n- <signless-integer>\n    // '+'? <ndashdigit-ident>\n    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {\n        // just ignore a plus\n        if (token.type !== IDENT) {\n            token = getNextToken(++offset);\n        }\n\n        if (token === null || !cmpChar(token.value, 0, N)) {\n            return 0;\n        }\n\n        switch (token.value.length) {\n            // '+'? n\n            // '+'? n <signed-integer>\n            // '+'? n ['+' | '-'] <signless-integer>\n            case 1:\n                return consumeB(getNextToken(++offset), offset, getNextToken);\n\n            // '+'? n- <signless-integer>\n            case 2:\n                if (token.value.charCodeAt(1) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                return checkInteger(token, 0, DISALLOW_SIGN, offset);\n\n            // '+'? <ndashdigit-ident>\n            default:\n                if (token.value.charCodeAt(1) !== HYPHENMINUS) {\n                    return 0;\n                }\n\n                return checkInteger(token, 2, DISALLOW_SIGN, offset);\n        }\n    }\n\n    // <ndashdigit-dimension>\n    // <ndash-dimension> <signless-integer>\n    // <n-dimension>\n    // <n-dimension> <signed-integer>\n    // <n-dimension> ['+' | '-'] <signless-integer>\n    else if (token.type === DIMENSION) {\n        var code = token.value.charCodeAt(0);\n        var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;\n\n        for (var i = sign; i < token.value.length; i++) {\n            if (!isDigit(token.value.charCodeAt(i))) {\n                break;\n            }\n        }\n\n        if (i === sign) {\n            // Integer is expected\n            return 0;\n        }\n\n        if (!cmpChar(token.value, i, N)) {\n            return 0;\n        }\n\n        // <n-dimension>\n        // <n-dimension> <signed-integer>\n        // <n-dimension> ['+' | '-'] <signless-integer>\n        if (i + 1 === token.value.length) {\n            return consumeB(getNextToken(++offset), offset, getNextToken);\n        } else {\n            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {\n                return 0;\n            }\n\n            // <ndash-dimension> <signless-integer>\n            if (i + 2 === token.value.length) {\n                offset = skipSC(getNextToken(++offset), offset, getNextToken);\n                token = getNextToken(offset);\n\n                return checkInteger(token, 0, DISALLOW_SIGN, offset);\n            }\n            // <ndashdigit-dimension>\n            else {\n                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);\n            }\n        }\n    }\n\n    return 0;\n};\n","var isHexDigit = require('../tokenizer').isHexDigit;\nvar cmpChar = require('../tokenizer').cmpChar;\nvar TYPE = require('../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\nvar DELIM = TYPE.Delim;\nvar NUMBER = TYPE.Number;\nvar DIMENSION = TYPE.Dimension;\nvar PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)\nvar HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)\nvar QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\nvar U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)\n\nfunction isDelim(token, code) {\n    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;\n}\n\nfunction startsWith(token, code) {\n    return token.value.charCodeAt(0) === code;\n}\n\nfunction hexSequence(token, offset, allowDash) {\n    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {\n        var code = token.value.charCodeAt(pos);\n\n        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {\n            if (hexSequence(token, offset + hexlen + 1, false) > 0) {\n                return 6; // dissallow following question marks\n            }\n\n            return 0; // dash at the ending of a hex sequence is not allowed\n        }\n\n        if (!isHexDigit(code)) {\n            return 0; // not a hex digit\n        }\n\n        if (++hexlen > 6) {\n            return 0; // too many hex digits\n        };\n    }\n\n    return hexlen;\n}\n\nfunction withQuestionMarkSequence(consumed, length, getNextToken) {\n    if (!consumed) {\n        return 0; // nothing consumed\n    }\n\n    while (isDelim(getNextToken(length), QUESTIONMARK)) {\n        if (++consumed > 6) {\n            return 0; // too many question marks\n        }\n\n        length++;\n    }\n\n    return length;\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nmodule.exports = function urange(token, getNextToken) {\n    var length = 0;\n\n    // should start with `u` or `U`\n    if (token === null || token.type !== IDENT || !cmpChar(token.value, 0, U)) {\n        return 0;\n    }\n\n    token = getNextToken(++length);\n    if (token === null) {\n        return 0;\n    }\n\n    // u '+' <ident-token> '?'*\n    // u '+' '?'+\n    if (isDelim(token, PLUSSIGN)) {\n        token = getNextToken(++length);\n        if (token === null) {\n            return 0;\n        }\n\n        if (token.type === IDENT) {\n            // u '+' <ident-token> '?'*\n            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);\n        }\n\n        if (isDelim(token, QUESTIONMARK)) {\n            // u '+' '?'+\n            return withQuestionMarkSequence(1, ++length, getNextToken);\n        }\n\n        // Hex digit or question mark is expected\n        return 0;\n    }\n\n    // u <number-token> '?'*\n    // u <number-token> <dimension-token>\n    // u <number-token> <number-token>\n    if (token.type === NUMBER) {\n        if (!startsWith(token, PLUSSIGN)) {\n            return 0;\n        }\n\n        var consumedHexLength = hexSequence(token, 1, true);\n        if (consumedHexLength === 0) {\n            return 0;\n        }\n\n        token = getNextToken(++length);\n        if (token === null) {\n            // u <number-token> <eof>\n            return length;\n        }\n\n        if (token.type === DIMENSION || token.type === NUMBER) {\n            // u <number-token> <dimension-token>\n            // u <number-token> <number-token>\n            if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {\n                return 0;\n            }\n\n            return length + 1;\n        }\n\n        // u <number-token> '?'*\n        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);\n    }\n\n    // u <dimension-token> '?'*\n    if (token.type === DIMENSION) {\n        if (!startsWith(token, PLUSSIGN)) {\n            return 0;\n        }\n\n        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);\n    }\n\n    return 0;\n};\n","var Tokenizer = require('./tokenizer');\nvar TAB = 9;\nvar N = 10;\nvar F = 12;\nvar R = 13;\nvar SPACE = 32;\nvar EXCLAMATIONMARK = 33;    // !\nvar NUMBERSIGN = 35;         // #\nvar AMPERSAND = 38;          // &\nvar APOSTROPHE = 39;         // '\nvar LEFTPARENTHESIS = 40;    // (\nvar RIGHTPARENTHESIS = 41;   // )\nvar ASTERISK = 42;           // *\nvar PLUSSIGN = 43;           // +\nvar COMMA = 44;              // ,\nvar HYPERMINUS = 45;         // -\nvar LESSTHANSIGN = 60;       // <\nvar GREATERTHANSIGN = 62;    // >\nvar QUESTIONMARK = 63;       // ?\nvar COMMERCIALAT = 64;       // @\nvar LEFTSQUAREBRACKET = 91;  // [\nvar RIGHTSQUAREBRACKET = 93; // ]\nvar LEFTCURLYBRACKET = 123;  // {\nvar VERTICALLINE = 124;      // |\nvar RIGHTCURLYBRACKET = 125; // }\nvar INFINITY = 8734;         // ∞\nvar NAME_CHAR = createCharMap(function(ch) {\n    return /[a-zA-Z0-9\\-]/.test(ch);\n});\nvar COMBINATOR_PRECEDENCE = {\n    ' ': 1,\n    '&&': 2,\n    '||': 3,\n    '|': 4\n};\n\nfunction createCharMap(fn) {\n    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);\n    for (var i = 0; i < 128; i++) {\n        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;\n    }\n    return array;\n}\n\nfunction scanSpaces(tokenizer) {\n    return tokenizer.substringToPos(\n        tokenizer.findWsEnd(tokenizer.pos)\n    );\n}\n\nfunction scanWord(tokenizer) {\n    var end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        var code = tokenizer.str.charCodeAt(end);\n        if (code >= 128 || NAME_CHAR[code] === 0) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a keyword');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanNumber(tokenizer) {\n    var end = tokenizer.pos;\n\n    for (; end < tokenizer.str.length; end++) {\n        var code = tokenizer.str.charCodeAt(end);\n        if (code < 48 || code > 57) {\n            break;\n        }\n    }\n\n    if (tokenizer.pos === end) {\n        tokenizer.error('Expect a number');\n    }\n\n    return tokenizer.substringToPos(end);\n}\n\nfunction scanString(tokenizer) {\n    var end = tokenizer.str.indexOf('\\'', tokenizer.pos + 1);\n\n    if (end === -1) {\n        tokenizer.pos = tokenizer.str.length;\n        tokenizer.error('Expect an apostrophe');\n    }\n\n    return tokenizer.substringToPos(end + 1);\n}\n\nfunction readMultiplierRange(tokenizer) {\n    var min = null;\n    var max = null;\n\n    tokenizer.eat(LEFTCURLYBRACKET);\n\n    min = scanNumber(tokenizer);\n\n    if (tokenizer.charCode() === COMMA) {\n        tokenizer.pos++;\n        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {\n            max = scanNumber(tokenizer);\n        }\n    } else {\n        max = min;\n    }\n\n    tokenizer.eat(RIGHTCURLYBRACKET);\n\n    return {\n        min: Number(min),\n        max: max ? Number(max) : 0\n    };\n}\n\nfunction readMultiplier(tokenizer) {\n    var range = null;\n    var comma = false;\n\n    switch (tokenizer.charCode()) {\n        case ASTERISK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 0\n            };\n\n            break;\n\n        case PLUSSIGN:\n            tokenizer.pos++;\n\n            range = {\n                min: 1,\n                max: 0\n            };\n\n            break;\n\n        case QUESTIONMARK:\n            tokenizer.pos++;\n\n            range = {\n                min: 0,\n                max: 1\n            };\n\n            break;\n\n        case NUMBERSIGN:\n            tokenizer.pos++;\n\n            comma = true;\n\n            if (tokenizer.charCode() === LEFTCURLYBRACKET) {\n                range = readMultiplierRange(tokenizer);\n            } else {\n                range = {\n                    min: 1,\n                    max: 0\n                };\n            }\n\n            break;\n\n        case LEFTCURLYBRACKET:\n            range = readMultiplierRange(tokenizer);\n            break;\n\n        default:\n            return null;\n    }\n\n    return {\n        type: 'Multiplier',\n        comma: comma,\n        min: range.min,\n        max: range.max,\n        term: null\n    };\n}\n\nfunction maybeMultiplied(tokenizer, node) {\n    var multiplier = readMultiplier(tokenizer);\n\n    if (multiplier !== null) {\n        multiplier.term = node;\n        return multiplier;\n    }\n\n    return node;\n}\n\nfunction maybeToken(tokenizer) {\n    var ch = tokenizer.peek();\n\n    if (ch === '') {\n        return null;\n    }\n\n    return {\n        type: 'Token',\n        value: ch\n    };\n}\n\nfunction readProperty(tokenizer) {\n    var name;\n\n    tokenizer.eat(LESSTHANSIGN);\n    tokenizer.eat(APOSTROPHE);\n\n    name = scanWord(tokenizer);\n\n    tokenizer.eat(APOSTROPHE);\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Property',\n        name: name\n    });\n}\n\n// https://drafts.csswg.org/css-values-3/#numeric-ranges\n// 4.1. Range Restrictions and Range Definition Notation\n//\n// Range restrictions can be annotated in the numeric type notation using CSS bracketed\n// range notation—[min,max]—within the angle brackets, after the identifying keyword,\n// indicating a closed range between (and including) min and max.\n// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.\nfunction readTypeRange(tokenizer) {\n    // use null for Infinity to make AST format JSON serializable/deserializable\n    var min = null; // -Infinity\n    var max = null; // Infinity\n    var sign = 1;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n\n    if (tokenizer.charCode() === HYPERMINUS) {\n        tokenizer.peek();\n        sign = -1;\n    }\n\n    if (sign == -1 && tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        min = sign * Number(scanNumber(tokenizer));\n    }\n\n    scanSpaces(tokenizer);\n    tokenizer.eat(COMMA);\n    scanSpaces(tokenizer);\n\n    if (tokenizer.charCode() === INFINITY) {\n        tokenizer.peek();\n    } else {\n        sign = 1;\n\n        if (tokenizer.charCode() === HYPERMINUS) {\n            tokenizer.peek();\n            sign = -1;\n        }\n\n        max = sign * Number(scanNumber(tokenizer));\n    }\n\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    // If no range is indicated, either by using the bracketed range notation\n    // or in the property description, then [−∞,∞] is assumed.\n    if (min === null && max === null) {\n        return null;\n    }\n\n    return {\n        type: 'Range',\n        min: min,\n        max: max\n    };\n}\n\nfunction readType(tokenizer) {\n    var name;\n    var opts = null;\n\n    tokenizer.eat(LESSTHANSIGN);\n    name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS &&\n        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {\n        tokenizer.pos += 2;\n        name += '()';\n    }\n\n    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {\n        scanSpaces(tokenizer);\n        opts = readTypeRange(tokenizer);\n    }\n\n    tokenizer.eat(GREATERTHANSIGN);\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Type',\n        name: name,\n        opts: opts\n    });\n}\n\nfunction readKeywordOrFunction(tokenizer) {\n    var name;\n\n    name = scanWord(tokenizer);\n\n    if (tokenizer.charCode() === LEFTPARENTHESIS) {\n        tokenizer.pos++;\n\n        return {\n            type: 'Function',\n            name: name\n        };\n    }\n\n    return maybeMultiplied(tokenizer, {\n        type: 'Keyword',\n        name: name\n    });\n}\n\nfunction regroupTerms(terms, combinators) {\n    function createGroup(terms, combinator) {\n        return {\n            type: 'Group',\n            terms: terms,\n            combinator: combinator,\n            disallowEmpty: false,\n            explicit: false\n        };\n    }\n\n    combinators = Object.keys(combinators).sort(function(a, b) {\n        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];\n    });\n\n    while (combinators.length > 0) {\n        var combinator = combinators.shift();\n        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {\n            var term = terms[i];\n            if (term.type === 'Combinator') {\n                if (term.value === combinator) {\n                    if (subgroupStart === -1) {\n                        subgroupStart = i - 1;\n                    }\n                    terms.splice(i, 1);\n                    i--;\n                } else {\n                    if (subgroupStart !== -1 && i - subgroupStart > 1) {\n                        terms.splice(\n                            subgroupStart,\n                            i - subgroupStart,\n                            createGroup(terms.slice(subgroupStart, i), combinator)\n                        );\n                        i = subgroupStart + 1;\n                    }\n                    subgroupStart = -1;\n                }\n            }\n        }\n\n        if (subgroupStart !== -1 && combinators.length) {\n            terms.splice(\n                subgroupStart,\n                i - subgroupStart,\n                createGroup(terms.slice(subgroupStart, i), combinator)\n            );\n        }\n    }\n\n    return combinator;\n}\n\nfunction readImplicitGroup(tokenizer) {\n    var terms = [];\n    var combinators = {};\n    var token;\n    var prevToken = null;\n    var prevTokenPos = tokenizer.pos;\n\n    while (token = peek(tokenizer)) {\n        if (token.type !== 'Spaces') {\n            if (token.type === 'Combinator') {\n                // check for combinator in group beginning and double combinator sequence\n                if (prevToken === null || prevToken.type === 'Combinator') {\n                    tokenizer.pos = prevTokenPos;\n                    tokenizer.error('Unexpected combinator');\n                }\n\n                combinators[token.value] = true;\n            } else if (prevToken !== null && prevToken.type !== 'Combinator') {\n                combinators[' '] = true;  // a b\n                terms.push({\n                    type: 'Combinator',\n                    value: ' '\n                });\n            }\n\n            terms.push(token);\n            prevToken = token;\n            prevTokenPos = tokenizer.pos;\n        }\n    }\n\n    // check for combinator in group ending\n    if (prevToken !== null && prevToken.type === 'Combinator') {\n        tokenizer.pos -= prevTokenPos;\n        tokenizer.error('Unexpected combinator');\n    }\n\n    return {\n        type: 'Group',\n        terms: terms,\n        combinator: regroupTerms(terms, combinators) || ' ',\n        disallowEmpty: false,\n        explicit: false\n    };\n}\n\nfunction readGroup(tokenizer) {\n    var result;\n\n    tokenizer.eat(LEFTSQUAREBRACKET);\n    result = readImplicitGroup(tokenizer);\n    tokenizer.eat(RIGHTSQUAREBRACKET);\n\n    result.explicit = true;\n\n    if (tokenizer.charCode() === EXCLAMATIONMARK) {\n        tokenizer.pos++;\n        result.disallowEmpty = true;\n    }\n\n    return result;\n}\n\nfunction peek(tokenizer) {\n    var code = tokenizer.charCode();\n\n    if (code < 128 && NAME_CHAR[code] === 1) {\n        return readKeywordOrFunction(tokenizer);\n    }\n\n    switch (code) {\n        case RIGHTSQUAREBRACKET:\n            // don't eat, stop scan a group\n            break;\n\n        case LEFTSQUAREBRACKET:\n            return maybeMultiplied(tokenizer, readGroup(tokenizer));\n\n        case LESSTHANSIGN:\n            return tokenizer.nextCharCode() === APOSTROPHE\n                ? readProperty(tokenizer)\n                : readType(tokenizer);\n\n        case VERTICALLINE:\n            return {\n                type: 'Combinator',\n                value: tokenizer.substringToPos(\n                    tokenizer.nextCharCode() === VERTICALLINE\n                        ? tokenizer.pos + 2\n                        : tokenizer.pos + 1\n                )\n            };\n\n        case AMPERSAND:\n            tokenizer.pos++;\n            tokenizer.eat(AMPERSAND);\n\n            return {\n                type: 'Combinator',\n                value: '&&'\n            };\n\n        case COMMA:\n            tokenizer.pos++;\n            return {\n                type: 'Comma'\n            };\n\n        case APOSTROPHE:\n            return maybeMultiplied(tokenizer, {\n                type: 'String',\n                value: scanString(tokenizer)\n            });\n\n        case SPACE:\n        case TAB:\n        case N:\n        case R:\n        case F:\n            return {\n                type: 'Spaces',\n                value: scanSpaces(tokenizer)\n            };\n\n        case COMMERCIALAT:\n            code = tokenizer.nextCharCode();\n\n            if (code < 128 && NAME_CHAR[code] === 1) {\n                tokenizer.pos++;\n                return {\n                    type: 'AtKeyword',\n                    name: scanWord(tokenizer)\n                };\n            }\n\n            return maybeToken(tokenizer);\n\n        case ASTERISK:\n        case PLUSSIGN:\n        case QUESTIONMARK:\n        case NUMBERSIGN:\n        case EXCLAMATIONMARK:\n            // prohibited tokens (used as a multiplier start)\n            break;\n\n        case LEFTCURLYBRACKET:\n            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting\n            // check next char isn't a number, because it's likely a disjoined multiplier\n            code = tokenizer.nextCharCode();\n\n            if (code < 48 || code > 57) {\n                return maybeToken(tokenizer);\n            }\n\n            break;\n\n        default:\n            return maybeToken(tokenizer);\n    }\n}\n\nfunction parse(source) {\n    var tokenizer = new Tokenizer(source);\n    var result = readImplicitGroup(tokenizer);\n\n    if (tokenizer.pos !== source.length) {\n        tokenizer.error('Unexpected input');\n    }\n\n    // reduce redundant groups with single group term\n    if (result.terms.length === 1 && result.terms[0].type === 'Group') {\n        result = result.terms[0];\n    }\n\n    return result;\n}\n\n// warm up parse to elimitate code branches that never execute\n// fix soft deoptimizations (insufficient type feedback)\nparse('[a&&<b>#|<\\'c\\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');\n\nmodule.exports = parse;\n","var SyntaxError = require('./SyntaxError');\n\nvar TAB = 9;\nvar N = 10;\nvar F = 12;\nvar R = 13;\nvar SPACE = 32;\n\nvar Tokenizer = function(str) {\n    this.str = str;\n    this.pos = 0;\n};\n\nTokenizer.prototype = {\n    charCodeAt: function(pos) {\n        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;\n    },\n    charCode: function() {\n        return this.charCodeAt(this.pos);\n    },\n    nextCharCode: function() {\n        return this.charCodeAt(this.pos + 1);\n    },\n    nextNonWsCode: function(pos) {\n        return this.charCodeAt(this.findWsEnd(pos));\n    },\n    findWsEnd: function(pos) {\n        for (; pos < this.str.length; pos++) {\n            var code = this.str.charCodeAt(pos);\n            if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {\n                break;\n            }\n        }\n\n        return pos;\n    },\n    substringToPos: function(end) {\n        return this.str.substring(this.pos, this.pos = end);\n    },\n    eat: function(code) {\n        if (this.charCode() !== code) {\n            this.error('Expect `' + String.fromCharCode(code) + '`');\n        }\n\n        this.pos++;\n    },\n    peek: function() {\n        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';\n    },\n    error: function(message) {\n        throw new SyntaxError(message, this.str, this.pos);\n    }\n};\n\nmodule.exports = Tokenizer;\n","var createCustomError = require('../utils/createCustomError');\n\nmodule.exports = function SyntaxError(message, input, offset) {\n    var error = createCustomError('SyntaxError', message);\n\n    error.input = input;\n    error.offset = offset;\n    error.rawMessage = message;\n    error.message = error.rawMessage + '\\n' +\n        '  ' + error.input + '\\n' +\n        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';\n\n    return error;\n};\n","var noop = function() {};\n\nfunction ensureFunction(value) {\n    return typeof value === 'function' ? value : noop;\n}\n\nmodule.exports = function(node, options, context) {\n    function walk(node) {\n        enter.call(context, node);\n\n        switch (node.type) {\n            case 'Group':\n                node.terms.forEach(walk);\n                break;\n\n            case 'Multiplier':\n                walk(node.term);\n                break;\n\n            case 'Type':\n            case 'Property':\n            case 'Keyword':\n            case 'AtKeyword':\n            case 'Function':\n            case 'String':\n            case 'Token':\n            case 'Comma':\n                break;\n\n            default:\n                throw new Error('Unknown type: ' + node.type);\n        }\n\n        leave.call(context, node);\n    }\n\n    var enter = noop;\n    var leave = noop;\n\n    if (typeof options === 'function') {\n        enter = options;\n    } else if (options) {\n        enter = ensureFunction(options.enter);\n        leave = ensureFunction(options.leave);\n    }\n\n    if (enter === noop && leave === noop) {\n        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n    }\n\n    walk(node, context);\n};\n","var tokenize = require('../tokenizer');\nvar TokenStream = require('../common/TokenStream');\nvar tokenStream = new TokenStream();\nvar astToTokens = {\n    decorator: function(handlers) {\n        var curNode = null;\n        var prev = { len: 0, node: null };\n        var nodes = [prev];\n        var buffer = '';\n\n        return {\n            children: handlers.children,\n            node: function(node) {\n                var tmp = curNode;\n                curNode = node;\n                handlers.node.call(this, node);\n                curNode = tmp;\n            },\n            chunk: function(chunk) {\n                buffer += chunk;\n                if (prev.node !== curNode) {\n                    nodes.push({\n                        len: chunk.length,\n                        node: curNode\n                    });\n                } else {\n                    prev.len += chunk.length;\n                }\n            },\n            result: function() {\n                return prepareTokens(buffer, nodes);\n            }\n        };\n    }\n};\n\nfunction prepareTokens(str, nodes) {\n    var tokens = [];\n    var nodesOffset = 0;\n    var nodesIndex = 0;\n    var currentNode = nodes ? nodes[nodesIndex].node : null;\n\n    tokenize(str, tokenStream);\n\n    while (!tokenStream.eof) {\n        if (nodes) {\n            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {\n                nodesOffset += nodes[nodesIndex++].len;\n                currentNode = nodes[nodesIndex].node;\n            }\n        }\n\n        tokens.push({\n            type: tokenStream.tokenType,\n            value: tokenStream.getTokenValue(),\n            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution\n            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution\n            node: currentNode\n        });\n        tokenStream.next();\n        // console.log({ ...tokens[tokens.length - 1], node: undefined });\n    }\n\n    return tokens;\n}\n\nmodule.exports = function(value, syntax) {\n    if (typeof value === 'string') {\n        return prepareTokens(value, null);\n    }\n\n    return syntax.generate(value, astToTokens);\n};\n","var parse = require('../definition-syntax/parse');\n\nvar MATCH = { type: 'Match' };\nvar MISMATCH = { type: 'Mismatch' };\nvar DISALLOW_EMPTY = { type: 'DisallowEmpty' };\nvar LEFTPARENTHESIS = 40;  // (\nvar RIGHTPARENTHESIS = 41; // )\n\nfunction createCondition(match, thenBranch, elseBranch) {\n    // reduce node count\n    if (thenBranch === MATCH && elseBranch === MISMATCH) {\n        return match;\n    }\n\n    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {\n        return match;\n    }\n\n    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {\n        thenBranch = match.then;\n        match = match.match;\n    }\n\n    return {\n        type: 'If',\n        match: match,\n        then: thenBranch,\n        else: elseBranch\n    };\n}\n\nfunction isFunctionType(name) {\n    return (\n        name.length > 2 &&\n        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS &&\n        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS\n    );\n}\n\nfunction isEnumCapatible(term) {\n    return (\n        term.type === 'Keyword' ||\n        term.type === 'AtKeyword' ||\n        term.type === 'Function' ||\n        term.type === 'Type' && isFunctionType(term.name)\n    );\n}\n\nfunction buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {\n    switch (combinator) {\n        case ' ':\n            // Juxtaposing components means that all of them must occur, in the given order.\n            //\n            // a b c\n            // =\n            // match a\n            //   then match b\n            //     then match c\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            //   else MISMATCH\n            var result = MATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n\n                result = createCondition(\n                    term,\n                    result,\n                    MISMATCH\n                );\n            };\n\n            return result;\n\n        case '|':\n            // A bar (|) separates two or more alternatives: exactly one of them must occur.\n            //\n            // a | b | c\n            // =\n            // match a\n            //   then MATCH\n            //   else match b\n            //     then MATCH\n            //     else match c\n            //       then MATCH\n            //       else MISMATCH\n\n            var result = MISMATCH;\n            var map = null;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n\n                // reduce sequence of keywords into a Enum\n                if (isEnumCapatible(term)) {\n                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {\n                        map = Object.create(null);\n                        result = createCondition(\n                            {\n                                type: 'Enum',\n                                map: map\n                            },\n                            MATCH,\n                            result\n                        );\n                    }\n\n                    if (map !== null) {\n                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();\n                        if (key in map === false) {\n                            map[key] = term;\n                            continue;\n                        }\n                    }\n                }\n\n                map = null;\n\n                // create a new conditonal node\n                result = createCondition(\n                    term,\n                    MATCH,\n                    result\n                );\n            };\n\n            return result;\n\n        case '&&':\n            // A double ampersand (&&) separates two or more components,\n            // all of which must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since &&-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms: terms,\n                    all: true\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a && b && c\n            // =\n            // match a\n            //   then [b && c]\n            //   else match b\n            //     then [a && c]\n            //     else match c\n            //       then [a && b]\n            //       else MISMATCH\n            //\n            // a && b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MISMATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MISMATCH\n            //     else MISMATCH\n            var result = MISMATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n                var thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        false\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n\n        case '||':\n            // A double bar (||) separates two or more options:\n            // one or more of them must occur, in any order.\n\n            // Use MatchOnce for groups with a large number of terms,\n            // since ||-groups produces at least N!-node trees\n            if (terms.length > 5) {\n                return {\n                    type: 'MatchOnce',\n                    terms: terms,\n                    all: false\n                };\n            }\n\n            // Use a combination tree for groups with small number of terms\n            //\n            // a || b || c\n            // =\n            // match a\n            //   then [b || c]\n            //   else match b\n            //     then [a || c]\n            //     else match c\n            //       then [a || b]\n            //       else MISMATCH\n            //\n            // a || b\n            // =\n            // match a\n            //   then match b\n            //     then MATCH\n            //     else MATCH\n            //   else match b\n            //     then match a\n            //       then MATCH\n            //       else MATCH\n            //     else MISMATCH\n            var result = atLeastOneTermMatched ? MATCH : MISMATCH;\n\n            for (var i = terms.length - 1; i >= 0; i--) {\n                var term = terms[i];\n                var thenClause;\n\n                if (terms.length > 1) {\n                    thenClause = buildGroupMatchGraph(\n                        combinator,\n                        terms.filter(function(newGroupTerm) {\n                            return newGroupTerm !== term;\n                        }),\n                        true\n                    );\n                } else {\n                    thenClause = MATCH;\n                }\n\n                result = createCondition(\n                    term,\n                    thenClause,\n                    result\n                );\n            };\n\n            return result;\n    }\n}\n\nfunction buildMultiplierMatchGraph(node) {\n    var result = MATCH;\n    var matchTerm = buildMatchGraph(node.term);\n\n    if (node.max === 0) {\n        // disable repeating of empty match to prevent infinite loop\n        matchTerm = createCondition(\n            matchTerm,\n            DISALLOW_EMPTY,\n            MISMATCH\n        );\n\n        // an occurrence count is not limited, make a cycle;\n        // to collect more terms on each following matching mismatch\n        result = createCondition(\n            matchTerm,\n            null, // will be a loop\n            MISMATCH\n        );\n\n        result.then = createCondition(\n            MATCH,\n            MATCH,\n            result // make a loop\n        );\n\n        if (node.comma) {\n            result.then.else = createCondition(\n                { type: 'Comma', syntax: node },\n                result,\n                MISMATCH\n            );\n        }\n    } else {\n        // create a match node chain for [min .. max] interval with optional matches\n        for (var i = node.min || 1; i <= node.max; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                createCondition(\n                    MATCH,\n                    MATCH,\n                    result\n                ),\n                MISMATCH\n            );\n        }\n    }\n\n    if (node.min === 0) {\n        // allow zero match\n        result = createCondition(\n            MATCH,\n            MATCH,\n            result\n        );\n    } else {\n        // create a match node chain to collect [0 ... min - 1] required matches\n        for (var i = 0; i < node.min - 1; i++) {\n            if (node.comma && result !== MATCH) {\n                result = createCondition(\n                    { type: 'Comma', syntax: node },\n                    result,\n                    MISMATCH\n                );\n            }\n\n            result = createCondition(\n                matchTerm,\n                result,\n                MISMATCH\n            );\n        }\n    }\n\n    return result;\n}\n\nfunction buildMatchGraph(node) {\n    if (typeof node === 'function') {\n        return {\n            type: 'Generic',\n            fn: node\n        };\n    }\n\n    switch (node.type) {\n        case 'Group':\n            var result = buildGroupMatchGraph(\n                node.combinator,\n                node.terms.map(buildMatchGraph),\n                false\n            );\n\n            if (node.disallowEmpty) {\n                result = createCondition(\n                    result,\n                    DISALLOW_EMPTY,\n                    MISMATCH\n                );\n            }\n\n            return result;\n\n        case 'Multiplier':\n            return buildMultiplierMatchGraph(node);\n\n        case 'Type':\n        case 'Property':\n            return {\n                type: node.type,\n                name: node.name,\n                syntax: node\n            };\n\n        case 'Keyword':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'AtKeyword':\n            return {\n                type: node.type,\n                name: '@' + node.name.toLowerCase(),\n                syntax: node\n            };\n\n        case 'Function':\n            return {\n                type: node.type,\n                name: node.name.toLowerCase() + '(',\n                syntax: node\n            };\n\n        case 'String':\n            // convert a one char length String to a Token\n            if (node.value.length === 3) {\n                return {\n                    type: 'Token',\n                    value: node.value.charAt(1),\n                    syntax: node\n                };\n            }\n\n            // otherwise use it as is\n            return {\n                type: node.type,\n                value: node.value.substr(1, node.value.length - 2).replace(/\\\\'/g, '\\''),\n                syntax: node\n            };\n\n        case 'Token':\n            return {\n                type: node.type,\n                value: node.value,\n                syntax: node\n            };\n\n        case 'Comma':\n            return {\n                type: node.type,\n                syntax: node\n            };\n\n        default:\n            throw new Error('Unknown node type:', node.type);\n    }\n}\n\nmodule.exports = {\n    MATCH: MATCH,\n    MISMATCH: MISMATCH,\n    DISALLOW_EMPTY: DISALLOW_EMPTY,\n    buildMatchGraph: function(syntaxTree, ref) {\n        if (typeof syntaxTree === 'string') {\n            syntaxTree = parse(syntaxTree);\n        }\n\n        return {\n            type: 'MatchGraph',\n            match: buildMatchGraph(syntaxTree),\n            syntax: ref || null,\n            source: syntaxTree\n        };\n    }\n};\n","var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar matchGraph = require('./match-graph');\nvar MATCH = matchGraph.MATCH;\nvar MISMATCH = matchGraph.MISMATCH;\nvar DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;\nvar TYPE = require('../tokenizer/const').TYPE;\n\nvar STUB = 0;\nvar TOKEN = 1;\nvar OPEN_SYNTAX = 2;\nvar CLOSE_SYNTAX = 3;\n\nvar EXIT_REASON_MATCH = 'Match';\nvar EXIT_REASON_MISMATCH = 'Mismatch';\nvar EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';\n\nvar ITERATION_LIMIT = 15000;\nvar totalIterationCount = 0;\n\nfunction reverseList(list) {\n    var prev = null;\n    var next = null;\n    var item = list;\n\n    while (item !== null) {\n        next = item.prev;\n        item.prev = prev;\n        prev = item;\n        item = next;\n    }\n\n    return prev;\n}\n\nfunction areStringsEqualCaseInsensitive(testStr, referenceStr) {\n    if (testStr.length !== referenceStr.length) {\n        return false;\n    }\n\n    for (var i = 0; i < testStr.length; i++) {\n        var testCode = testStr.charCodeAt(i);\n        var referenceCode = referenceStr.charCodeAt(i);\n\n        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).\n        if (testCode >= 0x0041 && testCode <= 0x005A) {\n            testCode = testCode | 32;\n        }\n\n        if (testCode !== referenceCode) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nfunction isCommaContextStart(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.Comma ||\n        token.type === TYPE.Function ||\n        token.type === TYPE.LeftParenthesis ||\n        token.type === TYPE.LeftSquareBracket ||\n        token.type === TYPE.LeftCurlyBracket ||\n        token.type === TYPE.Delim\n    );\n}\n\nfunction isCommaContextEnd(token) {\n    if (token === null) {\n        return true;\n    }\n\n    return (\n        token.type === TYPE.RightParenthesis ||\n        token.type === TYPE.RightSquareBracket ||\n        token.type === TYPE.RightCurlyBracket ||\n        token.type === TYPE.Delim\n    );\n}\n\nfunction internalMatch(tokens, state, syntaxes) {\n    function moveToNextToken() {\n        do {\n            tokenIndex++;\n            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));\n    }\n\n    function getNextToken(offset) {\n        var nextIndex = tokenIndex + offset;\n\n        return nextIndex < tokens.length ? tokens[nextIndex] : null;\n    }\n\n    function stateSnapshotFromSyntax(nextState, prev) {\n        return {\n            nextState: nextState,\n            matchStack: matchStack,\n            syntaxStack: syntaxStack,\n            thenStack: thenStack,\n            tokenIndex: tokenIndex,\n            prev: prev\n        };\n    }\n\n    function pushThenStack(nextState) {\n        thenStack = {\n            nextState: nextState,\n            matchStack: matchStack,\n            syntaxStack: syntaxStack,\n            prev: thenStack\n        };\n    }\n\n    function pushElseStack(nextState) {\n        elseStack = stateSnapshotFromSyntax(nextState, elseStack);\n    }\n\n    function addTokenToMatch() {\n        matchStack = {\n            type: TOKEN,\n            syntax: state.syntax,\n            token: token,\n            prev: matchStack\n        };\n\n        moveToNextToken();\n        syntaxStash = null;\n\n        if (tokenIndex > longestMatch) {\n            longestMatch = tokenIndex;\n        }\n    }\n\n    function openSyntax() {\n        syntaxStack = {\n            syntax: state.syntax,\n            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,\n            prev: syntaxStack\n        };\n\n        matchStack = {\n            type: OPEN_SYNTAX,\n            syntax: state.syntax,\n            token: matchStack.token,\n            prev: matchStack\n        };\n    }\n\n    function closeSyntax() {\n        if (matchStack.type === OPEN_SYNTAX) {\n            matchStack = matchStack.prev;\n        } else {\n            matchStack = {\n                type: CLOSE_SYNTAX,\n                syntax: syntaxStack.syntax,\n                token: matchStack.token,\n                prev: matchStack\n            };\n        }\n\n        syntaxStack = syntaxStack.prev;\n    }\n\n    var syntaxStack = null;\n    var thenStack = null;\n    var elseStack = null;\n\n    // null – stashing allowed, nothing stashed\n    // false – stashing disabled, nothing stashed\n    // anithing else – fail stashable syntaxes, some syntax stashed\n    var syntaxStash = null;\n\n    var iterationCount = 0; // count iterations and prevent infinite loop\n    var exitReason = null;\n\n    var token = null;\n    var tokenIndex = -1;\n    var longestMatch = 0;\n    var matchStack = {\n        type: STUB,\n        syntax: null,\n        token: null,\n        prev: null\n    };\n\n    moveToNextToken();\n\n    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {\n        // function mapList(list, fn) {\n        //     var result = [];\n        //     while (list) {\n        //         result.unshift(fn(list));\n        //         list = list.prev;\n        //     }\n        //     return result;\n        // }\n        // console.log('--\\n',\n        //     '#' + iterationCount,\n        //     require('util').inspect({\n        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),\n        //         token: token && token.value,\n        //         tokenIndex,\n        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')\n        //     }, { depth: null })\n        // );\n        switch (state.type) {\n            case 'Match':\n                if (thenStack === null) {\n                    // turn to MISMATCH when some tokens left unmatched\n                    if (token !== null) {\n                        // doesn't mismatch if just one token left and it's an IE hack\n                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\\\0' && token.value !== '\\\\9')) {\n                            state = MISMATCH;\n                            break;\n                        }\n                    }\n\n                    // break the main loop, return a result - MATCH\n                    exitReason = EXIT_REASON_MATCH;\n                    break;\n                }\n\n                // go to next syntax (`then` branch)\n                state = thenStack.nextState;\n\n                // check match is not empty\n                if (state === DISALLOW_EMPTY) {\n                    if (thenStack.matchStack === matchStack) {\n                        state = MISMATCH;\n                        break;\n                    } else {\n                        state = MATCH;\n                    }\n                }\n\n                // close syntax if needed\n                while (thenStack.syntaxStack !== syntaxStack) {\n                    closeSyntax();\n                }\n\n                // pop stack\n                thenStack = thenStack.prev;\n                break;\n\n            case 'Mismatch':\n                // when some syntax is stashed\n                if (syntaxStash !== null && syntaxStash !== false) {\n                    // there is no else branches or a branch reduce match stack\n                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {\n                        // restore state from the stash\n                        elseStack = syntaxStash;\n                        syntaxStash = false; // disable stashing\n                    }\n                } else if (elseStack === null) {\n                    // no else branches -> break the main loop\n                    // return a result - MISMATCH\n                    exitReason = EXIT_REASON_MISMATCH;\n                    break;\n                }\n\n                // go to next syntax (`else` branch)\n                state = elseStack.nextState;\n\n                // restore all the rest stack states\n                thenStack = elseStack.thenStack;\n                syntaxStack = elseStack.syntaxStack;\n                matchStack = elseStack.matchStack;\n                tokenIndex = elseStack.tokenIndex;\n                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;\n\n                // pop stack\n                elseStack = elseStack.prev;\n                break;\n\n            case 'MatchGraph':\n                state = state.match;\n                break;\n\n            case 'If':\n                // IMPORTANT: else stack push must go first,\n                // since it stores the state of thenStack before changes\n                if (state.else !== MISMATCH) {\n                    pushElseStack(state.else);\n                }\n\n                if (state.then !== MATCH) {\n                    pushThenStack(state.then);\n                }\n\n                state = state.match;\n                break;\n\n            case 'MatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state,\n                    index: 0,\n                    mask: 0\n                };\n                break;\n\n            case 'MatchOnceBuffer':\n                var terms = state.syntax.terms;\n\n                if (state.index === terms.length) {\n                    // no matches at all or it's required all terms to be matched\n                    if (state.mask === 0 || state.syntax.all) {\n                        state = MISMATCH;\n                        break;\n                    }\n\n                    // a partial match is ok\n                    state = MATCH;\n                    break;\n                }\n\n                // all terms are matched\n                if (state.mask === (1 << terms.length) - 1) {\n                    state = MATCH;\n                    break;\n                }\n\n                for (; state.index < terms.length; state.index++) {\n                    var matchFlag = 1 << state.index;\n\n                    if ((state.mask & matchFlag) === 0) {\n                        // IMPORTANT: else stack push must go first,\n                        // since it stores the state of thenStack before changes\n                        pushElseStack(state);\n                        pushThenStack({\n                            type: 'AddMatchOnce',\n                            syntax: state.syntax,\n                            mask: state.mask | matchFlag\n                        });\n\n                        // match\n                        state = terms[state.index++];\n                        break;\n                    }\n                }\n                break;\n\n            case 'AddMatchOnce':\n                state = {\n                    type: 'MatchOnceBuffer',\n                    syntax: state.syntax,\n                    index: 0,\n                    mask: state.mask\n                };\n                break;\n\n            case 'Enum':\n                if (token !== null) {\n                    var name = token.value.toLowerCase();\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (name.indexOf('\\\\') !== -1) {\n                        name = name.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (hasOwnProperty.call(state.map, name)) {\n                        state = state.map[name];\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Generic':\n                var opts = syntaxStack !== null ? syntaxStack.opts : null;\n                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));\n\n                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n\n            case 'Type':\n            case 'Property':\n                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';\n                var dictSyntax = hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;\n\n                if (!dictSyntax || !dictSyntax.match) {\n                    throw new Error(\n                        'Bad syntax reference: ' +\n                        (state.type === 'Type'\n                            ? '<' + state.name + '>'\n                            : '<\\'' + state.name + '\\'>')\n                    );\n                }\n\n                // stash a syntax for types with low priority\n                if (syntaxStash !== false && token !== null && state.type === 'Type') {\n                    var lowPriorityMatching =\n                        // https://drafts.csswg.org/css-values-4/#custom-idents\n                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production\n                        // can only claim the keyword if no other unfulfilled production can claim it.\n                        (state.name === 'custom-ident' && token.type === TYPE.Ident) ||\n\n                        // https://drafts.csswg.org/css-values-4/#lengths\n                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),\n                        // it must parse as a <number>\n                        (state.name === 'length' && token.value === '0');\n\n                    if (lowPriorityMatching) {\n                        if (syntaxStash === null) {\n                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);\n                        }\n\n                        state = MISMATCH;\n                        break;\n                    }\n                }\n\n                openSyntax();\n                state = dictSyntax.match;\n                break;\n\n            case 'Keyword':\n                var name = state.name;\n\n                if (token !== null) {\n                    var keywordName = token.value;\n\n                    // drop \\0 and \\9 hack from keyword name\n                    if (keywordName.indexOf('\\\\') !== -1) {\n                        keywordName = keywordName.replace(/\\\\[09].*$/, '');\n                    }\n\n                    if (areStringsEqualCaseInsensitive(keywordName, name)) {\n                        addTokenToMatch();\n                        state = MATCH;\n                        break;\n                    }\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'AtKeyword':\n            case 'Function':\n                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Token':\n                if (token !== null && token.value === state.value) {\n                    addTokenToMatch();\n                    state = MATCH;\n                    break;\n                }\n\n                state = MISMATCH;\n                break;\n\n            case 'Comma':\n                if (token !== null && token.type === TYPE.Comma) {\n                    if (isCommaContextStart(matchStack.token)) {\n                        state = MISMATCH;\n                    } else {\n                        addTokenToMatch();\n                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;\n                    }\n                } else {\n                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;\n                }\n\n                break;\n\n            case 'String':\n                var string = '';\n\n                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {\n                    string += tokens[lastTokenIndex].value;\n                }\n\n                if (areStringsEqualCaseInsensitive(string, state.value)) {\n                    while (tokenIndex < lastTokenIndex) {\n                        addTokenToMatch();\n                    }\n\n                    state = MATCH;\n                } else {\n                    state = MISMATCH;\n                }\n\n                break;\n\n            default:\n                throw new Error('Unknown node type: ' + state.type);\n        }\n    }\n\n    totalIterationCount += iterationCount;\n\n    switch (exitReason) {\n        case null:\n            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');\n            exitReason = EXIT_REASON_ITERATION_LIMIT;\n            matchStack = null;\n            break;\n\n        case EXIT_REASON_MATCH:\n            while (syntaxStack !== null) {\n                closeSyntax();\n            }\n            break;\n\n        default:\n            matchStack = null;\n    }\n\n    return {\n        tokens: tokens,\n        reason: exitReason,\n        iterations: iterationCount,\n        match: matchStack,\n        longestMatch: longestMatch\n    };\n}\n\nfunction matchAsList(tokens, matchGraph, syntaxes) {\n    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match !== null) {\n        var item = reverseList(matchResult.match).prev;\n\n        matchResult.match = [];\n\n        while (item !== null) {\n            switch (item.type) {\n                case STUB:\n                    break;\n\n                case OPEN_SYNTAX:\n                case CLOSE_SYNTAX:\n                    matchResult.match.push({\n                        type: item.type,\n                        syntax: item.syntax\n                    });\n                    break;\n\n                default:\n                    matchResult.match.push({\n                        token: item.token.value,\n                        node: item.token.node\n                    });\n                    break;\n            }\n\n            item = item.prev;\n        }\n    }\n\n    return matchResult;\n}\n\nfunction matchAsTree(tokens, matchGraph, syntaxes) {\n    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});\n\n    if (matchResult.match === null) {\n        return matchResult;\n    }\n\n    var item = matchResult.match;\n    var host = matchResult.match = {\n        syntax: matchGraph.syntax || null,\n        match: []\n    };\n    var hostStack = [host];\n\n    // revert a list and start with 2nd item since 1st is a stub item\n    item = reverseList(item).prev;\n\n    // build a tree\n    while (item !== null) {\n        switch (item.type) {\n            case OPEN_SYNTAX:\n                host.match.push(host = {\n                    syntax: item.syntax,\n                    match: []\n                });\n                hostStack.push(host);\n                break;\n\n            case CLOSE_SYNTAX:\n                hostStack.pop();\n                host = hostStack[hostStack.length - 1];\n                break;\n\n            default:\n                host.match.push({\n                    syntax: item.syntax || null,\n                    token: item.token.value,\n                    node: item.token.node\n                });\n        }\n\n        item = item.prev;\n    }\n\n    return matchResult;\n}\n\nmodule.exports = {\n    matchAsList: matchAsList,\n    matchAsTree: matchAsTree,\n    getTotalIterationCount: function() {\n        return totalIterationCount;\n    }\n};\n","function getTrace(node) {\n    function shouldPutToTrace(syntax) {\n        if (syntax === null) {\n            return false;\n        }\n\n        return (\n            syntax.type === 'Type' ||\n            syntax.type === 'Property' ||\n            syntax.type === 'Keyword'\n        );\n    }\n\n    function hasMatch(matchNode) {\n        if (Array.isArray(matchNode.match)) {\n            // use for-loop for better perfomance\n            for (var i = 0; i < matchNode.match.length; i++) {\n                if (hasMatch(matchNode.match[i])) {\n                    if (shouldPutToTrace(matchNode.syntax)) {\n                        result.unshift(matchNode.syntax);\n                    }\n\n                    return true;\n                }\n            }\n        } else if (matchNode.node === node) {\n            result = shouldPutToTrace(matchNode.syntax)\n                ? [matchNode.syntax]\n                : [];\n\n            return true;\n        }\n\n        return false;\n    }\n\n    var result = null;\n\n    if (this.matched !== null) {\n        hasMatch(this.matched);\n    }\n\n    return result;\n}\n\nfunction testNode(match, node, fn) {\n    var trace = getTrace.call(match, node);\n\n    if (trace === null) {\n        return false;\n    }\n\n    return trace.some(fn);\n}\n\nfunction isType(node, type) {\n    return testNode(this, node, function(matchNode) {\n        return matchNode.type === 'Type' && matchNode.name === type;\n    });\n}\n\nfunction isProperty(node, property) {\n    return testNode(this, node, function(matchNode) {\n        return matchNode.type === 'Property' && matchNode.name === property;\n    });\n}\n\nfunction isKeyword(node) {\n    return testNode(this, node, function(matchNode) {\n        return matchNode.type === 'Keyword';\n    });\n}\n\nmodule.exports = {\n    getTrace: getTrace,\n    isType: isType,\n    isProperty: isProperty,\n    isKeyword: isKeyword\n};\n","var List = require('../common/List');\n\nfunction getFirstMatchNode(matchNode) {\n    if ('node' in matchNode) {\n        return matchNode.node;\n    }\n\n    return getFirstMatchNode(matchNode.match[0]);\n}\n\nfunction getLastMatchNode(matchNode) {\n    if ('node' in matchNode) {\n        return matchNode.node;\n    }\n\n    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);\n}\n\nfunction matchFragments(lexer, ast, match, type, name) {\n    function findFragments(matchNode) {\n        if (matchNode.syntax !== null &&\n            matchNode.syntax.type === type &&\n            matchNode.syntax.name === name) {\n            var start = getFirstMatchNode(matchNode);\n            var end = getLastMatchNode(matchNode);\n\n            lexer.syntax.walk(ast, function(node, item, list) {\n                if (node === start) {\n                    var nodes = new List();\n\n                    do {\n                        nodes.appendData(item.data);\n\n                        if (item.data === end) {\n                            break;\n                        }\n\n                        item = item.next;\n                    } while (item !== null);\n\n                    fragments.push({\n                        parent: list,\n                        nodes: nodes\n                    });\n                }\n            });\n        }\n\n        if (Array.isArray(matchNode.match)) {\n            matchNode.match.forEach(findFragments);\n        }\n    }\n\n    var fragments = [];\n\n    if (match.matched !== null) {\n        findFragments(match.matched);\n    }\n\n    return fragments;\n}\n\nmodule.exports = {\n    matchFragments: matchFragments\n};\n","var List = require('../common/List');\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction isValidNumber(value) {\n    // Number.isInteger(value) && value >= 0\n    return (\n        typeof value === 'number' &&\n        isFinite(value) &&\n        Math.floor(value) === value &&\n        value >= 0\n    );\n}\n\nfunction isValidLocation(loc) {\n    return (\n        Boolean(loc) &&\n        isValidNumber(loc.offset) &&\n        isValidNumber(loc.line) &&\n        isValidNumber(loc.column)\n    );\n}\n\nfunction createNodeStructureChecker(type, fields) {\n    return function checkNode(node, warn) {\n        if (!node || node.constructor !== Object) {\n            return warn(node, 'Type of node should be an Object');\n        }\n\n        for (var key in node) {\n            var valid = true;\n\n            if (hasOwnProperty.call(node, key) === false) {\n                continue;\n            }\n\n            if (key === 'type') {\n                if (node.type !== type) {\n                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');\n                }\n            } else if (key === 'loc') {\n                if (node.loc === null) {\n                    continue;\n                } else if (node.loc && node.loc.constructor === Object) {\n                    if (typeof node.loc.source !== 'string') {\n                        key += '.source';\n                    } else if (!isValidLocation(node.loc.start)) {\n                        key += '.start';\n                    } else if (!isValidLocation(node.loc.end)) {\n                        key += '.end';\n                    } else {\n                        continue;\n                    }\n                }\n\n                valid = false;\n            } else if (fields.hasOwnProperty(key)) {\n                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {\n                    var fieldType = fields[key][i];\n\n                    switch (fieldType) {\n                        case String:\n                            valid = typeof node[key] === 'string';\n                            break;\n\n                        case Boolean:\n                            valid = typeof node[key] === 'boolean';\n                            break;\n\n                        case null:\n                            valid = node[key] === null;\n                            break;\n\n                        default:\n                            if (typeof fieldType === 'string') {\n                                valid = node[key] && node[key].type === fieldType;\n                            } else if (Array.isArray(fieldType)) {\n                                valid = node[key] instanceof List;\n                            }\n                    }\n                }\n            } else {\n                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');\n            }\n\n            if (!valid) {\n                warn(node, 'Bad value for `' + type + '.' + key + '`');\n            }\n        }\n\n        for (var key in fields) {\n            if (hasOwnProperty.call(fields, key) &&\n                hasOwnProperty.call(node, key) === false) {\n                warn(node, 'Field `' + type + '.' + key + '` is missed');\n            }\n        }\n    };\n}\n\nfunction processStructure(name, nodeType) {\n    var structure = nodeType.structure;\n    var fields = {\n        type: String,\n        loc: true\n    };\n    var docs = {\n        type: '\"' + name + '\"'\n    };\n\n    for (var key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        var docsTypes = [];\n        var fieldTypes = fields[key] = Array.isArray(structure[key])\n            ? structure[key].slice()\n            : [structure[key]];\n\n        for (var i = 0; i < fieldTypes.length; i++) {\n            var fieldType = fieldTypes[i];\n            if (fieldType === String || fieldType === Boolean) {\n                docsTypes.push(fieldType.name);\n            } else if (fieldType === null) {\n                docsTypes.push('null');\n            } else if (typeof fieldType === 'string') {\n                docsTypes.push('<' + fieldType + '>');\n            } else if (Array.isArray(fieldType)) {\n                docsTypes.push('List'); // TODO: use type enum\n            } else {\n                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');\n            }\n        }\n\n        docs[key] = docsTypes.join(' | ');\n    }\n\n    return {\n        docs: docs,\n        check: createNodeStructureChecker(name, fields)\n    };\n}\n\nmodule.exports = {\n    getStructureFromConfig: function(config) {\n        var structure = {};\n\n        if (config.node) {\n            for (var name in config.node) {\n                if (hasOwnProperty.call(config.node, name)) {\n                    var nodeType = config.node[name];\n\n                    if (nodeType.structure) {\n                        structure[name] = processStructure(name, nodeType);\n                    } else {\n                        throw new Error('Missed `structure` field in `' + name + '` node type definition');\n                    }\n                }\n            }\n        }\n\n        return structure;\n    }\n};\n","module.exports = {\n    SyntaxError: require('./SyntaxError'),\n    parse: require('./parse'),\n    generate: require('./generate'),\n    walk: require('./walk')\n};\n","var OffsetToLocation = require('../common/OffsetToLocation');\nvar SyntaxError = require('../common/SyntaxError');\nvar TokenStream = require('../common/TokenStream');\nvar List = require('../common/List');\nvar tokenize = require('../tokenizer');\nvar constants = require('../tokenizer/const');\nvar findWhiteSpaceStart = require('../tokenizer/utils').findWhiteSpaceStart;\nvar sequence = require('./sequence');\nvar noop = function() {};\n\nvar TYPE = constants.TYPE;\nvar NAME = constants.NAME;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar URL = TYPE.Url;\nvar HASH = TYPE.Hash;\nvar PERCENTAGE = TYPE.Percentage;\nvar NUMBER = TYPE.Number;\nvar NUMBERSIGN = 0x0023; // U+0023 NUMBER SIGN (#)\nvar NULL = 0;\n\nfunction createParseContext(name) {\n    return function() {\n        return this[name]();\n    };\n}\n\nfunction processConfig(config) {\n    var parserConfig = {\n        context: {},\n        scope: {},\n        atrule: {},\n        pseudo: {}\n    };\n\n    if (config.parseContext) {\n        for (var name in config.parseContext) {\n            switch (typeof config.parseContext[name]) {\n                case 'function':\n                    parserConfig.context[name] = config.parseContext[name];\n                    break;\n\n                case 'string':\n                    parserConfig.context[name] = createParseContext(config.parseContext[name]);\n                    break;\n            }\n        }\n    }\n\n    if (config.scope) {\n        for (var name in config.scope) {\n            parserConfig.scope[name] = config.scope[name];\n        }\n    }\n\n    if (config.atrule) {\n        for (var name in config.atrule) {\n            var atrule = config.atrule[name];\n\n            if (atrule.parse) {\n                parserConfig.atrule[name] = atrule.parse;\n            }\n        }\n    }\n\n    if (config.pseudo) {\n        for (var name in config.pseudo) {\n            var pseudo = config.pseudo[name];\n\n            if (pseudo.parse) {\n                parserConfig.pseudo[name] = pseudo.parse;\n            }\n        }\n    }\n\n    if (config.node) {\n        for (var name in config.node) {\n            parserConfig[name] = config.node[name].parse;\n        }\n    }\n\n    return parserConfig;\n}\n\nmodule.exports = function createParser(config) {\n    var parser = {\n        scanner: new TokenStream(),\n        locationMap: new OffsetToLocation(),\n\n        filename: '<unknown>',\n        needPositions: false,\n        onParseError: noop,\n        onParseErrorThrow: false,\n        parseAtrulePrelude: true,\n        parseRulePrelude: true,\n        parseValue: true,\n        parseCustomProperty: false,\n\n        readSequence: sequence,\n\n        createList: function() {\n            return new List();\n        },\n        createSingleNodeList: function(node) {\n            return new List().appendData(node);\n        },\n        getFirstListNode: function(list) {\n            return list && list.first();\n        },\n        getLastListNode: function(list) {\n            return list.last();\n        },\n\n        parseWithFallback: function(consumer, fallback) {\n            var startToken = this.scanner.tokenIndex;\n\n            try {\n                return consumer.call(this);\n            } catch (e) {\n                if (this.onParseErrorThrow) {\n                    throw e;\n                }\n\n                var fallbackNode = fallback.call(this, startToken);\n\n                this.onParseErrorThrow = true;\n                this.onParseError(e, fallbackNode);\n                this.onParseErrorThrow = false;\n\n                return fallbackNode;\n            }\n        },\n\n        lookupNonWSType: function(offset) {\n            do {\n                var type = this.scanner.lookupType(offset++);\n                if (type !== WHITESPACE) {\n                    return type;\n                }\n            } while (type !== NULL);\n\n            return NULL;\n        },\n\n        eat: function(tokenType) {\n            if (this.scanner.tokenType !== tokenType) {\n                var offset = this.scanner.tokenStart;\n                var message = NAME[tokenType] + ' is expected';\n\n                // tweak message and offset\n                switch (tokenType) {\n                    case IDENT:\n                        // when identifier is expected but there is a function or url\n                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {\n                            offset = this.scanner.tokenEnd - 1;\n                            message = 'Identifier is expected but function found';\n                        } else {\n                            message = 'Identifier is expected';\n                        }\n                        break;\n\n                    case HASH:\n                        if (this.scanner.isDelim(NUMBERSIGN)) {\n                            this.scanner.next();\n                            offset++;\n                            message = 'Name is expected';\n                        }\n                        break;\n\n                    case PERCENTAGE:\n                        if (this.scanner.tokenType === NUMBER) {\n                            offset = this.scanner.tokenEnd;\n                            message = 'Percent sign is expected';\n                        }\n                        break;\n\n                    default:\n                        // when test type is part of another token show error for current position + 1\n                        // e.g. eat(HYPHENMINUS) will fail on \"-foo\", but pointing on \"-\" is odd\n                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {\n                            offset = offset + 1;\n                        }\n                }\n\n                this.error(message, offset);\n            }\n\n            this.scanner.next();\n        },\n\n        consume: function(tokenType) {\n            var value = this.scanner.getTokenValue();\n\n            this.eat(tokenType);\n\n            return value;\n        },\n        consumeFunctionName: function() {\n            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);\n\n            this.eat(FUNCTION);\n\n            return name;\n        },\n\n        getLocation: function(start, end) {\n            if (this.needPositions) {\n                return this.locationMap.getLocationRange(\n                    start,\n                    end,\n                    this.filename\n                );\n            }\n\n            return null;\n        },\n        getLocationFromList: function(list) {\n            if (this.needPositions) {\n                var head = this.getFirstListNode(list);\n                var tail = this.getLastListNode(list);\n                return this.locationMap.getLocationRange(\n                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,\n                    this.filename\n                );\n            }\n\n            return null;\n        },\n\n        error: function(message, offset) {\n            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length\n                ? this.locationMap.getLocation(offset)\n                : this.scanner.eof\n                    ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1))\n                    : this.locationMap.getLocation(this.scanner.tokenStart);\n\n            throw new SyntaxError(\n                message || 'Unexpected input',\n                this.scanner.source,\n                location.offset,\n                location.line,\n                location.column\n            );\n        }\n    };\n\n    config = processConfig(config || {});\n    for (var key in config) {\n        parser[key] = config[key];\n    }\n\n    return function(source, options) {\n        options = options || {};\n\n        var context = options.context || 'default';\n        var ast;\n\n        tokenize(source, parser.scanner);\n        parser.locationMap.setSource(\n            source,\n            options.offset,\n            options.line,\n            options.column\n        );\n\n        parser.filename = options.filename || '<unknown>';\n        parser.needPositions = Boolean(options.positions);\n        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop;\n        parser.onParseErrorThrow = false;\n        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;\n        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;\n        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;\n        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;\n\n        if (!parser.context.hasOwnProperty(context)) {\n            throw new Error('Unknown context `' + context + '`');\n        }\n\n        ast = parser.context[context].call(parser, options);\n\n        if (!parser.scanner.eof) {\n            parser.error();\n        }\n\n        return ast;\n    };\n};\n","var adoptBuffer = require('./adopt-buffer');\nvar isBOM = require('../tokenizer').isBOM;\n\nvar N = 10;\nvar F = 12;\nvar R = 13;\n\nfunction computeLinesAndColumns(host, source) {\n    var sourceLength = source.length;\n    var lines = adoptBuffer(host.lines, sourceLength); // +1\n    var line = host.startLine;\n    var columns = adoptBuffer(host.columns, sourceLength);\n    var column = host.startColumn;\n    var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;\n\n    for (var i = startOffset; i < sourceLength; i++) { // -1\n        var code = source.charCodeAt(i);\n\n        lines[i] = line;\n        columns[i] = column++;\n\n        if (code === N || code === R || code === F) {\n            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {\n                i++;\n                lines[i] = line;\n                columns[i] = column;\n            }\n\n            line++;\n            column = 1;\n        }\n    }\n\n    lines[i] = line;\n    columns[i] = column;\n\n    host.lines = lines;\n    host.columns = columns;\n}\n\nvar OffsetToLocation = function() {\n    this.lines = null;\n    this.columns = null;\n    this.linesAndColumnsComputed = false;\n};\n\nOffsetToLocation.prototype = {\n    setSource: function(source, startOffset, startLine, startColumn) {\n        this.source = source;\n        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;\n        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;\n        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;\n        this.linesAndColumnsComputed = false;\n    },\n\n    ensureLinesAndColumnsComputed: function() {\n        if (!this.linesAndColumnsComputed) {\n            computeLinesAndColumns(this, this.source);\n            this.linesAndColumnsComputed = true;\n        }\n    },\n    getLocation: function(offset, filename) {\n        this.ensureLinesAndColumnsComputed();\n\n        return {\n            source: filename,\n            offset: this.startOffset + offset,\n            line: this.lines[offset],\n            column: this.columns[offset]\n        };\n    },\n    getLocationRange: function(start, end, filename) {\n        this.ensureLinesAndColumnsComputed();\n\n        return {\n            source: filename,\n            start: {\n                offset: this.startOffset + start,\n                line: this.lines[start],\n                column: this.columns[start]\n            },\n            end: {\n                offset: this.startOffset + end,\n                line: this.lines[end],\n                column: this.columns[end]\n            }\n        };\n    }\n};\n\nmodule.exports = OffsetToLocation;\n","var TYPE = require('../tokenizer').TYPE;\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\n\nmodule.exports = function readSequence(recognizer) {\n    var children = this.createList();\n    var child = null;\n    var context = {\n        recognizer: recognizer,\n        space: null,\n        ignoreWS: false,\n        ignoreWSAfter: false\n    };\n\n    this.scanner.skipSC();\n\n    while (!this.scanner.eof) {\n        switch (this.scanner.tokenType) {\n            case COMMENT:\n                this.scanner.next();\n                continue;\n\n            case WHITESPACE:\n                if (context.ignoreWS) {\n                    this.scanner.next();\n                } else {\n                    context.space = this.WhiteSpace();\n                }\n                continue;\n        }\n\n        child = recognizer.getNode.call(this, context);\n\n        if (child === undefined) {\n            break;\n        }\n\n        if (context.space !== null) {\n            children.push(context.space);\n            context.space = null;\n        }\n\n        children.push(child);\n\n        if (context.ignoreWSAfter) {\n            context.ignoreWSAfter = false;\n            context.ignoreWS = true;\n        } else {\n            context.ignoreWS = false;\n        }\n    }\n\n    return children;\n};\n","var sourceMap = require('./sourceMap');\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction processChildren(node, delimeter) {\n    var list = node.children;\n    var prev = null;\n\n    if (typeof delimeter !== 'function') {\n        list.forEach(this.node, this);\n    } else {\n        list.forEach(function(node) {\n            if (prev !== null) {\n                delimeter.call(this, prev);\n            }\n\n            this.node(node);\n            prev = node;\n        }, this);\n    }\n}\n\nmodule.exports = function createGenerator(config) {\n    function processNode(node) {\n        if (hasOwnProperty.call(types, node.type)) {\n            types[node.type].call(this, node);\n        } else {\n            throw new Error('Unknown node type: ' + node.type);\n        }\n    }\n\n    var types = {};\n\n    if (config.node) {\n        for (var name in config.node) {\n            types[name] = config.node[name].generate;\n        }\n    }\n\n    return function(node, options) {\n        var buffer = '';\n        var handlers = {\n            children: processChildren,\n            node: processNode,\n            chunk: function(chunk) {\n                buffer += chunk;\n            },\n            result: function() {\n                return buffer;\n            }\n        };\n\n        if (options) {\n            if (typeof options.decorator === 'function') {\n                handlers = options.decorator(handlers);\n            }\n\n            if (options.sourceMap) {\n                handlers = sourceMap(handlers);\n            }\n        }\n\n        handlers.node(node);\n\n        return handlers.result();\n    };\n};\n","var SourceMapGenerator = require('source-map/lib/source-map-generator').SourceMapGenerator;\nvar trackNodes = {\n    Atrule: true,\n    Selector: true,\n    Declaration: true\n};\n\nmodule.exports = function generateSourceMap(handlers) {\n    var map = new SourceMapGenerator();\n    var line = 1;\n    var column = 0;\n    var generated = {\n        line: 1,\n        column: 0\n    };\n    var original = {\n        line: 0, // should be zero to add first mapping\n        column: 0\n    };\n    var sourceMappingActive = false;\n    var activatedGenerated = {\n        line: 1,\n        column: 0\n    };\n    var activatedMapping = {\n        generated: activatedGenerated\n    };\n\n    var handlersNode = handlers.node;\n    handlers.node = function(node) {\n        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {\n            var nodeLine = node.loc.start.line;\n            var nodeColumn = node.loc.start.column - 1;\n\n            if (original.line !== nodeLine ||\n                original.column !== nodeColumn) {\n                original.line = nodeLine;\n                original.column = nodeColumn;\n\n                generated.line = line;\n                generated.column = column;\n\n                if (sourceMappingActive) {\n                    sourceMappingActive = false;\n                    if (generated.line !== activatedGenerated.line ||\n                        generated.column !== activatedGenerated.column) {\n                        map.addMapping(activatedMapping);\n                    }\n                }\n\n                sourceMappingActive = true;\n                map.addMapping({\n                    source: node.loc.source,\n                    original: original,\n                    generated: generated\n                });\n            }\n        }\n\n        handlersNode.call(this, node);\n\n        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {\n            activatedGenerated.line = line;\n            activatedGenerated.column = column;\n        }\n    };\n\n    var handlersChunk = handlers.chunk;\n    handlers.chunk = function(chunk) {\n        for (var i = 0; i < chunk.length; i++) {\n            if (chunk.charCodeAt(i) === 10) { // \\n\n                line++;\n                column = 0;\n            } else {\n                column++;\n            }\n        }\n\n        handlersChunk(chunk);\n    };\n\n    var handlersResult = handlers.result;\n    handlers.result = function() {\n        if (sourceMappingActive) {\n            map.addMapping(activatedMapping);\n        }\n\n        return {\n            css: handlersResult(),\n            map: map\n        };\n    };\n\n    return handlers;\n};\n","var List = require('../common/List');\n\nmodule.exports = function createConvertors(walk) {\n    return {\n        fromPlainObject: function(ast) {\n            walk(ast, {\n                enter: function(node) {\n                    if (node.children && node.children instanceof List === false) {\n                        node.children = new List().fromArray(node.children);\n                    }\n                }\n            });\n\n            return ast;\n        },\n        toPlainObject: function(ast) {\n            walk(ast, {\n                leave: function(node) {\n                    if (node.children && node.children instanceof List) {\n                        node.children = node.children.toArray();\n                    }\n                }\n            });\n\n            return ast;\n        }\n    };\n};\n","var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar noop = function() {};\n\nfunction ensureFunction(value) {\n    return typeof value === 'function' ? value : noop;\n}\n\nfunction invokeForType(fn, type) {\n    return function(node, item, list) {\n        if (node.type === type) {\n            fn.call(this, node, item, list);\n        }\n    };\n}\n\nfunction getWalkersFromStructure(name, nodeType) {\n    var structure = nodeType.structure;\n    var walkers = [];\n\n    for (var key in structure) {\n        if (hasOwnProperty.call(structure, key) === false) {\n            continue;\n        }\n\n        var fieldTypes = structure[key];\n        var walker = {\n            name: key,\n            type: false,\n            nullable: false\n        };\n\n        if (!Array.isArray(structure[key])) {\n            fieldTypes = [structure[key]];\n        }\n\n        for (var i = 0; i < fieldTypes.length; i++) {\n            var fieldType = fieldTypes[i];\n            if (fieldType === null) {\n                walker.nullable = true;\n            } else if (typeof fieldType === 'string') {\n                walker.type = 'node';\n            } else if (Array.isArray(fieldType)) {\n                walker.type = 'list';\n            }\n        }\n\n        if (walker.type) {\n            walkers.push(walker);\n        }\n    }\n\n    if (walkers.length) {\n        return {\n            context: nodeType.walkContext,\n            fields: walkers\n        };\n    }\n\n    return null;\n}\n\nfunction getTypesFromConfig(config) {\n    var types = {};\n\n    for (var name in config.node) {\n        if (hasOwnProperty.call(config.node, name)) {\n            var nodeType = config.node[name];\n\n            if (!nodeType.structure) {\n                throw new Error('Missed `structure` field in `' + name + '` node type definition');\n            }\n\n            types[name] = getWalkersFromStructure(name, nodeType);\n        }\n    }\n\n    return types;\n}\n\nfunction createTypeIterator(config, reverse) {\n    var fields = config.fields.slice();\n    var contextName = config.context;\n    var useContext = typeof contextName === 'string';\n\n    if (reverse) {\n        fields.reverse();\n    }\n\n    return function(node, context, walk) {\n        var prevContextValue;\n\n        if (useContext) {\n            prevContextValue = context[contextName];\n            context[contextName] = node;\n        }\n\n        for (var i = 0; i < fields.length; i++) {\n            var field = fields[i];\n            var ref = node[field.name];\n\n            if (!field.nullable || ref) {\n                if (field.type === 'list') {\n                    if (reverse) {\n                        ref.forEachRight(walk);\n                    } else {\n                        ref.forEach(walk);\n                    }\n                } else {\n                    walk(ref);\n                }\n            }\n        }\n\n        if (useContext) {\n            context[contextName] = prevContextValue;\n        }\n    };\n}\n\nfunction createFastTraveralMap(iterators) {\n    return {\n        Atrule: {\n            StyleSheet: iterators.StyleSheet,\n            Atrule: iterators.Atrule,\n            Rule: iterators.Rule,\n            Block: iterators.Block\n        },\n        Rule: {\n            StyleSheet: iterators.StyleSheet,\n            Atrule: iterators.Atrule,\n            Rule: iterators.Rule,\n            Block: iterators.Block\n        },\n        Declaration: {\n            StyleSheet: iterators.StyleSheet,\n            Atrule: iterators.Atrule,\n            Rule: iterators.Rule,\n            Block: iterators.Block\n        }\n    };\n}\n\nmodule.exports = function createWalker(config) {\n    var types = getTypesFromConfig(config);\n    var iteratorsNatural = {};\n    var iteratorsReverse = {};\n\n    for (var name in types) {\n        if (hasOwnProperty.call(types, name) && types[name] !== null) {\n            iteratorsNatural[name] = createTypeIterator(types[name], false);\n            iteratorsReverse[name] = createTypeIterator(types[name], true);\n        }\n    }\n\n    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);\n    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);\n\n    var walk = function(root, options) {\n        function walkNode(node, item, list) {\n            enter.call(context, node, item, list);\n\n            if (iterators.hasOwnProperty(node.type)) {\n                iterators[node.type](node, context, walkNode);\n            }\n\n            leave.call(context, node, item, list);\n        }\n\n        var enter = noop;\n        var leave = noop;\n        var iterators = iteratorsNatural;\n        var context = {\n            root: root,\n            stylesheet: null,\n            atrule: null,\n            atrulePrelude: null,\n            rule: null,\n            selector: null,\n            block: null,\n            declaration: null,\n            function: null\n        };\n\n        if (typeof options === 'function') {\n            enter = options;\n        } else if (options) {\n            enter = ensureFunction(options.enter);\n            leave = ensureFunction(options.leave);\n\n            if (options.reverse) {\n                iterators = iteratorsReverse;\n            }\n\n            if (options.visit) {\n                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {\n                    iterators = options.reverse\n                        ? fastTraversalIteratorsReverse[options.visit]\n                        : fastTraversalIteratorsNatural[options.visit];\n                } else if (!types.hasOwnProperty(options.visit)) {\n                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');\n                }\n\n                enter = invokeForType(enter, options.visit);\n                leave = invokeForType(leave, options.visit);\n            }\n        }\n\n        if (enter === noop && leave === noop) {\n            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\\'t a function');\n        }\n\n        // swap handlers in reverse mode to invert visit order\n        if (options.reverse) {\n            var tmp = enter;\n            enter = leave;\n            leave = tmp;\n        }\n\n        walkNode(root);\n    };\n\n    walk.find = function(ast, fn) {\n        var found = null;\n\n        walk(ast, function(node, item, list) {\n            if (found === null && fn.call(this, node, item, list)) {\n                found = node;\n            }\n        });\n\n        return found;\n    };\n\n    walk.findLast = function(ast, fn) {\n        var found = null;\n\n        walk(ast, {\n            reverse: true,\n            enter: function(node, item, list) {\n                if (found === null && fn.call(this, node, item, list)) {\n                    found = node;\n                }\n            }\n        });\n\n        return found;\n    };\n\n    walk.findAll = function(ast, fn) {\n        var found = [];\n\n        walk(ast, function(node, item, list) {\n            if (fn.call(this, node, item, list)) {\n                found.push(node);\n            }\n        });\n\n        return found;\n    };\n\n    return walk;\n};\n","var List = require('../common/List');\n\nmodule.exports = function clone(node) {\n    var result = {};\n\n    for (var key in node) {\n        var value = node[key];\n\n        if (value) {\n            if (Array.isArray(value) || value instanceof List) {\n                value = value.map(clone);\n            } else if (value.constructor === Object) {\n                value = clone(value);\n            }\n        }\n\n        result[key] = value;\n    }\n\n    return result;\n};\n","var hasOwnProperty = Object.prototype.hasOwnProperty;\nvar shape = {\n    generic: true,\n    types: {},\n    properties: {},\n    parseContext: {},\n    scope: {},\n    atrule: ['parse'],\n    pseudo: ['parse'],\n    node: ['name', 'structure', 'parse', 'generate', 'walkContext']\n};\n\nfunction isObject(value) {\n    return value && value.constructor === Object;\n}\n\nfunction copy(value) {\n    if (isObject(value)) {\n        var res = {};\n        for (var key in value) {\n            if (hasOwnProperty.call(value, key)) {\n                res[key] = value[key];\n            }\n        }\n        return res;\n    } else {\n        return value;\n    }\n}\n\nfunction extend(dest, src) {\n    for (var key in src) {\n        if (hasOwnProperty.call(src, key)) {\n            if (isObject(dest[key])) {\n                extend(dest[key], copy(src[key]));\n            } else {\n                dest[key] = copy(src[key]);\n            }\n        }\n    }\n}\n\nfunction mix(dest, src, shape) {\n    for (var key in shape) {\n        if (hasOwnProperty.call(shape, key) === false) {\n            continue;\n        }\n\n        if (shape[key] === true) {\n            if (key in src) {\n                if (hasOwnProperty.call(src, key)) {\n                    dest[key] = copy(src[key]);\n                }\n            }\n        } else if (shape[key]) {\n            if (isObject(shape[key])) {\n                var res = {};\n                extend(res, dest[key]);\n                extend(res, src[key]);\n                dest[key] = res;\n            } else if (Array.isArray(shape[key])) {\n                var res = {};\n                var innerShape = shape[key].reduce(function(s, k) {\n                    s[k] = true;\n                    return s;\n                }, {});\n                for (var name in dest[key]) {\n                    if (hasOwnProperty.call(dest[key], name)) {\n                        res[name] = {};\n                        if (dest[key] && dest[key][name]) {\n                            mix(res[name], dest[key][name], innerShape);\n                        }\n                    }\n                }\n                for (var name in src[key]) {\n                    if (hasOwnProperty.call(src[key], name)) {\n                        if (!res[name]) {\n                            res[name] = {};\n                        }\n                        if (src[key] && src[key][name]) {\n                            mix(res[name], src[key][name], innerShape);\n                        }\n                    }\n                }\n                dest[key] = res;\n            }\n        }\n    }\n    return dest;\n}\n\nmodule.exports = function(dest, src) {\n    return mix(dest, src, shape);\n};\n","var data = require('../../../data');\n\nmodule.exports = {\n    generic: true,\n    types: data.types,\n    properties: data.properties,\n    node: require('../node')\n};\n","var mdnProperties = require('mdn-data/css/properties.json');\nvar mdnSyntaxes = require('mdn-data/css/syntaxes.json');\nvar patch = require('./patch.json');\n\nfunction buildDictionary(dict, patchDict) {\n    var result = {};\n\n    // copy all syntaxes for an original dict\n    for (var key in dict) {\n        result[key] = dict[key].syntax;\n    }\n\n    // apply a patch\n    for (var key in patchDict) {\n        if (key in dict) {\n            if (patchDict[key].syntax) {\n                result[key] = patchDict[key].syntax;\n            } else {\n                delete result[key];\n            }\n        } else {\n            if (patchDict[key].syntax) {\n                result[key] = patchDict[key].syntax;\n            }\n        }\n    }\n\n    return result;\n}\n\nmodule.exports = {\n    properties: buildDictionary(mdnProperties, patch.properties),\n    types: buildDictionary(mdnSyntaxes, patch.syntaxes)\n};\n","module.exports = {\n  \"properties\": {\n    \"-moz-background-clip\": {\n      \"comment\": \"deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip\",\n      \"syntax\": \"padding | border\"\n    },\n    \"-moz-border-radius-bottomleft\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius\",\n      \"syntax\": \"<'border-bottom-left-radius'>\"\n    },\n    \"-moz-border-radius-bottomright\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius\",\n      \"syntax\": \"<'border-bottom-right-radius'>\"\n    },\n    \"-moz-border-radius-topleft\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius\",\n      \"syntax\": \"<'border-top-left-radius'>\"\n    },\n    \"-moz-border-radius-topright\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius\",\n      \"syntax\": \"<'border-bottom-right-radius'>\"\n    },\n    \"-moz-osx-font-smoothing\": {\n      \"comment\": \"misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth\",\n      \"syntax\": \"auto | grayscale\"\n    },\n    \"-moz-user-select\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/user-select\",\n      \"syntax\": \"none | text | all | -moz-none\"\n    },\n    \"-ms-flex-align\": {\n      \"comment\": \"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align\",\n      \"syntax\": \"start | end | center | baseline | stretch\"\n    },\n    \"-ms-flex-item-align\": {\n      \"comment\": \"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align\",\n      \"syntax\": \"auto | start | end | center | baseline | stretch\"\n    },\n    \"-ms-flex-line-pack\": {\n      \"comment\": \"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack\",\n      \"syntax\": \"start | end | center | justify | distribute | stretch\"\n    },\n    \"-ms-flex-negative\": {\n      \"comment\": \"misssed old syntax implemented in IE; TODO: find references for comfirmation\",\n      \"syntax\": \"<'flex-shrink'>\"\n    },\n    \"-ms-flex-pack\": {\n      \"comment\": \"misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack\",\n      \"syntax\": \"start | end | center | justify | distribute\"\n    },\n    \"-ms-flex-order\": {\n      \"comment\": \"misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx\",\n      \"syntax\": \"<integer>\"\n    },\n    \"-ms-flex-positive\": {\n      \"comment\": \"misssed old syntax implemented in IE; TODO: find references for comfirmation\",\n      \"syntax\": \"<'flex-grow'>\"\n    },\n    \"-ms-flex-preferred-size\": {\n      \"comment\": \"misssed old syntax implemented in IE; TODO: find references for comfirmation\",\n      \"syntax\": \"<'flex-basis'>\"\n    },\n    \"-ms-interpolation-mode\": {\n      \"comment\": \"https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx\",\n      \"syntax\": \"nearest-neighbor | bicubic\"\n    },\n    \"-ms-grid-column-align\": {\n      \"comment\": \"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx\",\n      \"syntax\": \"start | end | center | stretch\"\n    },\n    \"-ms-grid-row-align\": {\n      \"comment\": \"add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx\",\n      \"syntax\": \"start | end | center | stretch\"\n    },\n    \"-webkit-appearance\": {\n      \"comment\": \"webkit specific keywords\",\n      \"references\": [\n        \"http://css-infos.net/property/-webkit-appearance\"\n      ],\n      \"syntax\": \"none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield\"\n    },\n    \"-webkit-background-clip\": {\n      \"comment\": \"https://developer.mozilla.org/en/docs/Web/CSS/background-clip\",\n      \"syntax\": \"[ <box> | border | padding | content | text ]#\"\n    },\n    \"-webkit-column-break-after\": {\n      \"comment\": \"added, http://help.dottoro.com/lcrthhhv.php\",\n      \"syntax\": \"always | auto | avoid\"\n    },\n    \"-webkit-column-break-before\": {\n      \"comment\": \"added, http://help.dottoro.com/lcxquvkf.php\",\n      \"syntax\": \"always | auto | avoid\"\n    },\n    \"-webkit-column-break-inside\": {\n      \"comment\": \"added, http://help.dottoro.com/lclhnthl.php\",\n      \"syntax\": \"always | auto | avoid\"\n    },\n    \"-webkit-font-smoothing\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth\",\n      \"syntax\": \"auto | none | antialiased | subpixel-antialiased\"\n    },\n    \"-webkit-mask-box-image\": {\n      \"comment\": \"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image\",\n      \"syntax\": \"[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?\"\n    },\n    \"-webkit-print-color-adjust\": {\n      \"comment\": \"missed\",\n      \"references\": [\n        \"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust\"\n      ],\n      \"syntax\": \"economy | exact\"\n    },\n    \"-webkit-text-security\": {\n      \"comment\": \"missed; http://help.dottoro.com/lcbkewgt.php\",\n      \"syntax\": \"none | circle | disc | square\"\n    },\n    \"-webkit-user-drag\": {\n      \"comment\": \"missed; http://help.dottoro.com/lcbixvwm.php\",\n      \"syntax\": \"none | element | auto\"\n    },\n    \"-webkit-user-select\": {\n      \"comment\": \"auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select\",\n      \"syntax\": \"auto | none | text | all\"\n    },\n    \"alignment-baseline\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty\"\n      ],\n      \"syntax\": \"auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical\"\n    },\n    \"baseline-shift\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty\"\n      ],\n      \"syntax\": \"baseline | sub | super | <svg-length>\"\n    },\n    \"behavior\": {\n      \"comment\": \"added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx\",\n      \"syntax\": \"<url>+\"\n    },\n    \"clip-rule\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty\"\n      ],\n      \"syntax\": \"nonzero | evenodd\"\n    },\n    \"cue\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<'cue-before'> <'cue-after'>?\"\n    },\n    \"cue-after\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<url> <decibel>? | none\"\n    },\n    \"cue-before\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<url> <decibel>? | none\"\n    },\n    \"cursor\": {\n      \"comment\": \"added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out\",\n      \"references\": [\n        \"https://www.sitepoint.com/css3-cursor-styles/\"\n      ],\n      \"syntax\": \"[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]\"\n    },\n    \"display\": {\n      \"comment\": \"extended with -ms-flexbox\",\n      \"syntax\": \"none | inline | block | list-item | inline-list-item | inline-block | inline-table | table | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | flex | inline-flex | grid | inline-grid | run-in | ruby | ruby-base | ruby-text | ruby-base-container | ruby-text-container | contents | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box\"\n    },\n    \"position\": {\n      \"comment\": \"extended with -webkit-sticky\",\n      \"syntax\": \"static | relative | absolute | sticky | fixed | -webkit-sticky\"\n    },\n    \"dominant-baseline\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty\"\n      ],\n      \"syntax\": \"auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge\"\n    },\n    \"image-rendering\": {\n      \"comment\": \"extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality\",\n      \"references\": [\n        \"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering\",\n        \"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty\"\n      ],\n      \"syntax\": \"auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>\"\n    },\n    \"fill\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#FillProperty\"\n      ],\n      \"syntax\": \"<paint>\"\n    },\n    \"fill-opacity\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#FillProperty\"\n      ],\n      \"syntax\": \"<number-zero-one>\"\n    },\n    \"fill-rule\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#FillProperty\"\n      ],\n      \"syntax\": \"nonzero | evenodd\"\n    },\n    \"filter\": {\n      \"comment\": \"extend with IE legacy syntaxes\",\n      \"syntax\": \"none | <filter-function-list> | <-ms-filter-function-list>\"\n    },\n    \"glyph-orientation-horizontal\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty\"\n      ],\n      \"syntax\": \"<angle>\"\n    },\n    \"glyph-orientation-vertical\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty\"\n      ],\n      \"syntax\": \"<angle>\"\n    },\n    \"kerning\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/text.html#KerningProperty\"\n      ],\n      \"syntax\": \"auto | <svg-length>\"\n    },\n    \"letter-spacing\": {\n      \"comment\": \"fix syntax <length> -> <length-percentage>\",\n      \"references\": [\n        \"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing\"\n      ],\n      \"syntax\": \"normal | <length-percentage>\"\n    },\n    \"marker\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"\n      ],\n      \"syntax\": \"none | <url>\"\n    },\n    \"marker-end\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"\n      ],\n      \"syntax\": \"none | <url>\"\n    },\n    \"marker-mid\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"\n      ],\n      \"syntax\": \"none | <url>\"\n    },\n    \"marker-start\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#MarkerProperties\"\n      ],\n      \"syntax\": \"none | <url>\"\n    },\n    \"max-width\": {\n      \"comment\": \"extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width\",\n      \"syntax\": \"<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>\"\n    },\n    \"min-width\": {\n      \"comment\": \"extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width\",\n      \"syntax\": \"<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>\"\n    },\n    \"opacity\": {\n      \"comment\": \"strict to 0..1 <number> -> <number-zero-one>\",\n      \"syntax\": \"<number-zero-one>\"\n    },\n    \"overflow\": {\n      \"comment\": \"extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow\",\n      \"syntax\": \"[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>\"\n    },\n    \"pause\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<'pause-before'> <'pause-after'>?\"\n    },\n    \"pause-after\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<time> | none | x-weak | weak | medium | strong | x-strong\"\n    },\n    \"pause-before\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<time> | none | x-weak | weak | medium | strong | x-strong\"\n    },\n    \"rest\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<'rest-before'> <'rest-after'>?\"\n    },\n    \"rest-after\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<time> | none | x-weak | weak | medium | strong | x-strong\"\n    },\n    \"rest-before\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<time> | none | x-weak | weak | medium | strong | x-strong\"\n    },\n    \"shape-rendering\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert\"\n      ],\n      \"syntax\": \"auto | optimizeSpeed | crispEdges | geometricPrecision\"\n    },\n    \"src\": {\n      \"comment\": \"added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src\",\n      \"syntax\": \"[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#\"\n    },\n    \"speak\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"auto | none | normal\"\n    },\n    \"speak-as\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"normal | spell-out || digits || [ literal-punctuation | no-punctuation ]\"\n    },\n    \"stroke\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"\n      ],\n      \"syntax\": \"<paint>\"\n    },\n    \"stroke-dasharray\": {\n      \"comment\": \"added SVG property; a list of comma and/or white space separated <length>s and <percentage>s\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"\n      ],\n      \"syntax\": \"none | [ <svg-length>+ ]#\"\n    },\n    \"stroke-dashoffset\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"\n      ],\n      \"syntax\": \"<svg-length>\"\n    },\n    \"stroke-linecap\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"\n      ],\n      \"syntax\": \"butt | round | square\"\n    },\n    \"stroke-linejoin\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"\n      ],\n      \"syntax\": \"miter | round | bevel\"\n    },\n    \"stroke-miterlimit\": {\n      \"comment\": \"added SVG property (<miterlimit> = <number-one-or-greater>) \",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"\n      ],\n      \"syntax\": \"<number-one-or-greater>\"\n    },\n    \"stroke-opacity\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"\n      ],\n      \"syntax\": \"<number-zero-one>\"\n    },\n    \"stroke-width\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/painting.html#StrokeProperties\"\n      ],\n      \"syntax\": \"<svg-length>\"\n    },\n    \"text-anchor\": {\n      \"comment\": \"added SVG property\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties\"\n      ],\n      \"syntax\": \"start | middle | end\"\n    },\n    \"unicode-bidi\": {\n      \"comment\": \"added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi\",\n      \"syntax\": \"normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate\"\n    },\n    \"unicode-range\": {\n      \"comment\": \"added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range\",\n      \"syntax\": \"<urange>#\"\n    },\n    \"voice-balance\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<number> | left | center | right | leftwards | rightwards\"\n    },\n    \"voice-duration\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"auto | <time>\"\n    },\n    \"voice-family\": {\n      \"comment\": \"<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve\"\n    },\n    \"voice-pitch\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]\"\n    },\n    \"voice-range\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]\"\n    },\n    \"voice-rate\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>\"\n    },\n    \"voice-stress\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"normal | strong | moderate | none | reduced\"\n    },\n    \"voice-volume\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#property-index\",\n      \"syntax\": \"silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]\"\n    },\n    \"writing-mode\": {\n      \"comment\": \"extend with SVG keywords\",\n      \"syntax\": \"horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>\"\n    }\n  },\n  \"syntaxes\": {\n    \"-legacy-gradient\": {\n      \"comment\": \"added collection of legacy gradient syntaxes\",\n      \"syntax\": \"<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>\"\n    },\n    \"-legacy-linear-gradient\": {\n      \"comment\": \"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\",\n      \"syntax\": \"-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )\"\n    },\n    \"-legacy-repeating-linear-gradient\": {\n      \"comment\": \"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\",\n      \"syntax\": \"-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )\"\n    },\n    \"-legacy-linear-gradient-arguments\": {\n      \"comment\": \"like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient\",\n      \"syntax\": \"[ <angle> | <side-or-corner> ]? , <color-stop-list>\"\n    },\n    \"-legacy-radial-gradient\": {\n      \"comment\": \"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients\",\n      \"syntax\": \"-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )\"\n    },\n    \"-legacy-repeating-radial-gradient\": {\n      \"comment\": \"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients\",\n      \"syntax\": \"-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )\"\n    },\n    \"-legacy-radial-gradient-arguments\": {\n      \"comment\": \"deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients\",\n      \"syntax\": \"[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>\"\n    },\n    \"-legacy-radial-gradient-size\": {\n      \"comment\": \"before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize\",\n      \"syntax\": \"closest-side | closest-corner | farthest-side | farthest-corner | contain | cover\"\n    },\n    \"-legacy-radial-gradient-shape\": {\n      \"comment\": \"define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape\",\n      \"syntax\": \"circle | ellipse\"\n    },\n    \"-non-standard-font\": {\n      \"comment\": \"non standard fonts\",\n      \"references\": [\n        \"https://webkit.org/blog/3709/using-the-system-font-in-web-content/\"\n      ],\n      \"syntax\": \"-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body\"\n    },\n    \"-non-standard-color\": {\n      \"comment\": \"non standard colors\",\n      \"references\": [\n        \"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html\",\n        \"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions\"\n      ],\n      \"syntax\": \"-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text\"\n    },\n    \"-non-standard-image-rendering\": {\n      \"comment\": \"non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html\",\n      \"syntax\": \"optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast\"\n    },\n    \"-non-standard-overflow\": {\n      \"comment\": \"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow\",\n      \"syntax\": \"-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable\"\n    },\n    \"-non-standard-width\": {\n      \"comment\": \"non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width\",\n      \"syntax\": \"min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content\"\n    },\n    \"-webkit-gradient()\": {\n      \"comment\": \"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )\",\n      \"syntax\": \"-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )\"\n    },\n    \"-webkit-gradient-color-stop\": {\n      \"comment\": \"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\n      \"syntax\": \"from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )\"\n    },\n    \"-webkit-gradient-point\": {\n      \"comment\": \"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\n      \"syntax\": \"[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]\"\n    },\n    \"-webkit-gradient-radius\": {\n      \"comment\": \"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\n      \"syntax\": \"<length> | <percentage>\"\n    },\n    \"-webkit-gradient-type\": {\n      \"comment\": \"first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/\",\n      \"syntax\": \"linear | radial\"\n    },\n    \"-webkit-mask-box-repeat\": {\n      \"comment\": \"missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image\",\n      \"syntax\": \"repeat | stretch | round\"\n    },\n    \"-webkit-mask-clip-style\": {\n      \"comment\": \"missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working\",\n      \"syntax\": \"border | border-box | padding | padding-box | content | content-box | text\"\n    },\n    \"-ms-filter-function-list\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\n      \"syntax\": \"<-ms-filter-function>+\"\n    },\n    \"-ms-filter-function\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\n      \"syntax\": \"<-ms-filter-function-progid> | <-ms-filter-function-legacy>\"\n    },\n    \"-ms-filter-function-progid\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\n      \"syntax\": \"'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]\"\n    },\n    \"-ms-filter-function-legacy\": {\n      \"comment\": \"https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter\",\n      \"syntax\": \"<ident-token> | <function-token> <any-value>? )\"\n    },\n    \"-ms-filter\": {\n      \"syntax\": \"<string>\"\n    },\n    \"age\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#voice-family\",\n      \"syntax\": \"child | young | old\"\n    },\n    \"attr-name\": {\n      \"syntax\": \"<wq-name>\"\n    },\n    \"attr-fallback\": {\n      \"syntax\": \"<any-value>\"\n    },\n    \"border-radius\": {\n      \"comment\": \"missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius\",\n      \"syntax\": \"<length-percentage>{1,2}\"\n    },\n    \"bottom\": {\n      \"comment\": \"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\n      \"syntax\": \"<length> | auto\"\n    },\n    \"content-list\": {\n      \"comment\": \"missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)\",\n      \"syntax\": \"[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+\"\n    },\n    \"generic-voice\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#voice-family\",\n      \"syntax\": \"[ <age>? <gender> <integer>? ]\"\n    },\n    \"gender\": {\n      \"comment\": \"https://www.w3.org/TR/css3-speech/#voice-family\",\n      \"syntax\": \"male | female | neutral\"\n    },\n    \"generic-family\": {\n      \"comment\": \"added -apple-system\",\n      \"references\": [\n        \"https://webkit.org/blog/3709/using-the-system-font-in-web-content/\"\n      ],\n      \"syntax\": \"serif | sans-serif | cursive | fantasy | monospace | -apple-system\"\n    },\n    \"gradient\": {\n      \"comment\": \"added legacy syntaxes support\",\n      \"syntax\": \"<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>\"\n    },\n    \"left\": {\n      \"comment\": \"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\n      \"syntax\": \"<length> | auto\"\n    },\n    \"mask-image\": {\n      \"comment\": \"missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image\",\n      \"syntax\": \"<mask-reference>#\"\n    },\n    \"name-repeat\": {\n      \"comment\": \"missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat\",\n      \"syntax\": \"repeat( [ <positive-integer> | auto-fill ], <line-names>+)\"\n    },\n    \"named-color\": {\n      \"comment\": \"added non standard color names\",\n      \"syntax\": \"transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>\"\n    },\n    \"paint\": {\n      \"comment\": \"used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint\",\n      \"syntax\": \"none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke\"\n    },\n    \"path()\": {\n      \"comment\": \"missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path\",\n      \"syntax\": \"path( <string> )\"\n    },\n    \"ratio\": {\n      \"comment\": \"missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio\",\n      \"syntax\": \"<integer> / <integer>\"\n    },\n    \"right\": {\n      \"comment\": \"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\n      \"syntax\": \"<length> | auto\"\n    },\n    \"shape\": {\n      \"comment\": \"missed spaces in function body and add backwards compatible syntax\",\n      \"syntax\": \"rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )\"\n    },\n    \"svg-length\": {\n      \"comment\": \"All coordinates and lengths in SVG can be specified with or without a unit identifier\",\n      \"references\": [\n        \"https://www.w3.org/TR/SVG11/coords.html#Units\"\n      ],\n      \"syntax\": \"<percentage> | <length> | <number>\"\n    },\n    \"svg-writing-mode\": {\n      \"comment\": \"SVG specific keywords (deprecated for CSS)\",\n      \"references\": [\n        \"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode\",\n        \"https://www.w3.org/TR/SVG/text.html#WritingModeProperty\"\n      ],\n      \"syntax\": \"lr-tb | rl-tb | tb-rl | lr | rl | tb\"\n    },\n    \"top\": {\n      \"comment\": \"missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect\",\n      \"syntax\": \"<length> | auto\"\n    },\n    \"x\": {\n      \"comment\": \"missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor\",\n      \"syntax\": \"<number>\"\n    },\n    \"y\": {\n      \"comment\": \"missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor\",\n      \"syntax\": \"<number>\"\n    },\n    \"declaration\": {\n      \"comment\": \"missed, restored by https://drafts.csswg.org/css-syntax\",\n      \"syntax\": \"<ident-token> : <declaration-value>? [ '!' important ]?\"\n    },\n    \"declaration-list\": {\n      \"comment\": \"missed, restored by https://drafts.csswg.org/css-syntax\",\n      \"syntax\": \"[ <declaration>? ';' ]* <declaration>?\"\n    },\n    \"url\": {\n      \"comment\": \"https://drafts.csswg.org/css-values-4/#urls\",\n      \"syntax\": \"url( <string> <url-modifier>* ) | <url-token>\"\n    },\n    \"url-modifier\": {\n      \"comment\": \"https://drafts.csswg.org/css-values-4/#typedef-url-modifier\",\n      \"syntax\": \"<ident> | <function-token> <any-value> )\"\n    },\n    \"number-zero-one\": {\n      \"syntax\": \"<number [0,1]>\"\n    },\n    \"number-one-or-greater\": {\n      \"syntax\": \"<number [1,∞]>\"\n    },\n    \"positive-integer\": {\n      \"syntax\": \"<integer [0,∞]>\"\n    }\n  }\n}\n","module.exports = {\n    AnPlusB: require('./AnPlusB'),\n    Atrule: require('./Atrule'),\n    AtrulePrelude: require('./AtrulePrelude'),\n    AttributeSelector: require('./AttributeSelector'),\n    Block: require('./Block'),\n    Brackets: require('./Brackets'),\n    CDC: require('./CDC'),\n    CDO: require('./CDO'),\n    ClassSelector: require('./ClassSelector'),\n    Combinator: require('./Combinator'),\n    Comment: require('./Comment'),\n    Declaration: require('./Declaration'),\n    DeclarationList: require('./DeclarationList'),\n    Dimension: require('./Dimension'),\n    Function: require('./Function'),\n    HexColor: require('./HexColor'),\n    Identifier: require('./Identifier'),\n    IdSelector: require('./IdSelector'),\n    MediaFeature: require('./MediaFeature'),\n    MediaQuery: require('./MediaQuery'),\n    MediaQueryList: require('./MediaQueryList'),\n    Nth: require('./Nth'),\n    Number: require('./Number'),\n    Operator: require('./Operator'),\n    Parentheses: require('./Parentheses'),\n    Percentage: require('./Percentage'),\n    PseudoClassSelector: require('./PseudoClassSelector'),\n    PseudoElementSelector: require('./PseudoElementSelector'),\n    Ratio: require('./Ratio'),\n    Raw: require('./Raw'),\n    Rule: require('./Rule'),\n    Selector: require('./Selector'),\n    SelectorList: require('./SelectorList'),\n    String: require('./String'),\n    StyleSheet: require('./StyleSheet'),\n    TypeSelector: require('./TypeSelector'),\n    UnicodeRange: require('./UnicodeRange'),\n    Url: require('./Url'),\n    Value: require('./Value'),\n    WhiteSpace: require('./WhiteSpace')\n};\n","var cmpChar = require('../../tokenizer').cmpChar;\nvar isDigit = require('../../tokenizer').isDigit;\nvar TYPE = require('../../tokenizer').TYPE;\n\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar NUMBER = TYPE.Number;\nvar DIMENSION = TYPE.Dimension;\nvar PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nvar HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nvar N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)\nvar DISALLOW_SIGN = true;\nvar ALLOW_SIGN = false;\n\nfunction checkInteger(offset, disallowSign) {\n    var pos = this.scanner.tokenStart + offset;\n    var code = this.scanner.source.charCodeAt(pos);\n\n    if (code === PLUSSIGN || code === HYPHENMINUS) {\n        if (disallowSign) {\n            this.error('Number sign is not allowed');\n        }\n        pos++;\n    }\n\n    for (; pos < this.scanner.tokenEnd; pos++) {\n        if (!isDigit(this.scanner.source.charCodeAt(pos))) {\n            this.error('Integer is expected', pos);\n        }\n    }\n}\n\nfunction checkTokenIsInteger(disallowSign) {\n    return checkInteger.call(this, 0, disallowSign);\n}\n\nfunction expectCharCode(offset, code) {\n    if (!cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)) {\n        var msg = '';\n\n        switch (code) {\n            case N:\n                msg = 'N is expected';\n                break;\n            case HYPHENMINUS:\n                msg = 'HyphenMinus is expected';\n                break;\n        }\n\n        this.error(msg, this.scanner.tokenStart + offset);\n    }\n}\n\n// ... <signed-integer>\n// ... ['+' | '-'] <signless-integer>\nfunction consumeB() {\n    var offset = 0;\n    var sign = 0;\n    var type = this.scanner.tokenType;\n\n    while (type === WHITESPACE || type === COMMENT) {\n        type = this.scanner.lookupType(++offset);\n    }\n\n    if (type !== NUMBER) {\n        if (this.scanner.isDelim(PLUSSIGN, offset) ||\n            this.scanner.isDelim(HYPHENMINUS, offset)) {\n            sign = this.scanner.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;\n\n            do {\n                type = this.scanner.lookupType(++offset);\n            } while (type === WHITESPACE || type === COMMENT);\n\n            if (type !== NUMBER) {\n                this.scanner.skip(offset);\n                checkTokenIsInteger.call(this, DISALLOW_SIGN);\n            }\n        } else {\n            return null;\n        }\n    }\n\n    if (offset > 0) {\n        this.scanner.skip(offset);\n    }\n\n    if (sign === 0) {\n        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n        if (type !== PLUSSIGN && type !== HYPHENMINUS) {\n            this.error('Number sign is expected');\n        }\n    }\n\n    checkTokenIsInteger.call(this, sign !== 0);\n    return sign === HYPHENMINUS ? '-' + this.consume(NUMBER) : this.consume(NUMBER);\n}\n\n// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb\nmodule.exports = {\n    name: 'AnPlusB',\n    structure: {\n        a: [String, null],\n        b: [String, null]\n    },\n    parse: function() {\n        /* eslint-disable brace-style*/\n        var start = this.scanner.tokenStart;\n        var a = null;\n        var b = null;\n\n        // <integer>\n        if (this.scanner.tokenType === NUMBER) {\n            checkTokenIsInteger.call(this, ALLOW_SIGN);\n            b = this.consume(NUMBER);\n        }\n\n        // -n\n        // -n <signed-integer>\n        // -n ['+' | '-'] <signless-integer>\n        // -n- <signless-integer>\n        // <dashndashdigit-ident>\n        else if (this.scanner.tokenType === IDENT && cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)) {\n            a = '-1';\n\n            expectCharCode.call(this, 1, N);\n\n            switch (this.scanner.getTokenLength()) {\n                // -n\n                // -n <signed-integer>\n                // -n ['+' | '-'] <signless-integer>\n                case 2:\n                    this.scanner.next();\n                    b = consumeB.call(this);\n                    break;\n\n                // -n- <signless-integer>\n                case 3:\n                    expectCharCode.call(this, 2, HYPHENMINUS);\n\n                    this.scanner.next();\n                    this.scanner.skipSC();\n\n                    checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                    b = '-' + this.consume(NUMBER);\n                    break;\n\n                // <dashndashdigit-ident>\n                default:\n                    expectCharCode.call(this, 2, HYPHENMINUS);\n                    checkInteger.call(this, 3, DISALLOW_SIGN);\n                    this.scanner.next();\n\n                    b = this.scanner.substrToCursor(start + 2);\n            }\n        }\n\n        // '+'? n\n        // '+'? n <signed-integer>\n        // '+'? n ['+' | '-'] <signless-integer>\n        // '+'? n- <signless-integer>\n        // '+'? <ndashdigit-ident>\n        else if (this.scanner.tokenType === IDENT || (this.scanner.isDelim(PLUSSIGN) && this.scanner.lookupType(1) === IDENT)) {\n            var sign = 0;\n            a = '1';\n\n            // just ignore a plus\n            if (this.scanner.isDelim(PLUSSIGN)) {\n                sign = 1;\n                this.scanner.next();\n            }\n\n            expectCharCode.call(this, 0, N);\n\n            switch (this.scanner.getTokenLength()) {\n                // '+'? n\n                // '+'? n <signed-integer>\n                // '+'? n ['+' | '-'] <signless-integer>\n                case 1:\n                    this.scanner.next();\n                    b = consumeB.call(this);\n                    break;\n\n                // '+'? n- <signless-integer>\n                case 2:\n                    expectCharCode.call(this, 1, HYPHENMINUS);\n\n                    this.scanner.next();\n                    this.scanner.skipSC();\n\n                    checkTokenIsInteger.call(this, DISALLOW_SIGN);\n\n                    b = '-' + this.consume(NUMBER);\n                    break;\n\n                // '+'? <ndashdigit-ident>\n                default:\n                    expectCharCode.call(this, 1, HYPHENMINUS);\n                    checkInteger.call(this, 2, DISALLOW_SIGN);\n                    this.scanner.next();\n\n                    b = this.scanner.substrToCursor(start + sign + 1);\n            }\n        }\n\n        // <ndashdigit-dimension>\n        // <ndash-dimension> <signless-integer>\n        // <n-dimension>\n        // <n-dimension> <signed-integer>\n        // <n-dimension> ['+' | '-'] <signless-integer>\n        else if (this.scanner.tokenType === DIMENSION) {\n            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n            var sign = code === PLUSSIGN || code === HYPHENMINUS;\n\n            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {\n                if (!isDigit(this.scanner.source.charCodeAt(i))) {\n                    break;\n                }\n            }\n\n            if (i === this.scanner.tokenStart + sign) {\n                this.error('Integer is expected', this.scanner.tokenStart + sign);\n            }\n\n            expectCharCode.call(this, i - this.scanner.tokenStart, N);\n            a = this.scanner.source.substring(start, i);\n\n            // <n-dimension>\n            // <n-dimension> <signed-integer>\n            // <n-dimension> ['+' | '-'] <signless-integer>\n            if (i + 1 === this.scanner.tokenEnd) {\n                this.scanner.next();\n                b = consumeB.call(this);\n            } else {\n                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS);\n\n                // <ndash-dimension> <signless-integer>\n                if (i + 2 === this.scanner.tokenEnd) {\n                    this.scanner.next();\n                    this.scanner.skipSC();\n                    checkTokenIsInteger.call(this, DISALLOW_SIGN);\n                    b = '-' + this.consume(NUMBER);\n                }\n                // <ndashdigit-dimension>\n                else {\n                    checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);\n                    this.scanner.next();\n                    b = this.scanner.substrToCursor(i + 1);\n                }\n            }\n        } else {\n            this.error();\n        }\n\n        if (a !== null && a.charCodeAt(0) === PLUSSIGN) {\n            a = a.substr(1);\n        }\n\n        if (b !== null && b.charCodeAt(0) === PLUSSIGN) {\n            b = b.substr(1);\n        }\n\n        return {\n            type: 'AnPlusB',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            a: a,\n            b: b\n        };\n    },\n    generate: function(node) {\n        var a = node.a !== null && node.a !== undefined;\n        var b = node.b !== null && node.b !== undefined;\n\n        if (a) {\n            this.chunk(\n                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent\n                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent\n                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent\n                node.a + 'n'             // eslint-disable-line operator-linebreak, indent\n            );\n\n            if (b) {\n                b = String(node.b);\n                if (b.charAt(0) === '-' || b.charAt(0) === '+') {\n                    this.chunk(b.charAt(0));\n                    this.chunk(b.substr(1));\n                } else {\n                    this.chunk('+');\n                    this.chunk(b);\n                }\n            }\n        } else {\n            this.chunk(String(node.b));\n        }\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\nvar rawMode = require('./Raw').mode;\n\nvar ATKEYWORD = TYPE.AtKeyword;\nvar SEMICOLON = TYPE.Semicolon;\nvar LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;\nvar RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);\n}\n\nfunction isDeclarationBlockAtrule() {\n    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {\n        if (type === RIGHTCURLYBRACKET) {\n            return true;\n        }\n\n        if (type === LEFTCURLYBRACKET ||\n            type === ATKEYWORD) {\n            return false;\n        }\n    }\n\n    return false;\n}\n\nmodule.exports = {\n    name: 'Atrule',\n    structure: {\n        name: String,\n        prelude: ['AtrulePrelude', 'Raw', null],\n        block: ['Block', null]\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var name;\n        var nameLowerCase;\n        var prelude = null;\n        var block = null;\n\n        this.eat(ATKEYWORD);\n\n        name = this.scanner.substrToCursor(start + 1);\n        nameLowerCase = name.toLowerCase();\n        this.scanner.skipSC();\n\n        // parse prelude\n        if (this.scanner.eof === false &&\n            this.scanner.tokenType !== LEFTCURLYBRACKET &&\n            this.scanner.tokenType !== SEMICOLON) {\n            if (this.parseAtrulePrelude) {\n                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);\n\n                // turn empty AtrulePrelude into null\n                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {\n                    prelude = null;\n                }\n            } else {\n                prelude = consumeRaw.call(this, this.scanner.tokenIndex);\n            }\n\n            this.scanner.skipSC();\n        }\n\n        switch (this.scanner.tokenType) {\n            case SEMICOLON:\n                this.scanner.next();\n                break;\n\n            case LEFTCURLYBRACKET:\n                if (this.atrule.hasOwnProperty(nameLowerCase) &&\n                    typeof this.atrule[nameLowerCase].block === 'function') {\n                    block = this.atrule[nameLowerCase].block.call(this);\n                } else {\n                    // TODO: should consume block content as Raw?\n                    block = this.Block(isDeclarationBlockAtrule.call(this));\n                }\n\n                break;\n        }\n\n        return {\n            type: 'Atrule',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: name,\n            prelude: prelude,\n            block: block\n        };\n    },\n    generate: function(node) {\n        this.chunk('@');\n        this.chunk(node.name);\n\n        if (node.prelude !== null) {\n            this.chunk(' ');\n            this.node(node.prelude);\n        }\n\n        if (node.block) {\n            this.node(node.block);\n        } else {\n            this.chunk(';');\n        }\n    },\n    walkContext: 'atrule'\n};\n","var tokenizer = require('../../tokenizer');\nvar TYPE = tokenizer.TYPE;\n\nvar WhiteSpace = TYPE.WhiteSpace;\nvar Semicolon = TYPE.Semicolon;\nvar LeftCurlyBracket = TYPE.LeftCurlyBracket;\nvar Delim = TYPE.Delim;\nvar EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\nfunction getOffsetExcludeWS() {\n    if (this.scanner.tokenIndex > 0) {\n        if (this.scanner.lookupType(-1) === WhiteSpace) {\n            return this.scanner.tokenIndex > 1\n                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)\n                : this.scanner.firstCharOffset;\n        }\n    }\n\n    return this.scanner.tokenStart;\n}\n\n// 0, 0, false\nfunction balanceEnd() {\n    return 0;\n}\n\n// LEFTCURLYBRACKET, 0, false\nfunction leftCurlyBracket(tokenType) {\n    return tokenType === LeftCurlyBracket ? 1 : 0;\n}\n\n// LEFTCURLYBRACKET, SEMICOLON, false\nfunction leftCurlyBracketOrSemicolon(tokenType) {\n    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;\n}\n\n// EXCLAMATIONMARK, SEMICOLON, false\nfunction exclamationMarkOrSemicolon(tokenType, source, offset) {\n    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {\n        return 1;\n    }\n\n    return tokenType === Semicolon ? 1 : 0;\n}\n\n// 0, SEMICOLON, true\nfunction semicolonIncluded(tokenType) {\n    return tokenType === Semicolon ? 2 : 0;\n}\n\nmodule.exports = {\n    name: 'Raw',\n    structure: {\n        value: String\n    },\n    parse: function(startToken, mode, excludeWhiteSpace) {\n        var startOffset = this.scanner.getTokenStart(startToken);\n        var endOffset;\n\n        this.scanner.skip(\n            this.scanner.getRawLength(startToken, mode || balanceEnd)\n        );\n\n        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {\n            endOffset = getOffsetExcludeWS.call(this);\n        } else {\n            endOffset = this.scanner.tokenStart;\n        }\n\n        return {\n            type: 'Raw',\n            loc: this.getLocation(startOffset, endOffset),\n            value: this.scanner.source.substring(startOffset, endOffset)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.value);\n    },\n\n    mode: {\n        default: balanceEnd,\n        leftCurlyBracket: leftCurlyBracket,\n        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,\n        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,\n        semicolonIncluded: semicolonIncluded\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar SEMICOLON = TYPE.Semicolon;\nvar LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;\n\nmodule.exports = {\n    name: 'AtrulePrelude',\n    structure: {\n        children: [[]]\n    },\n    parse: function(name) {\n        var children = null;\n\n        if (name !== null) {\n            name = name.toLowerCase();\n        }\n\n        this.scanner.skipSC();\n\n        if (this.atrule.hasOwnProperty(name) &&\n            typeof this.atrule[name].prelude === 'function') {\n            // custom consumer\n            children = this.atrule[name].prelude.call(this);\n        } else {\n            // default consumer\n            children = this.readSequence(this.scope.AtrulePrelude);\n        }\n\n        this.scanner.skipSC();\n\n        if (this.scanner.eof !== true &&\n            this.scanner.tokenType !== LEFTCURLYBRACKET &&\n            this.scanner.tokenType !== SEMICOLON) {\n            this.error('Semicolon or block is expected');\n        }\n\n        if (children === null) {\n            children = this.createList();\n        }\n\n        return {\n            type: 'AtrulePrelude',\n            loc: this.getLocationFromList(children),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.children(node);\n    },\n    walkContext: 'atrulePrelude'\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\nvar STRING = TYPE.String;\nvar COLON = TYPE.Colon;\nvar LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;\nvar RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;\nvar DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)\nvar ASTERISK = 0x002A;         // U+002A ASTERISK (*)\nvar EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)\nvar CIRCUMFLEXACCENT = 0x005E; // U+005E (^)\nvar VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)\nvar TILDE = 0x007E;            // U+007E TILDE (~)\n\nfunction getAttributeName() {\n    if (this.scanner.eof) {\n        this.error('Unexpected end of input');\n    }\n\n    var start = this.scanner.tokenStart;\n    var expectIdent = false;\n    var checkColon = true;\n\n    if (this.scanner.isDelim(ASTERISK)) {\n        expectIdent = true;\n        checkColon = false;\n        this.scanner.next();\n    } else if (!this.scanner.isDelim(VERTICALLINE)) {\n        this.eat(IDENT);\n    }\n\n    if (this.scanner.isDelim(VERTICALLINE)) {\n        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {\n            this.scanner.next();\n            this.eat(IDENT);\n        } else if (expectIdent) {\n            this.error('Identifier is expected', this.scanner.tokenEnd);\n        }\n    } else if (expectIdent) {\n        this.error('Vertical line is expected');\n    }\n\n    if (checkColon && this.scanner.tokenType === COLON) {\n        this.scanner.next();\n        this.eat(IDENT);\n    }\n\n    return {\n        type: 'Identifier',\n        loc: this.getLocation(start, this.scanner.tokenStart),\n        name: this.scanner.substrToCursor(start)\n    };\n}\n\nfunction getOperator() {\n    var start = this.scanner.tokenStart;\n    var code = this.scanner.source.charCodeAt(start);\n\n    if (code !== EQUALSSIGN &&        // =\n        code !== TILDE &&             // ~=\n        code !== CIRCUMFLEXACCENT &&  // ^=\n        code !== DOLLARSIGN &&        // $=\n        code !== ASTERISK &&          // *=\n        code !== VERTICALLINE         // |=\n    ) {\n        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');\n    }\n\n    this.scanner.next();\n\n    if (code !== EQUALSSIGN) {\n        if (!this.scanner.isDelim(EQUALSSIGN)) {\n            this.error('Equal sign is expected');\n        }\n\n        this.scanner.next();\n    }\n\n    return this.scanner.substrToCursor(start);\n}\n\n// '[' <wq-name> ']'\n// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'\nmodule.exports = {\n    name: 'AttributeSelector',\n    structure: {\n        name: 'Identifier',\n        matcher: [String, null],\n        value: ['String', 'Identifier', null],\n        flags: [String, null]\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var name;\n        var matcher = null;\n        var value = null;\n        var flags = null;\n\n        this.eat(LEFTSQUAREBRACKET);\n        this.scanner.skipSC();\n\n        name = getAttributeName.call(this);\n        this.scanner.skipSC();\n\n        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {\n            // avoid case `[name i]`\n            if (this.scanner.tokenType !== IDENT) {\n                matcher = getOperator.call(this);\n\n                this.scanner.skipSC();\n\n                value = this.scanner.tokenType === STRING\n                    ? this.String()\n                    : this.Identifier();\n\n                this.scanner.skipSC();\n            }\n\n            // attribute flags\n            if (this.scanner.tokenType === IDENT) {\n                flags = this.scanner.getTokenValue();\n                this.scanner.next();\n\n                this.scanner.skipSC();\n            }\n        }\n\n        this.eat(RIGHTSQUAREBRACKET);\n\n        return {\n            type: 'AttributeSelector',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: name,\n            matcher: matcher,\n            value: value,\n            flags: flags\n        };\n    },\n    generate: function(node) {\n        var flagsPrefix = ' ';\n\n        this.chunk('[');\n        this.node(node.name);\n\n        if (node.matcher !== null) {\n            this.chunk(node.matcher);\n\n            if (node.value !== null) {\n                this.node(node.value);\n\n                // space between string and flags is not required\n                if (node.value.type === 'String') {\n                    flagsPrefix = '';\n                }\n            }\n        }\n\n        if (node.flags !== null) {\n            this.chunk(flagsPrefix);\n            this.chunk(node.flags);\n        }\n\n        this.chunk(']');\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\nvar rawMode = require('./Raw').mode;\n\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar SEMICOLON = TYPE.Semicolon;\nvar ATKEYWORD = TYPE.AtKeyword;\nvar LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;\nvar RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, null, true);\n}\nfunction consumeRule() {\n    return this.parseWithFallback(this.Rule, consumeRaw);\n}\nfunction consumeRawDeclaration(startToken) {\n    return this.Raw(startToken, rawMode.semicolonIncluded, true);\n}\nfunction consumeDeclaration() {\n    if (this.scanner.tokenType === SEMICOLON) {\n        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);\n    }\n\n    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);\n\n    if (this.scanner.tokenType === SEMICOLON) {\n        this.scanner.next();\n    }\n\n    return node;\n}\n\nmodule.exports = {\n    name: 'Block',\n    structure: {\n        children: [[\n            'Atrule',\n            'Rule',\n            'Declaration'\n        ]]\n    },\n    parse: function(isDeclaration) {\n        var consumer = isDeclaration ? consumeDeclaration : consumeRule;\n\n        var start = this.scanner.tokenStart;\n        var children = this.createList();\n\n        this.eat(LEFTCURLYBRACKET);\n\n        scan:\n        while (!this.scanner.eof) {\n            switch (this.scanner.tokenType) {\n                case RIGHTCURLYBRACKET:\n                    break scan;\n\n                case WHITESPACE:\n                case COMMENT:\n                    this.scanner.next();\n                    break;\n\n                case ATKEYWORD:\n                    children.push(this.parseWithFallback(this.Atrule, consumeRaw));\n                    break;\n\n                default:\n                    children.push(consumer.call(this));\n            }\n        }\n\n        if (!this.scanner.eof) {\n            this.eat(RIGHTCURLYBRACKET);\n        }\n\n        return {\n            type: 'Block',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.chunk('{');\n        this.children(node, function(prev) {\n            if (prev.type === 'Declaration') {\n                this.chunk(';');\n            }\n        });\n        this.chunk('}');\n    },\n    walkContext: 'block'\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;\nvar RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;\n\nmodule.exports = {\n    name: 'Brackets',\n    structure: {\n        children: [[]]\n    },\n    parse: function(readSequence, recognizer) {\n        var start = this.scanner.tokenStart;\n        var children = null;\n\n        this.eat(LEFTSQUAREBRACKET);\n\n        children = readSequence.call(this, recognizer);\n\n        if (!this.scanner.eof) {\n            this.eat(RIGHTSQUAREBRACKET);\n        }\n\n        return {\n            type: 'Brackets',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.chunk('[');\n        this.children(node);\n        this.chunk(']');\n    }\n};\n","var CDC = require('../../tokenizer').TYPE.CDC;\n\nmodule.exports = {\n    name: 'CDC',\n    structure: [],\n    parse: function() {\n        var start = this.scanner.tokenStart;\n\n        this.eat(CDC); // -->\n\n        return {\n            type: 'CDC',\n            loc: this.getLocation(start, this.scanner.tokenStart)\n        };\n    },\n    generate: function() {\n        this.chunk('-->');\n    }\n};\n","var CDO = require('../../tokenizer').TYPE.CDO;\n\nmodule.exports = {\n    name: 'CDO',\n    structure: [],\n    parse: function() {\n        var start = this.scanner.tokenStart;\n\n        this.eat(CDO); // <!--\n\n        return {\n            type: 'CDO',\n            loc: this.getLocation(start, this.scanner.tokenStart)\n        };\n    },\n    generate: function() {\n        this.chunk('<!--');\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\nvar FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\n// '.' ident\nmodule.exports = {\n    name: 'ClassSelector',\n    structure: {\n        name: String\n    },\n    parse: function() {\n        if (!this.scanner.isDelim(FULLSTOP)) {\n            this.error('Full stop is expected');\n        }\n\n        this.scanner.next();\n\n        return {\n            type: 'ClassSelector',\n            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),\n            name: this.consume(IDENT)\n        };\n    },\n    generate: function(node) {\n        this.chunk('.');\n        this.chunk(node.name);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\nvar PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nvar SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nvar GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nvar TILDE = 0x007E;           // U+007E TILDE (~)\n\n// + | > | ~ | /deep/\nmodule.exports = {\n    name: 'Combinator',\n    structure: {\n        name: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n\n        switch (code) {\n            case GREATERTHANSIGN:\n            case PLUSSIGN:\n            case TILDE:\n                this.scanner.next();\n                break;\n\n            case SOLIDUS:\n                this.scanner.next();\n\n                if (this.scanner.tokenType !== IDENT || this.scanner.lookupValue(0, 'deep') === false) {\n                    this.error('Identifier `deep` is expected');\n                }\n\n                this.scanner.next();\n\n                if (!this.scanner.isDelim(SOLIDUS)) {\n                    this.error('Solidus is expected');\n                }\n\n                this.scanner.next();\n                break;\n\n            default:\n                this.error('Combinator is expected');\n        }\n\n        return {\n            type: 'Combinator',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: this.scanner.substrToCursor(start)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.name);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar COMMENT = TYPE.Comment;\nvar ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nvar SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\n// '/*' .* '*/'\nmodule.exports = {\n    name: 'Comment',\n    structure: {\n        value: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var end = this.scanner.tokenEnd;\n\n        this.eat(COMMENT);\n\n        if ((end - start + 2) >= 2 &&\n            this.scanner.source.charCodeAt(end - 2) === ASTERISK &&\n            this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {\n            end -= 2;\n        }\n\n        return {\n            type: 'Comment',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            value: this.scanner.source.substring(start + 2, end)\n        };\n    },\n    generate: function(node) {\n        this.chunk('/*');\n        this.chunk(node.value);\n        this.chunk('*/');\n    }\n};\n","var isCustomProperty = require('../../utils/names').isCustomProperty;\nvar TYPE = require('../../tokenizer').TYPE;\nvar rawMode = require('./Raw').mode;\n\nvar IDENT = TYPE.Ident;\nvar HASH = TYPE.Hash;\nvar COLON = TYPE.Colon;\nvar SEMICOLON = TYPE.Semicolon;\nvar DELIM = TYPE.Delim;\nvar EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\nvar NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nvar DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)\nvar AMPERSAND = 0x0026;       // U+0026 ANPERSAND (&)\nvar ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nvar PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nvar SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\n\nfunction consumeValueRaw(startToken) {\n    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);\n}\n\nfunction consumeCustomPropertyRaw(startToken) {\n    return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);\n}\n\nfunction consumeValue() {\n    var startValueToken = this.scanner.tokenIndex;\n    var value = this.Value();\n\n    if (value.type !== 'Raw' &&\n        this.scanner.eof === false &&\n        this.scanner.tokenType !== SEMICOLON &&\n        this.scanner.isDelim(EXCLAMATIONMARK) === false &&\n        this.scanner.isBalanceEdge(startValueToken) === false) {\n        this.error();\n    }\n\n    return value;\n}\n\nmodule.exports = {\n    name: 'Declaration',\n    structure: {\n        important: [Boolean, String],\n        property: String,\n        value: ['Value', 'Raw']\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var startToken = this.scanner.tokenIndex;\n        var property = readProperty.call(this);\n        var customProperty = isCustomProperty(property);\n        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;\n        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;\n        var important = false;\n        var value;\n\n        this.scanner.skipSC();\n        this.eat(COLON);\n\n        if (!customProperty) {\n            this.scanner.skipSC();\n        }\n\n        if (parseValue) {\n            value = this.parseWithFallback(consumeValue, consumeRaw);\n        } else {\n            value = consumeRaw.call(this, this.scanner.tokenIndex);\n        }\n\n        if (this.scanner.isDelim(EXCLAMATIONMARK)) {\n            important = getImportant.call(this);\n            this.scanner.skipSC();\n        }\n\n        // Do not include semicolon to range per spec\n        // https://drafts.csswg.org/css-syntax/#declaration-diagram\n\n        if (this.scanner.eof === false &&\n            this.scanner.tokenType !== SEMICOLON &&\n            this.scanner.isBalanceEdge(startToken) === false) {\n            this.error();\n        }\n\n        return {\n            type: 'Declaration',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            important: important,\n            property: property,\n            value: value\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.property);\n        this.chunk(':');\n        this.node(node.value);\n\n        if (node.important) {\n            this.chunk(node.important === true ? '!important' : '!' + node.important);\n        }\n    },\n    walkContext: 'declaration'\n};\n\nfunction readProperty() {\n    var start = this.scanner.tokenStart;\n    var prefix = 0;\n\n    // hacks\n    if (this.scanner.tokenType === DELIM) {\n        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {\n            case ASTERISK:\n            case DOLLARSIGN:\n            case PLUSSIGN:\n            case NUMBERSIGN:\n            case AMPERSAND:\n                this.scanner.next();\n                break;\n\n            // TODO: not sure we should support this hack\n            case SOLIDUS:\n                this.scanner.next();\n                if (this.scanner.isDelim(SOLIDUS)) {\n                    this.scanner.next();\n                }\n                break;\n        }\n    }\n\n    if (prefix) {\n        this.scanner.skip(prefix);\n    }\n\n    if (this.scanner.tokenType === HASH) {\n        this.eat(HASH);\n    } else {\n        this.eat(IDENT);\n    }\n\n    return this.scanner.substrToCursor(start);\n}\n\n// ! ws* important\nfunction getImportant() {\n    this.eat(DELIM);\n    this.scanner.skipSC();\n\n    var important = this.consume(IDENT);\n\n    // store original value in case it differ from `important`\n    // for better original source restoring and hacks like `!ie` support\n    return important === 'important' ? true : important;\n}\n","var TYPE = require('../../tokenizer').TYPE;\nvar rawMode = require('./Raw').mode;\n\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar SEMICOLON = TYPE.Semicolon;\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, rawMode.semicolonIncluded, true);\n}\n\nmodule.exports = {\n    name: 'DeclarationList',\n    structure: {\n        children: [[\n            'Declaration'\n        ]]\n    },\n    parse: function() {\n        var children = this.createList();\n\n        scan:\n        while (!this.scanner.eof) {\n            switch (this.scanner.tokenType) {\n                case WHITESPACE:\n                case COMMENT:\n                case SEMICOLON:\n                    this.scanner.next();\n                    break;\n\n                default:\n                    children.push(this.parseWithFallback(this.Declaration, consumeRaw));\n            }\n        }\n\n        return {\n            type: 'DeclarationList',\n            loc: this.getLocationFromList(children),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.children(node, function(prev) {\n            if (prev.type === 'Declaration') {\n                this.chunk(';');\n            }\n        });\n    }\n};\n","var consumeNumber = require('../../tokenizer/utils').consumeNumber;\nvar TYPE = require('../../tokenizer').TYPE;\n\nvar DIMENSION = TYPE.Dimension;\n\nmodule.exports = {\n    name: 'Dimension',\n    structure: {\n        value: String,\n        unit: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var numberEnd = consumeNumber(this.scanner.source, start);\n\n        this.eat(DIMENSION);\n\n        return {\n            type: 'Dimension',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            value: this.scanner.source.substring(start, numberEnd),\n            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.value);\n        this.chunk(node.unit);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar RIGHTPARENTHESIS = TYPE.RightParenthesis;\n\n// <function-token> <sequence> )\nmodule.exports = {\n    name: 'Function',\n    structure: {\n        name: String,\n        children: [[]]\n    },\n    parse: function(readSequence, recognizer) {\n        var start = this.scanner.tokenStart;\n        var name = this.consumeFunctionName();\n        var nameLowerCase = name.toLowerCase();\n        var children;\n\n        children = recognizer.hasOwnProperty(nameLowerCase)\n            ? recognizer[nameLowerCase].call(this, recognizer)\n            : readSequence.call(this, recognizer);\n\n        if (!this.scanner.eof) {\n            this.eat(RIGHTPARENTHESIS);\n        }\n\n        return {\n            type: 'Function',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: name,\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.name);\n        this.chunk('(');\n        this.children(node);\n        this.chunk(')');\n    },\n    walkContext: 'function'\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar HASH = TYPE.Hash;\n\n// '#' ident\nmodule.exports = {\n    name: 'HexColor',\n    structure: {\n        value: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n\n        this.eat(HASH);\n\n        return {\n            type: 'HexColor',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            value: this.scanner.substrToCursor(start + 1)\n        };\n    },\n    generate: function(node) {\n        this.chunk('#');\n        this.chunk(node.value);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\n\nmodule.exports = {\n    name: 'Identifier',\n    structure: {\n        name: String\n    },\n    parse: function() {\n        return {\n            type: 'Identifier',\n            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n            name: this.consume(IDENT)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.name);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar HASH = TYPE.Hash;\n\n// <hash-token>\nmodule.exports = {\n    name: 'IdSelector',\n    structure: {\n        name: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n\n        // TODO: check value is an ident\n        this.eat(HASH);\n\n        return {\n            type: 'IdSelector',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: this.scanner.substrToCursor(start + 1)\n        };\n    },\n    generate: function(node) {\n        this.chunk('#');\n        this.chunk(node.name);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\nvar NUMBER = TYPE.Number;\nvar DIMENSION = TYPE.Dimension;\nvar LEFTPARENTHESIS = TYPE.LeftParenthesis;\nvar RIGHTPARENTHESIS = TYPE.RightParenthesis;\nvar COLON = TYPE.Colon;\nvar DELIM = TYPE.Delim;\n\nmodule.exports = {\n    name: 'MediaFeature',\n    structure: {\n        name: String,\n        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var name;\n        var value = null;\n\n        this.eat(LEFTPARENTHESIS);\n        this.scanner.skipSC();\n\n        name = this.consume(IDENT);\n        this.scanner.skipSC();\n\n        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {\n            this.eat(COLON);\n            this.scanner.skipSC();\n\n            switch (this.scanner.tokenType) {\n                case NUMBER:\n                    if (this.lookupNonWSType(1) === DELIM) {\n                        value = this.Ratio();\n                    } else {\n                        value = this.Number();\n                    }\n\n                    break;\n\n                case DIMENSION:\n                    value = this.Dimension();\n                    break;\n\n                case IDENT:\n                    value = this.Identifier();\n\n                    break;\n\n                default:\n                    this.error('Number, dimension, ratio or identifier is expected');\n            }\n\n            this.scanner.skipSC();\n        }\n\n        this.eat(RIGHTPARENTHESIS);\n\n        return {\n            type: 'MediaFeature',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: name,\n            value: value\n        };\n    },\n    generate: function(node) {\n        this.chunk('(');\n        this.chunk(node.name);\n        if (node.value !== null) {\n            this.chunk(':');\n            this.node(node.value);\n        }\n        this.chunk(')');\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar LEFTPARENTHESIS = TYPE.LeftParenthesis;\n\nmodule.exports = {\n    name: 'MediaQuery',\n    structure: {\n        children: [[\n            'Identifier',\n            'MediaFeature',\n            'WhiteSpace'\n        ]]\n    },\n    parse: function() {\n        this.scanner.skipSC();\n\n        var children = this.createList();\n        var child = null;\n        var space = null;\n\n        scan:\n        while (!this.scanner.eof) {\n            switch (this.scanner.tokenType) {\n                case COMMENT:\n                    this.scanner.next();\n                    continue;\n\n                case WHITESPACE:\n                    space = this.WhiteSpace();\n                    continue;\n\n                case IDENT:\n                    child = this.Identifier();\n                    break;\n\n                case LEFTPARENTHESIS:\n                    child = this.MediaFeature();\n                    break;\n\n                default:\n                    break scan;\n            }\n\n            if (space !== null) {\n                children.push(space);\n                space = null;\n            }\n\n            children.push(child);\n        }\n\n        if (child === null) {\n            this.error('Identifier or parenthesis is expected');\n        }\n\n        return {\n            type: 'MediaQuery',\n            loc: this.getLocationFromList(children),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.children(node);\n    }\n};\n","var COMMA = require('../../tokenizer').TYPE.Comma;\n\nmodule.exports = {\n    name: 'MediaQueryList',\n    structure: {\n        children: [[\n            'MediaQuery'\n        ]]\n    },\n    parse: function(relative) {\n        var children = this.createList();\n\n        this.scanner.skipSC();\n\n        while (!this.scanner.eof) {\n            children.push(this.MediaQuery(relative));\n\n            if (this.scanner.tokenType !== COMMA) {\n                break;\n            }\n\n            this.scanner.next();\n        }\n\n        return {\n            type: 'MediaQueryList',\n            loc: this.getLocationFromList(children),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.children(node, function() {\n            this.chunk(',');\n        });\n    }\n};\n","module.exports = {\n    name: 'Nth',\n    structure: {\n        nth: ['AnPlusB', 'Identifier'],\n        selector: ['SelectorList', null]\n    },\n    parse: function(allowOfClause) {\n        this.scanner.skipSC();\n\n        var start = this.scanner.tokenStart;\n        var end = start;\n        var selector = null;\n        var query;\n\n        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {\n            query = this.Identifier();\n        } else {\n            query = this.AnPlusB();\n        }\n\n        this.scanner.skipSC();\n\n        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {\n            this.scanner.next();\n\n            selector = this.SelectorList();\n\n            if (this.needPositions) {\n                end = this.getLastListNode(selector.children).loc.end.offset;\n            }\n        } else {\n            if (this.needPositions) {\n                end = query.loc.end.offset;\n            }\n        }\n\n        return {\n            type: 'Nth',\n            loc: this.getLocation(start, end),\n            nth: query,\n            selector: selector\n        };\n    },\n    generate: function(node) {\n        this.node(node.nth);\n        if (node.selector !== null) {\n            this.chunk(' of ');\n            this.node(node.selector);\n        }\n    }\n};\n","var NUMBER = require('../../tokenizer').TYPE.Number;\n\nmodule.exports = {\n    name: 'Number',\n    structure: {\n        value: String\n    },\n    parse: function() {\n        return {\n            type: 'Number',\n            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n            value: this.consume(NUMBER)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.value);\n    }\n};\n","// '/' | '*' | ',' | ':' | '+' | '-'\nmodule.exports = {\n    name: 'Operator',\n    structure: {\n        value: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n\n        this.scanner.next();\n\n        return {\n            type: 'Operator',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            value: this.scanner.substrToCursor(start)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.value);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar LEFTPARENTHESIS = TYPE.LeftParenthesis;\nvar RIGHTPARENTHESIS = TYPE.RightParenthesis;\n\nmodule.exports = {\n    name: 'Parentheses',\n    structure: {\n        children: [[]]\n    },\n    parse: function(readSequence, recognizer) {\n        var start = this.scanner.tokenStart;\n        var children = null;\n\n        this.eat(LEFTPARENTHESIS);\n\n        children = readSequence.call(this, recognizer);\n\n        if (!this.scanner.eof) {\n            this.eat(RIGHTPARENTHESIS);\n        }\n\n        return {\n            type: 'Parentheses',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.chunk('(');\n        this.children(node);\n        this.chunk(')');\n    }\n};\n","var consumeNumber = require('../../tokenizer/utils').consumeNumber;\nvar TYPE = require('../../tokenizer').TYPE;\n\nvar PERCENTAGE = TYPE.Percentage;\n\nmodule.exports = {\n    name: 'Percentage',\n    structure: {\n        value: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var numberEnd = consumeNumber(this.scanner.source, start);\n\n        this.eat(PERCENTAGE);\n\n        return {\n            type: 'Percentage',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            value: this.scanner.source.substring(start, numberEnd)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.value);\n        this.chunk('%');\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar COLON = TYPE.Colon;\nvar RIGHTPARENTHESIS = TYPE.RightParenthesis;\n\n// : [ <ident> | <function-token> <any-value>? ) ]\nmodule.exports = {\n    name: 'PseudoClassSelector',\n    structure: {\n        name: String,\n        children: [['Raw'], null]\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var children = null;\n        var name;\n        var nameLowerCase;\n\n        this.eat(COLON);\n\n        if (this.scanner.tokenType === FUNCTION) {\n            name = this.consumeFunctionName();\n            nameLowerCase = name.toLowerCase();\n\n            if (this.pseudo.hasOwnProperty(nameLowerCase)) {\n                this.scanner.skipSC();\n                children = this.pseudo[nameLowerCase].call(this);\n                this.scanner.skipSC();\n            } else {\n                children = this.createList();\n                children.push(\n                    this.Raw(this.scanner.tokenIndex, null, false)\n                );\n            }\n\n            this.eat(RIGHTPARENTHESIS);\n        } else {\n            name = this.consume(IDENT);\n        }\n\n        return {\n            type: 'PseudoClassSelector',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: name,\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.chunk(':');\n        this.chunk(node.name);\n\n        if (node.children !== null) {\n            this.chunk('(');\n            this.children(node);\n            this.chunk(')');\n        }\n    },\n    walkContext: 'function'\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar COLON = TYPE.Colon;\nvar RIGHTPARENTHESIS = TYPE.RightParenthesis;\n\n// :: [ <ident> | <function-token> <any-value>? ) ]\nmodule.exports = {\n    name: 'PseudoElementSelector',\n    structure: {\n        name: String,\n        children: [['Raw'], null]\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var children = null;\n        var name;\n        var nameLowerCase;\n\n        this.eat(COLON);\n        this.eat(COLON);\n\n        if (this.scanner.tokenType === FUNCTION) {\n            name = this.consumeFunctionName();\n            nameLowerCase = name.toLowerCase();\n\n            if (this.pseudo.hasOwnProperty(nameLowerCase)) {\n                this.scanner.skipSC();\n                children = this.pseudo[nameLowerCase].call(this);\n                this.scanner.skipSC();\n            } else {\n                children = this.createList();\n                children.push(\n                    this.Raw(this.scanner.tokenIndex, null, false)\n                );\n            }\n\n            this.eat(RIGHTPARENTHESIS);\n        } else {\n            name = this.consume(IDENT);\n        }\n\n        return {\n            type: 'PseudoElementSelector',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: name,\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.chunk('::');\n        this.chunk(node.name);\n\n        if (node.children !== null) {\n            this.chunk('(');\n            this.children(node);\n            this.chunk(')');\n        }\n    },\n    walkContext: 'function'\n};\n","var isDigit = require('../../tokenizer').isDigit;\nvar TYPE = require('../../tokenizer').TYPE;\n\nvar NUMBER = TYPE.Number;\nvar DELIM = TYPE.Delim;\nvar SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)\nvar FULLSTOP = 0x002E; // U+002E FULL STOP (.)\n\n// Terms of <ratio> should be a positive numbers (not zero or negative)\n// (see https://drafts.csswg.org/mediaqueries-3/#values)\n// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term\n// and this is using by various sites. Therefore we relax checking on parse\n// to test a term is unsigned number without an exponent part.\n// Additional checking may be applied on lexer validation.\nfunction consumeNumber() {\n    this.scanner.skipWS();\n\n    var value = this.consume(NUMBER);\n\n    for (var i = 0; i < value.length; i++) {\n        var code = value.charCodeAt(i);\n        if (!isDigit(code) && code !== FULLSTOP) {\n            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);\n        }\n    }\n\n    if (Number(value) === 0) {\n        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);\n    }\n\n    return value;\n}\n\n// <positive-integer> S* '/' S* <positive-integer>\nmodule.exports = {\n    name: 'Ratio',\n    structure: {\n        left: String,\n        right: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var left = consumeNumber.call(this);\n        var right;\n\n        this.scanner.skipWS();\n\n        if (!this.scanner.isDelim(SOLIDUS)) {\n            this.error('Solidus is expected');\n        }\n        this.eat(DELIM);\n        right = consumeNumber.call(this);\n\n        return {\n            type: 'Ratio',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            left: left,\n            right: right\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.left);\n        this.chunk('/');\n        this.chunk(node.right);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\nvar rawMode = require('./Raw').mode;\n\nvar LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, rawMode.leftCurlyBracket, true);\n}\n\nfunction consumePrelude() {\n    var prelude = this.SelectorList();\n\n    if (prelude.type !== 'Raw' &&\n        this.scanner.eof === false &&\n        this.scanner.tokenType !== LEFTCURLYBRACKET) {\n        this.error();\n    }\n\n    return prelude;\n}\n\nmodule.exports = {\n    name: 'Rule',\n    structure: {\n        prelude: ['SelectorList', 'Raw'],\n        block: ['Block']\n    },\n    parse: function() {\n        var startToken = this.scanner.tokenIndex;\n        var startOffset = this.scanner.tokenStart;\n        var prelude;\n        var block;\n\n        if (this.parseRulePrelude) {\n            prelude = this.parseWithFallback(consumePrelude, consumeRaw);\n        } else {\n            prelude = consumeRaw.call(this, startToken);\n        }\n\n        block = this.Block(true);\n\n        return {\n            type: 'Rule',\n            loc: this.getLocation(startOffset, this.scanner.tokenStart),\n            prelude: prelude,\n            block: block\n        };\n    },\n    generate: function(node) {\n        this.node(node.prelude);\n        this.node(node.block);\n    },\n    walkContext: 'rule'\n};\n","module.exports = {\n    name: 'Selector',\n    structure: {\n        children: [[\n            'TypeSelector',\n            'IdSelector',\n            'ClassSelector',\n            'AttributeSelector',\n            'PseudoClassSelector',\n            'PseudoElementSelector',\n            'Combinator',\n            'WhiteSpace'\n        ]]\n    },\n    parse: function() {\n        var children = this.readSequence(this.scope.Selector);\n\n        // nothing were consumed\n        if (this.getFirstListNode(children) === null) {\n            this.error('Selector is expected');\n        }\n\n        return {\n            type: 'Selector',\n            loc: this.getLocationFromList(children),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.children(node);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar COMMA = TYPE.Comma;\n\nmodule.exports = {\n    name: 'SelectorList',\n    structure: {\n        children: [[\n            'Selector',\n            'Raw'\n        ]]\n    },\n    parse: function() {\n        var children = this.createList();\n\n        while (!this.scanner.eof) {\n            children.push(this.Selector());\n\n            if (this.scanner.tokenType === COMMA) {\n                this.scanner.next();\n                continue;\n            }\n\n            break;\n        }\n\n        return {\n            type: 'SelectorList',\n            loc: this.getLocationFromList(children),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.children(node, function() {\n            this.chunk(',');\n        });\n    },\n    walkContext: 'selector'\n};\n","var STRING = require('../../tokenizer').TYPE.String;\n\nmodule.exports = {\n    name: 'String',\n    structure: {\n        value: String\n    },\n    parse: function() {\n        return {\n            type: 'String',\n            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n            value: this.consume(STRING)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.value);\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar ATKEYWORD = TYPE.AtKeyword;\nvar CDO = TYPE.CDO;\nvar CDC = TYPE.CDC;\nvar EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)\n\nfunction consumeRaw(startToken) {\n    return this.Raw(startToken, null, false);\n}\n\nmodule.exports = {\n    name: 'StyleSheet',\n    structure: {\n        children: [[\n            'Comment',\n            'CDO',\n            'CDC',\n            'Atrule',\n            'Rule',\n            'Raw'\n        ]]\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var children = this.createList();\n        var child;\n\n        scan:\n        while (!this.scanner.eof) {\n            switch (this.scanner.tokenType) {\n                case WHITESPACE:\n                    this.scanner.next();\n                    continue;\n\n                case COMMENT:\n                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level\n                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {\n                        this.scanner.next();\n                        continue;\n                    }\n\n                    child = this.Comment();\n                    break;\n\n                case CDO: // <!--\n                    child = this.CDO();\n                    break;\n\n                case CDC: // -->\n                    child = this.CDC();\n                    break;\n\n                // CSS Syntax Module Level 3\n                // §2.2 Error handling\n                // At the \"top level\" of a stylesheet, an <at-keyword-token> starts an at-rule.\n                case ATKEYWORD:\n                    child = this.parseWithFallback(this.Atrule, consumeRaw);\n                    break;\n\n                // Anything else starts a qualified rule ...\n                default:\n                    child = this.parseWithFallback(this.Rule, consumeRaw);\n            }\n\n            children.push(child);\n        }\n\n        return {\n            type: 'StyleSheet',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.children(node);\n    },\n    walkContext: 'stylesheet'\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\nvar ASTERISK = 0x002A;     // U+002A ASTERISK (*)\nvar VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)\n\nfunction eatIdentifierOrAsterisk() {\n    if (this.scanner.tokenType !== IDENT &&\n        this.scanner.isDelim(ASTERISK) === false) {\n        this.error('Identifier or asterisk is expected');\n    }\n\n    this.scanner.next();\n}\n\n// ident\n// ident|ident\n// ident|*\n// *\n// *|ident\n// *|*\n// |ident\n// |*\nmodule.exports = {\n    name: 'TypeSelector',\n    structure: {\n        name: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n\n        if (this.scanner.isDelim(VERTICALLINE)) {\n            this.scanner.next();\n            eatIdentifierOrAsterisk.call(this);\n        } else {\n            eatIdentifierOrAsterisk.call(this);\n\n            if (this.scanner.isDelim(VERTICALLINE)) {\n                this.scanner.next();\n                eatIdentifierOrAsterisk.call(this);\n            }\n        }\n\n        return {\n            type: 'TypeSelector',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            name: this.scanner.substrToCursor(start)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.name);\n    }\n};\n","var isHexDigit = require('../../tokenizer').isHexDigit;\nvar cmpChar = require('../../tokenizer').cmpChar;\nvar TYPE = require('../../tokenizer').TYPE;\nvar NAME = require('../../tokenizer').NAME;\n\nvar IDENT = TYPE.Ident;\nvar NUMBER = TYPE.Number;\nvar DIMENSION = TYPE.Dimension;\nvar PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)\nvar HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)\nvar QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)\nvar U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)\n\nfunction eatHexSequence(offset, allowDash) {\n    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {\n        var code = this.scanner.source.charCodeAt(pos);\n\n        if (code === HYPHENMINUS && allowDash && len !== 0) {\n            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {\n                this.error();\n            }\n\n            return -1;\n        }\n\n        if (!isHexDigit(code)) {\n            this.error(\n                allowDash && len !== 0\n                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'\n                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),\n                pos\n            );\n        }\n\n        if (++len > 6) {\n            this.error('Too many hex digits', pos);\n        };\n    }\n\n    this.scanner.next();\n    return len;\n}\n\nfunction eatQuestionMarkSequence(max) {\n    var count = 0;\n\n    while (this.scanner.isDelim(QUESTIONMARK)) {\n        if (++count > max) {\n            this.error('Too many question marks');\n        }\n\n        this.scanner.next();\n    }\n}\n\nfunction startsWith(code) {\n    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {\n        this.error(NAME[code] + ' is expected');\n    }\n}\n\n// https://drafts.csswg.org/css-syntax/#urange\n// Informally, the <urange> production has three forms:\n// U+0001\n//      Defines a range consisting of a single code point, in this case the code point \"1\".\n// U+0001-00ff\n//      Defines a range of codepoints between the first and the second value, in this case\n//      the range between \"1\" and \"ff\" (255 in decimal) inclusive.\n// U+00??\n//      Defines a range of codepoints where the \"?\" characters range over all hex digits,\n//      in this case defining the same as the value U+0000-00ff.\n// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat \"?\" as a hexadecimal digit).\n//\n// <urange> =\n//   u '+' <ident-token> '?'* |\n//   u <dimension-token> '?'* |\n//   u <number-token> '?'* |\n//   u <number-token> <dimension-token> |\n//   u <number-token> <number-token> |\n//   u '+' '?'+\nfunction scanUnicodeRange() {\n    var hexLength = 0;\n\n    // u '+' <ident-token> '?'*\n    // u '+' '?'+\n    if (this.scanner.isDelim(PLUSSIGN)) {\n        this.scanner.next();\n\n        if (this.scanner.tokenType === IDENT) {\n            hexLength = eatHexSequence.call(this, 0, true);\n            if (hexLength > 0) {\n                eatQuestionMarkSequence.call(this, 6 - hexLength);\n            }\n            return;\n        }\n\n        if (this.scanner.isDelim(QUESTIONMARK)) {\n            this.scanner.next();\n            eatQuestionMarkSequence.call(this, 5);\n            return;\n        }\n\n        this.error('Hex digit or question mark is expected');\n        return;\n    }\n\n    // u <number-token> '?'*\n    // u <number-token> <dimension-token>\n    // u <number-token> <number-token>\n    if (this.scanner.tokenType === NUMBER) {\n        startsWith.call(this, PLUSSIGN);\n        hexLength = eatHexSequence.call(this, 1, true);\n\n        if (this.scanner.isDelim(QUESTIONMARK)) {\n            eatQuestionMarkSequence.call(this, 6 - hexLength);\n            return;\n        }\n\n        if (this.scanner.tokenType === DIMENSION ||\n            this.scanner.tokenType === NUMBER) {\n            startsWith.call(this, HYPHENMINUS);\n            eatHexSequence.call(this, 1, false);\n            return;\n        }\n\n        return;\n    }\n\n    // u <dimension-token> '?'*\n    if (this.scanner.tokenType === DIMENSION) {\n        startsWith.call(this, PLUSSIGN);\n        hexLength = eatHexSequence.call(this, 1, true);\n\n        if (hexLength > 0) {\n            eatQuestionMarkSequence.call(this, 6 - hexLength);\n        }\n\n        return;\n    }\n\n    this.error();\n}\n\nmodule.exports = {\n    name: 'UnicodeRange',\n    structure: {\n        value: String\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n\n        // U or u\n        if (!cmpChar(this.scanner.source, start, U)) {\n            this.error('U is expected');\n        }\n\n        if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {\n            this.error('Plus sign is expected');\n        }\n\n        this.scanner.next();\n        scanUnicodeRange.call(this);\n\n        return {\n            type: 'UnicodeRange',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            value: this.scanner.substrToCursor(start)\n        };\n    },\n    generate: function(node) {\n        this.chunk(node.value);\n    }\n};\n","var isWhiteSpace = require('../../tokenizer').isWhiteSpace;\nvar cmpStr = require('../../tokenizer').cmpStr;\nvar TYPE = require('../../tokenizer').TYPE;\n\nvar FUNCTION = TYPE.Function;\nvar URL = TYPE.Url;\nvar RIGHTPARENTHESIS = TYPE.RightParenthesis;\n\n// <url-token> | <function-token> <string> )\nmodule.exports = {\n    name: 'Url',\n    structure: {\n        value: ['String', 'Raw']\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var value;\n\n        switch (this.scanner.tokenType) {\n            case URL:\n                var rawStart = start + 4;\n                var rawEnd = this.scanner.tokenEnd - 1;\n\n                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {\n                    rawStart++;\n                }\n\n                while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {\n                    rawEnd--;\n                }\n\n                value = {\n                    type: 'Raw',\n                    loc: this.getLocation(rawStart, rawEnd),\n                    value: this.scanner.source.substring(rawStart, rawEnd)\n                };\n\n                this.eat(URL);\n                break;\n\n            case FUNCTION:\n                if (!cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {\n                    this.error('Function name must be `url`');\n                }\n\n                this.eat(FUNCTION);\n                this.scanner.skipSC();\n                value = this.String();\n                this.scanner.skipSC();\n                this.eat(RIGHTPARENTHESIS);\n                break;\n\n            default:\n                this.error('Url or Function is expected');\n        }\n\n        return {\n            type: 'Url',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            value: value\n        };\n    },\n    generate: function(node) {\n        this.chunk('url');\n        this.chunk('(');\n        this.node(node.value);\n        this.chunk(')');\n    }\n};\n","module.exports = {\n    name: 'Value',\n    structure: {\n        children: [[]]\n    },\n    parse: function() {\n        var start = this.scanner.tokenStart;\n        var children = this.readSequence(this.scope.Value);\n\n        return {\n            type: 'Value',\n            loc: this.getLocation(start, this.scanner.tokenStart),\n            children: children\n        };\n    },\n    generate: function(node) {\n        this.children(node);\n    }\n};\n","var WHITESPACE = require('../../tokenizer').TYPE.WhiteSpace;\nvar SPACE = Object.freeze({\n    type: 'WhiteSpace',\n    loc: null,\n    value: ' '\n});\n\nmodule.exports = {\n    name: 'WhiteSpace',\n    structure: {\n        value: String\n    },\n    parse: function() {\n        this.eat(WHITESPACE);\n        return SPACE;\n\n        // return {\n        //     type: 'WhiteSpace',\n        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),\n        //     value: this.consume(WHITESPACE)\n        // };\n    },\n    generate: function(node) {\n        this.chunk(node.value);\n    }\n};\n","module.exports = {\n    parseContext: {\n        default: 'StyleSheet',\n        stylesheet: 'StyleSheet',\n        atrule: 'Atrule',\n        atrulePrelude: function(options) {\n            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);\n        },\n        mediaQueryList: 'MediaQueryList',\n        mediaQuery: 'MediaQuery',\n        rule: 'Rule',\n        selectorList: 'SelectorList',\n        selector: 'Selector',\n        block: function() {\n            return this.Block(true);\n        },\n        declarationList: 'DeclarationList',\n        declaration: 'Declaration',\n        value: 'Value'\n    },\n    scope: require('../scope'),\n    atrule: require('../atrule'),\n    pseudo: require('../pseudo'),\n    node: require('../node')\n};\n","module.exports = {\n    AtrulePrelude: require('./atrulePrelude'),\n    Selector: require('./selector'),\n    Value: require('./value')\n};\n","module.exports = {\n    getNode: require('./default')\n};\n","var cmpChar = require('../../tokenizer').cmpChar;\nvar cmpStr = require('../../tokenizer').cmpStr;\nvar TYPE = require('../../tokenizer').TYPE;\n\nvar IDENT = TYPE.Ident;\nvar STRING = TYPE.String;\nvar NUMBER = TYPE.Number;\nvar FUNCTION = TYPE.Function;\nvar URL = TYPE.Url;\nvar HASH = TYPE.Hash;\nvar DIMENSION = TYPE.Dimension;\nvar PERCENTAGE = TYPE.Percentage;\nvar LEFTPARENTHESIS = TYPE.LeftParenthesis;\nvar LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;\nvar COMMA = TYPE.Comma;\nvar DELIM = TYPE.Delim;\nvar NUMBERSIGN = 0x0023;  // U+0023 NUMBER SIGN (#)\nvar ASTERISK = 0x002A;    // U+002A ASTERISK (*)\nvar PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)\nvar HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)\nvar SOLIDUS = 0x002F;     // U+002F SOLIDUS (/)\nvar U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)\n\nmodule.exports = function defaultRecognizer(context) {\n    switch (this.scanner.tokenType) {\n        case HASH:\n            return this.HexColor();\n\n        case COMMA:\n            context.space = null;\n            context.ignoreWSAfter = true;\n            return this.Operator();\n\n        case LEFTPARENTHESIS:\n            return this.Parentheses(this.readSequence, context.recognizer);\n\n        case LEFTSQUAREBRACKET:\n            return this.Brackets(this.readSequence, context.recognizer);\n\n        case STRING:\n            return this.String();\n\n        case DIMENSION:\n            return this.Dimension();\n\n        case PERCENTAGE:\n            return this.Percentage();\n\n        case NUMBER:\n            return this.Number();\n\n        case FUNCTION:\n            return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')\n                ? this.Url()\n                : this.Function(this.readSequence, context.recognizer);\n\n        case URL:\n            return this.Url();\n\n        case IDENT:\n            // check for unicode range, it should start with u+ or U+\n            if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) &&\n                cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {\n                return this.UnicodeRange();\n            } else {\n                return this.Identifier();\n            }\n\n        case DELIM:\n            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n\n            if (code === SOLIDUS ||\n                code === ASTERISK ||\n                code === PLUSSIGN ||\n                code === HYPHENMINUS) {\n                return this.Operator(); // TODO: replace with Delim\n            }\n\n            // TODO: produce a node with Delim node type\n\n            if (code === NUMBERSIGN) {\n                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);\n            }\n\n            break;\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar DELIM = TYPE.Delim;\nvar IDENT = TYPE.Ident;\nvar DIMENSION = TYPE.Dimension;\nvar PERCENTAGE = TYPE.Percentage;\nvar NUMBER = TYPE.Number;\nvar HASH = TYPE.Hash;\nvar COLON = TYPE.Colon;\nvar LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;\nvar NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)\nvar ASTERISK = 0x002A;        // U+002A ASTERISK (*)\nvar PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)\nvar SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)\nvar FULLSTOP = 0x002E;        // U+002E FULL STOP (.)\nvar GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)\nvar VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)\nvar TILDE = 0x007E;           // U+007E TILDE (~)\n\nfunction getNode(context) {\n    switch (this.scanner.tokenType) {\n        case LEFTSQUAREBRACKET:\n            return this.AttributeSelector();\n\n        case HASH:\n            return this.IdSelector();\n\n        case COLON:\n            if (this.scanner.lookupType(1) === COLON) {\n                return this.PseudoElementSelector();\n            } else {\n                return this.PseudoClassSelector();\n            }\n\n        case IDENT:\n            return this.TypeSelector();\n\n        case NUMBER:\n        case PERCENTAGE:\n            return this.Percentage();\n\n        case DIMENSION:\n            // throws when .123ident\n            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {\n                this.error('Identifier is expected', this.scanner.tokenStart + 1);\n            }\n            break;\n\n        case DELIM:\n            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);\n\n            switch (code) {\n                case PLUSSIGN:\n                case GREATERTHANSIGN:\n                case TILDE:\n                    context.space = null;\n                    context.ignoreWSAfter = true;\n                    return this.Combinator();\n\n                case SOLIDUS:  // /deep/\n                    return this.Combinator();\n\n                case FULLSTOP:\n                    return this.ClassSelector();\n\n                case ASTERISK:\n                case VERTICALLINE:\n                    return this.TypeSelector();\n\n                case NUMBERSIGN:\n                    return this.IdSelector();\n            }\n\n            break;\n    }\n};\n\nmodule.exports = {\n    getNode: getNode\n};\n","module.exports = {\n    getNode: require('./default'),\n    '-moz-element': require('../function/element'),\n    'element': require('../function/element'),\n    'expression': require('../function/expression'),\n    'var': require('../function/var')\n};\n","// https://drafts.csswg.org/css-images-4/#element-notation\n// https://developer.mozilla.org/en-US/docs/Web/CSS/element\nmodule.exports = function() {\n    this.scanner.skipSC();\n\n    var children = this.createSingleNodeList(\n        this.IdSelector()\n    );\n\n    this.scanner.skipSC();\n\n    return children;\n};\n","// legacy IE function\n// expression( <any-value> )\nmodule.exports = function() {\n    return this.createSingleNodeList(\n        this.Raw(this.scanner.tokenIndex, null, false)\n    );\n};\n","var TYPE = require('../../tokenizer').TYPE;\nvar rawMode = require('../node/Raw').mode;\n\nvar COMMA = TYPE.Comma;\n\n// var( <ident> , <value>? )\nmodule.exports = function() {\n    var children = this.createList();\n\n    this.scanner.skipSC();\n\n    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer\n    children.push(this.Identifier());\n\n    this.scanner.skipSC();\n\n    if (this.scanner.tokenType === COMMA) {\n        children.push(this.Operator());\n        children.push(this.parseCustomProperty\n            ? this.Value(null)\n            : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false)\n        );\n    }\n\n    return children;\n};\n","module.exports = {\n    'font-face': require('./font-face'),\n    'import': require('./import'),\n    'media': require('./media'),\n    'page': require('./page'),\n    'supports': require('./supports')\n};\n","module.exports = {\n    parse: {\n        prelude: null,\n        block: function() {\n            return this.Block(true);\n        }\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar STRING = TYPE.String;\nvar IDENT = TYPE.Ident;\nvar URL = TYPE.Url;\nvar FUNCTION = TYPE.Function;\nvar LEFTPARENTHESIS = TYPE.LeftParenthesis;\n\nmodule.exports = {\n    parse: {\n        prelude: function() {\n            var children = this.createList();\n\n            this.scanner.skipSC();\n\n            switch (this.scanner.tokenType) {\n                case STRING:\n                    children.push(this.String());\n                    break;\n\n                case URL:\n                case FUNCTION:\n                    children.push(this.Url());\n                    break;\n\n                default:\n                    this.error('String or url() is expected');\n            }\n\n            if (this.lookupNonWSType(0) === IDENT ||\n                this.lookupNonWSType(0) === LEFTPARENTHESIS) {\n                children.push(this.WhiteSpace());\n                children.push(this.MediaQueryList());\n            }\n\n            return children;\n        },\n        block: null\n    }\n};\n","module.exports = {\n    parse: {\n        prelude: function() {\n            return this.createSingleNodeList(\n                this.MediaQueryList()\n            );\n        },\n        block: function() {\n            return this.Block(false);\n        }\n    }\n};\n","module.exports = {\n    parse: {\n        prelude: function() {\n            return this.createSingleNodeList(\n                this.SelectorList()\n            );\n        },\n        block: function() {\n            return this.Block(true);\n        }\n    }\n};\n","var TYPE = require('../../tokenizer').TYPE;\n\nvar WHITESPACE = TYPE.WhiteSpace;\nvar COMMENT = TYPE.Comment;\nvar IDENT = TYPE.Ident;\nvar FUNCTION = TYPE.Function;\nvar COLON = TYPE.Colon;\nvar LEFTPARENTHESIS = TYPE.LeftParenthesis;\n\nfunction consumeRaw() {\n    return this.createSingleNodeList(\n        this.Raw(this.scanner.tokenIndex, null, false)\n    );\n}\n\nfunction parentheses() {\n    this.scanner.skipSC();\n\n    if (this.scanner.tokenType === IDENT &&\n        this.lookupNonWSType(1) === COLON) {\n        return this.createSingleNodeList(\n            this.Declaration()\n        );\n    }\n\n    return readSequence.call(this);\n}\n\nfunction readSequence() {\n    var children = this.createList();\n    var space = null;\n    var child;\n\n    this.scanner.skipSC();\n\n    scan:\n    while (!this.scanner.eof) {\n        switch (this.scanner.tokenType) {\n            case WHITESPACE:\n                space = this.WhiteSpace();\n                continue;\n\n            case COMMENT:\n                this.scanner.next();\n                continue;\n\n            case FUNCTION:\n                child = this.Function(consumeRaw, this.scope.AtrulePrelude);\n                break;\n\n            case IDENT:\n                child = this.Identifier();\n                break;\n\n            case LEFTPARENTHESIS:\n                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);\n                break;\n\n            default:\n                break scan;\n        }\n\n        if (space !== null) {\n            children.push(space);\n            space = null;\n        }\n\n        children.push(child);\n    }\n\n    return children;\n}\n\nmodule.exports = {\n    parse: {\n        prelude: function() {\n            var children = readSequence.call(this);\n\n            if (this.getFirstListNode(children) === null) {\n                this.error('Condition is expected');\n            }\n\n            return children;\n        },\n        block: function() {\n            return this.Block(false);\n        }\n    }\n};\n","module.exports = {\n    'dir': require('./dir'),\n    'has': require('./has'),\n    'lang': require('./lang'),\n    'matches': require('./matches'),\n    'not': require('./not'),\n    'nth-child': require('./nth-child'),\n    'nth-last-child': require('./nth-last-child'),\n    'nth-last-of-type': require('./nth-last-of-type'),\n    'nth-of-type': require('./nth-of-type'),\n    'slotted': require('./slotted')\n};\n","module.exports = {\n    parse: function() {\n        return this.createSingleNodeList(\n            this.Identifier()\n        );\n    }\n};\n","module.exports = {\n    parse: function() {\n        return this.createSingleNodeList(\n            this.SelectorList()\n        );\n    }\n};\n","module.exports = {\n    parse: function() {\n        return this.createSingleNodeList(\n            this.Identifier()\n        );\n    }\n};\n","module.exports = require('./common/selectorList');\n","module.exports = {\n    parse: function selectorList() {\n        return this.createSingleNodeList(\n            this.SelectorList()\n        );\n    }\n};\n","module.exports = require('./common/selectorList');\n","module.exports = require('./common/nthWithOfClause');\n","var ALLOW_OF_CLAUSE = true;\n\nmodule.exports = {\n    parse: function nthWithOfClause() {\n        return this.createSingleNodeList(\n            this.Nth(ALLOW_OF_CLAUSE)\n        );\n    }\n};\n","module.exports = require('./common/nthWithOfClause');\n","module.exports = require('./common/nth');\n","var DISALLOW_OF_CLAUSE = false;\n\nmodule.exports = {\n    parse: function nth() {\n        return this.createSingleNodeList(\n            this.Nth(DISALLOW_OF_CLAUSE)\n        );\n    }\n};\n","module.exports = require('./common/nth');\n","module.exports = {\n    parse: function compoundSelector() {\n        return this.createSingleNodeList(\n            this.Selector()\n        );\n    }\n};\n","module.exports = {\n    node: require('../node')\n};\n"]}