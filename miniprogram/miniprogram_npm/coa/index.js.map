{"version":3,"sources":["index.js","lib/index.js","lib/cmd.js","lib/coaobject.js","lib/opt.js","lib/coaparam.js","lib/arg.js","lib/completion.js","lib/shell.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;;ACDA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA;ACFA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AFMA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AFOA,ACHA,AENA,AJYA,AGTA;AELA,AJYA,ACHA,AENA,ADGA;AELA,AJYA,ACHA,AENA,ADGA;AELA,AJYA,ACHA,AENA,ADGA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA,AIZA;AFOA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AELA,AJYA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,ACHA,AENA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AGTA,AENA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA,AHSA;AFOA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA,AKfA;ALgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["module.exports = require('./lib');\n","const\n    Cmd = require('./cmd'),\n    Opt = require('./opt'),\n    Arg = require('./arg'),\n    shell = require('./shell');\n\nmodule.exports = {\n    Cmd : Cmd.create,\n    Opt : Opt.create,\n    Arg : Arg.create,\n    classes : { Cmd, Opt, Arg },\n    shell,\n    require\n};\n","/* eslint-disable class-methods-use-this */\n\n\nconst\n    UTIL = require('util'),\n    PATH = require('path'),\n    EOL = require('os').EOL,\n\n    Q = require('q'),\n    chalk = require('chalk'),\n\n    CoaObject = require('./coaobject'),\n    Opt = require('./opt'),\n    Arg = require('./arg'),\n    completion = require('./completion');\n\n/**\n * Command\n *\n * Top level entity. Commands may have options and arguments.\n *\n * @namespace\n * @class Cmd\n * @extends CoaObject\n */\nclass Cmd extends CoaObject {\n    /**\n     * @constructs\n     * @param {COA.Cmd} [cmd] parent command\n     */\n    constructor(cmd) {\n        super(cmd);\n\n        this._parent(cmd);\n        this._cmds = [];\n        this._cmdsByName = {};\n        this._opts = [];\n        this._optsByKey = {};\n        this._args = [];\n        this._api = null;\n        this._ext = false;\n    }\n\n    static create(cmd) {\n        return new Cmd(cmd);\n    }\n\n    /**\n     * Returns object containing all its subcommands as methods\n     * to use from other programs.\n     *\n     * @returns {Object}\n     */\n    get api() {\n        // Need _this here because of passed arguments into _api\n        const _this = this;\n        this._api || (this._api = function () {\n            return _this.invoke.apply(_this, arguments);\n        });\n\n        const cmds = this._cmdsByName;\n        Object.keys(cmds).forEach(cmd => { this._api[cmd] = cmds[cmd].api; });\n\n        return this._api;\n    }\n\n    _parent(cmd) {\n        this._cmd = cmd || this;\n\n        this.isRootCmd ||\n            cmd._cmds.push(this) &&\n            this._name &&\n            (this._cmd._cmdsByName[this._name] = this);\n\n        return this;\n    }\n\n    get isRootCmd() {\n        return this._cmd === this;\n    }\n\n    /**\n     * Set a canonical command identifier to be used anywhere in the API.\n     *\n     * @param {String} name - command name\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n    name(name) {\n        super.name(name);\n\n        this.isRootCmd ||\n            (this._cmd._cmdsByName[name] = this);\n\n        return this;\n    }\n\n    /**\n     * Create new or add existing subcommand for current command.\n     *\n     * @param {COA.Cmd} [cmd] existing command instance\n     * @returns {COA.Cmd} new subcommand instance\n     */\n    cmd(cmd) {\n        return cmd?\n            cmd._parent(this)\n            : new Cmd(this);\n    }\n\n    /**\n     * Create option for current command.\n     *\n     * @returns {COA.Opt} new option instance\n     */\n    opt() {\n        return new Opt(this);\n    }\n\n    /**\n     * Create argument for current command.\n     *\n     * @returns {COA.Opt} new argument instance\n     */\n    arg() {\n        return new Arg(this);\n    }\n\n    /**\n     * Add (or set) action for current command.\n     *\n     * @param {Function} act - action function,\n     *         invoked in the context of command instance\n     *         and has the parameters:\n     *                 - {Object} opts - parsed options\n     *                 - {String[]} args - parsed arguments\n     *                 - {Object} res - actions result accumulator\n     *         It can return rejected promise by Cmd.reject (in case of error)\n     *         or any other value treated as result.\n     * @param {Boolean} [force=false] flag for set action instead add to existings\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n    act(act, force) {\n        if(!act) return this;\n\n        (!this._act || force) && (this._act = []);\n        this._act.push(act);\n\n        return this;\n    }\n\n    /**\n     * Make command \"helpful\", i.e. add -h --help flags for print usage.\n     *\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n    helpful() {\n        return this.opt()\n            .name('help')\n            .title('Help')\n            .short('h')\n            .long('help')\n            .flag()\n            .only()\n            .act(function() {\n                return this.usage();\n            })\n            .end();\n    }\n\n    /**\n     * Adds shell completion to command, adds \"completion\" subcommand,\n     * that makes all the magic.\n     * Must be called only on root command.\n     *\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n    completable() {\n        return this.cmd()\n            .name('completion')\n            .apply(completion)\n            .end();\n    }\n\n    /**\n     * Allow command to be extendable by external node.js modules.\n     *\n     * @param {String} [pattern]  Pattern of node.js module to find subcommands at.\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n    extendable(pattern) {\n        this._ext = pattern || true;\n        return this;\n    }\n\n    _exit(msg, code) {\n        return process.once('exit', function(exitCode) {\n            msg && console[code === 0 ? 'log' : 'error'](msg);\n            process.exit(code || exitCode || 0);\n        });\n    }\n\n    /**\n     * Build full usage text for current command instance.\n     *\n     * @returns {String} usage text\n     */\n    usage() {\n        const res = [];\n\n        this._title && res.push(this._fullTitle());\n\n        res.push('', 'Usage:');\n\n        this._cmds.length\n            && res.push([\n                '', '', chalk.redBright(this._fullName()), chalk.blueBright('COMMAND'),\n                chalk.greenBright('[OPTIONS]'), chalk.magentaBright('[ARGS]')\n            ].join(' '));\n\n        (this._opts.length + this._args.length)\n            && res.push([\n                '', '', chalk.redBright(this._fullName()),\n                chalk.greenBright('[OPTIONS]'), chalk.magentaBright('[ARGS]')\n            ].join(' '));\n\n        res.push(\n            this._usages(this._cmds, 'Commands'),\n            this._usages(this._opts, 'Options'),\n            this._usages(this._args, 'Arguments')\n        );\n\n        return res.join(EOL);\n    }\n\n    _usage() {\n        return chalk.blueBright(this._name) + ' : ' + this._title;\n    }\n\n    _usages(os, title) {\n        if(!os.length) return;\n\n        return ['', title + ':']\n            .concat(os.map(o => `  ${o._usage()}`))\n            .join(EOL);\n    }\n\n    _fullTitle() {\n        return `${this.isRootCmd? '' : this._cmd._fullTitle() + EOL}${this._title}`;\n    }\n\n    _fullName() {\n        return `${this.isRootCmd? '' : this._cmd._fullName() + ' '}${PATH.basename(this._name)}`;\n    }\n\n    _ejectOpt(opts, opt) {\n        const pos = opts.indexOf(opt);\n        if(pos === -1) return;\n\n        return opts[pos]._arr?\n            opts[pos] :\n            opts.splice(pos, 1)[0];\n    }\n\n    _checkRequired(opts, args) {\n        if(this._opts.some(opt => opt._only && opts.hasOwnProperty(opt._name))) return;\n\n        const all = this._opts.concat(this._args);\n        let i;\n        while(i = all.shift())\n            if(i._req && i._checkParsed(opts, args))\n                return this.reject(i._requiredText());\n    }\n\n    _parseCmd(argv, unparsed) {\n        unparsed || (unparsed = []);\n\n        let i,\n            optSeen = false;\n        while(i = argv.shift()) {\n            i.indexOf('-') || (optSeen = true);\n\n            if(optSeen || !/^\\w[\\w-_]*$/.test(i)) {\n                unparsed.push(i);\n                continue;\n            }\n\n            let pkg, cmd = this._cmdsByName[i];\n            if(!cmd && this._ext) {\n                if(this._ext === true) {\n                    pkg = i;\n                    let c = this;\n                    while(true) { // eslint-disable-line\n                        pkg = c._name + '-' + pkg;\n                        if(c.isRootCmd) break;\n                        c = c._cmd;\n                    }\n                } else if(typeof this._ext === 'string')\n                    pkg = ~this._ext.indexOf('%s')?\n                        UTIL.format(this._ext, i) :\n                        this._ext + i;\n\n                let cmdDesc;\n                try {\n                    cmdDesc = require(pkg);\n                } catch(e) {\n                    // Dummy\n                }\n\n                if(cmdDesc) {\n                    if(typeof cmdDesc === 'function') {\n                        this.cmd().name(i).apply(cmdDesc).end();\n                    } else if(typeof cmdDesc === 'object') {\n                        this.cmd(cmdDesc);\n                        cmdDesc.name(i);\n                    } else throw new Error('Error: Unsupported command declaration type, '\n                        + 'should be a function or COA.Cmd() object');\n\n                    cmd = this._cmdsByName[i];\n                }\n            }\n\n            if(cmd) return cmd._parseCmd(argv, unparsed);\n\n            unparsed.push(i);\n        }\n\n        return { cmd : this, argv : unparsed };\n    }\n\n    _parseOptsAndArgs(argv) {\n        const opts = {},\n            args = {},\n            nonParsedOpts = this._opts.concat(),\n            nonParsedArgs = this._args.concat();\n\n        let res, i;\n        while(i = argv.shift()) {\n            if(i !== '--' && i[0] === '-') {\n                const m = i.match(/^(--\\w[\\w-_]*)=(.*)$/);\n                if(m) {\n                    i = m[1];\n                    this._optsByKey[i]._flag || argv.unshift(m[2]);\n                }\n\n                const opt = this._ejectOpt(nonParsedOpts, this._optsByKey[i]);\n                if(!opt) return this.reject(`Unknown option: ${i}`);\n\n                if(Q.isRejected(res = opt._parse(argv, opts))) return res;\n\n                continue;\n            }\n\n            i === '--' && (i = argv.splice(0));\n            Array.isArray(i) || (i = [i]);\n\n            let a;\n            while(a = i.shift()) {\n                let arg = nonParsedArgs.shift();\n                if(!arg) return this.reject(`Unknown argument: ${a}`);\n\n                arg._arr && nonParsedArgs.unshift(arg);\n                if(Q.isRejected(res = arg._parse(a, args))) return res;\n            }\n        }\n\n        return {\n            opts : this._setDefaults(opts, nonParsedOpts),\n            args : this._setDefaults(args, nonParsedArgs)\n        };\n    }\n\n    _setDefaults(params, desc) {\n        for(const item of desc)\n            item._def !== undefined &&\n                !params.hasOwnProperty(item._name) &&\n                item._saveVal(params, item._def);\n\n        return params;\n    }\n\n    _processParams(params, desc) {\n        const notExists = [];\n\n        for(const item of desc) {\n            const n = item._name;\n\n            if(!params.hasOwnProperty(n)) {\n                notExists.push(item);\n                continue;\n            }\n\n            const vals = Array.isArray(params[n])? params[n] : [params[n]];\n            delete params[n];\n\n            let res;\n            for(const v of vals)\n                if(Q.isRejected(res = item._saveVal(params, v)))\n                    return res;\n        }\n\n        return this._setDefaults(params, notExists);\n    }\n\n    _parseArr(argv) {\n        return Q.when(this._parseCmd(argv), p =>\n            Q.when(p.cmd._parseOptsAndArgs(p.argv), r => ({\n                cmd : p.cmd,\n                opts : r.opts,\n                args : r.args\n            })));\n    }\n\n    _do(inputPromise) {\n        return Q.when(inputPromise, input => {\n            return [this._checkRequired]\n                .concat(input.cmd._act || [])\n                .reduce((res, act) =>\n                    Q.when(res, prev => act.call(input.cmd, input.opts, input.args, prev)),\n                    undefined);\n        });\n    }\n\n    /**\n     * Parse arguments from simple format like NodeJS process.argv\n     * and run ahead current program, i.e. call process.exit when all actions done.\n     *\n     * @param {String[]} argv - arguments\n     * @returns {COA.Cmd} - this instance (for chainability)\n     */\n    run(argv) {\n        argv || (argv = process.argv.slice(2));\n\n        const cb = code =>\n            res => res?\n                this._exit(res.stack || res.toString(), (res.hasOwnProperty('exitCode')? res.exitCode : code) || 0) :\n                this._exit();\n\n        Q.when(this.do(argv), cb(0), cb(1)).done();\n\n        return this;\n    }\n\n    /**\n     * Invoke specified (or current) command using provided\n     * options and arguments.\n     *\n     * @param {String|String[]} [cmds] - subcommand to invoke (optional)\n     * @param {Object} [opts] - command options (optional)\n     * @param {Object} [args] - command arguments (optional)\n     * @returns {Q.Promise}\n     */\n    invoke(cmds, opts, args) {\n        cmds || (cmds = []);\n        opts || (opts = {});\n        args || (args = {});\n        typeof cmds === 'string' && (cmds = cmds.split(' '));\n\n        if(arguments.length < 3 && !Array.isArray(cmds)) {\n            args = opts;\n            opts = cmds;\n            cmds = [];\n        }\n\n        return Q.when(this._parseCmd(cmds), p => {\n            if(p.argv.length)\n                return this.reject(`Unknown command: ${cmds.join(' ')}`);\n\n            return Q.all([\n                this._processParams(opts, this._opts),\n                this._processParams(args, this._args)\n            ]).spread((_opts, _args) =>\n                this._do({\n                    cmd : p.cmd,\n                    opts : _opts,\n                    args : _args\n                })\n                .fail(res => (res && res.exitCode === 0)?\n                    res.toString() :\n                    this.reject(res)));\n        });\n    }\n}\n\n/**\n * Convenient function to run command from tests.\n *\n * @param {String[]} argv - arguments\n * @returns {Q.Promise}\n */\nCmd.prototype.do = function(argv) {\n    return this._do(this._parseArr(argv || []));\n};\n\nmodule.exports = Cmd;\n","/* eslint-disable class-methods-use-this */\n\n\nconst Q = require('q');\n\n/**\n * COA Object\n *\n * Base class for all COA-related objects\n *\n * --------|-----|-----|-----\n *         | Cmd | Opt | Arg\n * --------|-----|-----|-----\n *  name   | ✓   | ✓   | ✓\n *  title  | ✓   | ✓   | ✓\n *  comp   | ✓   | ✓   | ✓\n *  reject | ✓   | ✓   | ✓\n *  end    | ✓   | ✓   | ✓\n *  apply  | ✓   | ✓   | ✓\n *\n * @class CoaObject\n */\nmodule.exports = class CoaObject {\n    constructor(cmd) {\n        this._cmd = cmd;\n        this._name = null;\n        this._title = null;\n        this._comp = null;\n    }\n\n    /**\n     * Set a canonical identifier to be used anywhere in the API.\n     *\n     * @param {String} name - command, option or argument name\n     * @returns {COA.CoaObject} - this instance (for chainability)\n     */\n    name(name) {\n        this._name = name;\n        return this;\n    }\n\n    /**\n     * Set a long description to be used anywhere in text messages.\n     * @param {String} title - human readable entity title\n     * @returns {COA.CoaObject} - this instance (for chainability)\n     */\n    title(title) {\n        this._title = title;\n        return this;\n    }\n\n    /**\n     * Set custom additional completion for current object.\n     *\n     * @param {Function} comp - completion generation function,\n     *         invoked in the context of object instance.\n     *         Accepts parameters:\n     *                 - {Object} opts - completion options\n     *         It can return promise or any other value threated as a result.\n     * @returns {COA.CoaObject} - this instance (for chainability)\n     */\n    comp(comp) {\n        this._comp = comp;\n        return this;\n    }\n\n    /**\n     * Apply function with arguments in a context of object instance.\n     *\n     * @param {Function} fn - body\n     * @param {Array.<*>} args... - arguments\n     * @returns {COA.CoaObject} - this instance (for chainability)\n     */\n    apply(fn) {\n        arguments.length > 1?\n            fn.apply(this, [].slice.call(arguments, 1))\n            : fn.call(this);\n\n        return this;\n    }\n\n    /**\n     * Return reject of actions results promise with error code.\n     * Use in .act() for return with error.\n     * @param {Object} reason - reject reason\n     *         You can customize toString() method and exitCode property\n     *         of reason object.\n     * @returns {Q.promise} rejected promise\n     */\n    reject(reason) {\n        return Q.reject(reason);\n    }\n\n    /**\n     * Finish chain for current subcommand and return parent command instance.\n     * @returns {COA.Cmd} parent command\n     */\n    end() {\n        return this._cmd;\n    }\n};\n","\n\nconst\n    Q = require('q'),\n\n    CoaParam = require('./coaparam'),\n    chalk = require('chalk');\n\n/**\n * Option\n *\n * Named entity. Options may have short and long keys for use from command line.\n *\n * @namespace\n * @class Opt\n * @extends CoaParam\n */\nmodule.exports = class Opt extends CoaParam {\n    /**\n     * @constructs\n     * @param {COA.Cmd} cmd - parent command\n     */\n    constructor(cmd) {\n        super(cmd);\n\n        this._short = null;\n        this._long = null;\n        this._flag = false;\n        this._only = false;\n        this._cmd._opts.push(this);\n    }\n\n    /**\n     * Set a short key for option to be used with one hyphen from command line.\n     *\n     * @param {String} short - short name\n     * @returns {COA.Opt} - this instance (for chainability)\n     */\n    short(short) {\n        this._short = short;\n        this._cmd._optsByKey[`-${short}`] = this;\n        return this;\n    }\n\n    /**\n     * Set a short key for option to be used with double hyphens from command line.\n     *\n     * @param {String} long - long name\n     * @returns {COA.Opt} - this instance (for chainability)\n     */\n    long(long) {\n        this._long = long;\n        this._cmd._optsByKey[`--${long}`] = this;\n        return this;\n    }\n\n    /**\n     * Make an option boolean, i.e. option without value.\n     *\n     * @returns {COA.Opt} - this instance (for chainability)\n     */\n    flag() {\n        this._flag = true;\n        return this;\n    }\n\n    /**\n     * Makes an option to act as a command,\n     * i.e. program will exit just after option action.\n     *\n     * @returns {COA.Opt} - this instance (for chainability)\n     */\n    only() {\n        this._only = true;\n        return this;\n    }\n\n    /**\n     * Add action for current option command.\n     * This action is performed if the current option\n     * is present in parsed options (with any value).\n     *\n     * @param {Function} act - action function,\n     *         invoked in the context of command instance\n     *         and has the parameters:\n     *                 - {Object} opts - parsed options\n     *                 - {Array} args - parsed arguments\n     *                 - {Object} res - actions result accumulator\n     *         It can return rejected promise by Cmd.reject (in case of error)\n     *         or any other value treated as result.\n     * @returns {COA.Opt} - this instance (for chainability)\n     */\n    act(act) {\n        // Need function here for arguments\n        const opt = this;\n        this._cmd.act(function(opts) {\n            if(!opts.hasOwnProperty(opt._name)) return;\n\n            const res = act.apply(this, arguments);\n            if(!opt._only) return res;\n\n            return Q.when(res, out => this.reject({\n                toString : () => out.toString(),\n                exitCode : 0\n            }));\n        });\n\n        return this;\n    }\n\n    _saveVal(opts, val) {\n        this._val && (val = this._val(val));\n\n        const name = this._name;\n        this._arr\n            ? (opts[name] || (opts[name] = [])).push(val)\n            : (opts[name] = val);\n\n        return val;\n    }\n\n    _parse(argv, opts) {\n        return this._saveVal(opts, this._flag ? true : argv.shift());\n    }\n\n    _checkParsed(opts) {\n        return !opts.hasOwnProperty(this._name);\n    }\n\n    _usage() {\n        const res = [],\n            nameStr = this._name.toUpperCase();\n\n        if(this._short) {\n            res.push('-', chalk.greenBright(this._short));\n            this._flag || res.push(' ' + nameStr);\n            res.push(', ');\n        }\n\n        if(this._long) {\n            res.push('--', chalk.green(this._long));\n            this._flag || res.push('=' + nameStr);\n        }\n\n        res.push(' : ', this._title);\n\n        this._req && res.push(' ', chalk.redBright('(required)'));\n\n        return res.join('');\n    }\n\n    _requiredText() {\n        return `Missing required option:\\n  ${this._usage()}`;\n    }\n};\n","\n\nconst fs = require('fs');\n\nconst CoaObject = require('./coaobject');\n\n/**\n * COA Parameter\n *\n * Base class for options and arguments\n *\n * --------|-----|-----|-----\n *         | Cmd | Opt | Arg\n * --------|-----|-----|-----\n *  arr    |     | ✓   | ✓\n *  req    |     | ✓   | ✓\n *  val    |     | ✓   | ✓\n *  def    |     | ✓   | ✓\n *  input  |     | ✓   | ✓\n *  output |     | ✓   | ✓\n *\n * @class CoaParam\n * @extends CoaObject\n */\nmodule.exports = class CoaParam extends CoaObject {\n    constructor(cmd) {\n        super(cmd);\n\n        this._arr = false;\n        this._req = false;\n        this._val = undefined;\n        this._def = undefined;\n    }\n\n    /**\n     * Makes a param accepts multiple values.\n     * Otherwise, the value will be used by the latter passed.\n     *\n     * @returns {COA.CoaParam} - this instance (for chainability)\n     */\n    arr() {\n        this._arr = true;\n        return this;\n    }\n\n    /**\n     * Makes a param required.\n     *\n     * @returns {COA.CoaParam} - this instance (for chainability)\n     */\n    req() {\n        this._req = true;\n        return this;\n    }\n\n    /**\n     * Set a validation (or value) function for param.\n     * Value from command line passes through before becoming available from API.\n     * Using for validation and convertion simple types to any values.\n     *\n     * @param {Function} val - validating function,\n     *         invoked in the context of option instance\n     *         and has one parameter with value from command line.\n     * @returns {COA.CoaParam} - this instance (for chainability)\n     */\n    val(val) {\n        this._val = val;\n        return this;\n    }\n\n    /**\n     * Set a default value for param.\n     * Default value passed through validation function as ordinary value.\n     *\n     * @param {*} def - default value of function generator\n     * @returns {COA.CoaParam} - this instance (for chainability)\n     */\n    def(def) {\n        this._def = def;\n        return this;\n    }\n\n    /**\n     * Make option value inputting stream.\n     * It's add useful validation and shortcut for STDIN.\n     *\n     * @returns {COA.CoaParam} - this instance (for chainability)\n     */\n    input() {\n        process.stdin.pause();\n        return this\n            .def(process.stdin)\n            .val(function(v) {\n                if(typeof v !== 'string')\n                    return v;\n\n                if(v === '-')\n                    return process.stdin;\n\n                const s = fs.createReadStream(v, { encoding : 'utf8' });\n                s.pause();\n                return s;\n            });\n    }\n\n    /**\n     * Make option value outputing stream.\n     * It's add useful validation and shortcut for STDOUT.\n     *\n     * @returns {COA.CoaParam} - this instance (for chainability)\n     */\n    output() {\n        return this\n            .def(process.stdout)\n            .val(function(v) {\n                if(typeof v !== 'string')\n                    return v;\n\n                if(v === '-')\n                    return process.stdout;\n\n                return fs.createWriteStream(v, { encoding : 'utf8' });\n            });\n    }\n};\n","\n\nconst\n    CoaParam = require('./coaparam'),\n    chalk = require('chalk');\n\n/**\n * Argument\n *\n * Unnamed entity. From command line arguments passed as list of unnamed values.\n *\n * @class Arg\n * @extends CoaParam\n */\nmodule.exports = class Arg extends CoaParam {\n    /**\n     * @constructs\n     * @param {COA.Cmd} cmd - parent command\n     */\n    constructor(cmd) {\n        super(cmd);\n\n        this._cmd._args.push(this);\n    }\n\n    _saveVal(args, val) {\n        this._val && (val = this._val(val));\n\n        const name = this._name;\n        this._arr\n            ? (args[name] || (args[name] = [])).push(val)\n            : (args[name] = val);\n\n        return val;\n    }\n\n    _parse(arg, args) {\n        return this._saveVal(args, arg);\n    }\n\n    _checkParsed(opts, args) {\n        return !args.hasOwnProperty(this._name);\n    }\n\n    _usage() {\n        const res = [];\n\n        res.push(chalk.magentaBright(this._name.toUpperCase()), ' : ', this._title);\n\n        this._req && res.push(' ', chalk.redBright('(required)'));\n\n        return res.join('');\n    }\n\n    _requiredText() {\n        return `Missing required argument:\\n  ${this._usage()}`;\n    }\n};\n","\n\nconst constants = require('constants');\nconst fs = require('fs');\nconst path = require('path');\n\nconst Q = require('q');\n\nconst shell = require('./shell');\nconst escape = shell.escape;\nconst unescape = shell.unescape;\n\n/**\n * Most of the code adopted from the npm package shell completion code.\n * See https://github.com/isaacs/npm/blob/master/lib/completion.js\n *\n * @returns {COA.CoaObject}\n */\nmodule.exports = function completion() {\n    return this\n        .title('Shell completion')\n        .helpful()\n        .arg()\n            .name('raw')\n            .title('Completion words')\n            .arr()\n            .end()\n        .act((opts, args) => {\n            if(process.platform === 'win32') {\n                const e = new Error('shell completion not supported on windows');\n                e.code = 'ENOTSUP';\n                e.errno = constants.ENOTSUP;\n                return this.reject(e);\n            }\n\n            // if the COMP_* isn't in the env, then just dump the script\n            if((process.env.COMP_CWORD == null)\n                || (process.env.COMP_LINE == null)\n                || (process.env.COMP_POINT == null)) {\n                return dumpScript(this._cmd._name);\n            }\n\n            console.error('COMP_LINE:  %s', process.env.COMP_LINE);\n            console.error('COMP_CWORD: %s', process.env.COMP_CWORD);\n            console.error('COMP_POINT: %s', process.env.COMP_POINT);\n            console.error('args: %j', args.raw);\n\n            // completion opts\n            opts = getOpts(args.raw);\n\n            // cmd\n            const parsed = this._cmd._parseCmd(opts.partialWords);\n            return Q.when(complete(parsed.cmd, parsed.opts), compls => {\n                console.error('filtered: %j', compls);\n                return console.log(compls.map(escape).join('\\n'));\n            });\n        });\n};\n\nfunction dumpScript(name) {\n    const defer = Q.defer();\n\n    fs.readFile(path.resolve(__dirname, 'completion.sh'), 'utf8', function(err, d) {\n        if(err) return defer.reject(err);\n        d = d.replace(/{{cmd}}/g, path.basename(name)).replace(/^#!.*?\\n/, '');\n\n        process.stdout.on('error', onError);\n        process.stdout.write(d, () => defer.resolve());\n    });\n\n    return defer.promise;\n\n    function onError(err) {\n        // Darwin is a real dick sometimes.\n        //\n        // This is necessary because the \"source\" or \".\" program in\n        // bash on OS X closes its file argument before reading\n        // from it, meaning that you get exactly 1 write, which will\n        // work most of the time, and will always raise an EPIPE.\n        //\n        // Really, one should not be tossing away EPIPE errors, or any\n        // errors, so casually. But, without this, `. <(cmd completion)`\n        // can never ever work on OS X.\n        if(err.errno !== constants.EPIPE) return defer.reject(err);\n        process.stdout.removeListener('error', onError);\n        return defer.resolve();\n    }\n}\n\nfunction getOpts(argv) {\n    // get the partial line and partial word, if the point isn't at the end\n    // ie, tabbing at: cmd foo b|ar\n    const line = process.env.COMP_LINE;\n    const w = +process.env.COMP_CWORD;\n    const point = +process.env.COMP_POINT;\n    const words = argv.map(unescape);\n    const word = words[w];\n    const partialLine = line.substr(0, point);\n    const partialWords = words.slice(0, w);\n\n    // figure out where in that last word the point is\n    let partialWord = argv[w] || '';\n    let i = partialWord.length;\n    while(partialWord.substr(0, i) !== partialLine.substr(-1 * i) && i > 0) i--;\n\n    partialWord = unescape(partialWord.substr(0, i));\n    partialWord && partialWords.push(partialWord);\n\n    return {\n        line,\n        w,\n        point,\n        words,\n        word,\n        partialLine,\n        partialWords,\n        partialWord\n    };\n}\n\nfunction complete(cmd, opts) {\n    let optWord, optPrefix,\n        compls = [];\n\n    // Complete on cmds\n    if(opts.partialWord.indexOf('-'))\n        compls = Object.keys(cmd._cmdsByName);\n        // Complete on required opts without '-' in last partial word\n        // (if required not already specified)\n        //\n        // Commented out because of uselessness:\n        // -b, --block suggest results in '-' on cmd line;\n        // next completion suggest all options, because of '-'\n        //.concat Object.keys(cmd._optsByKey).filter (v) -> cmd._optsByKey[v]._req\n    else {\n        // complete on opt values: --opt=| case\n        const m = opts.partialWord.match(/^(--\\w[\\w-_]*)=(.*)$/);\n        if(m) {\n            optWord = m[1];\n            optPrefix = optWord + '=';\n        } else\n            // complete on opts\n            // don't complete on opts in case of --opt=val completion\n            // TODO: don't complete on opts in case of unknown arg after commands\n            // TODO: complete only on opts with arr() or not already used\n            // TODO: complete only on full opts?\n            compls = Object.keys(cmd._optsByKey);\n    }\n\n    // complete on opt values: next arg case\n    opts.partialWords[opts.w - 1].indexOf('-') || (optWord = opts.partialWords[opts.w - 1]);\n\n    // complete on opt values: completion\n    let opt;\n    optWord\n        && (opt = cmd._optsByKey[optWord])\n        && !opt._flag\n        && opt._comp\n        && (compls = Q.join(compls,\n            Q.when(opt._comp(opts),\n                (c, o) => c.concat(o.map(v => (optPrefix || '') + v)))));\n\n    // TODO: complete on args values (context aware, custom completion?)\n\n    // custom completion on cmds\n    cmd._comp && (compls = Q.join(compls, Q.when(cmd._comp(opts)), (c, o) => c.concat(o)));\n\n    // TODO: context aware custom completion on cmds, opts and args\n    // (can depend on already entered values, especially options)\n\n    return Q.when(compls, complitions => {\n        console.error('partialWord: %s', opts.partialWord);\n        console.error('compls: %j', complitions);\n        return compls.filter(c => c.indexOf(opts.partialWord) === 0);\n    });\n}\n","module.exports = { escape, unescape };\n\nfunction unescape(w) {\n    w = w.charAt(0) === '\"'\n        ? w.replace(/^\"|([^\\\\])\"$/g, '$1')\n        : w.replace(/\\\\ /g, ' ');\n\n    return w.replace(/\\\\(\"|'|\\$|`|\\\\)/g, '$1');\n}\n\nfunction escape(w) {\n    w = w.replace(/([\"'$`\\\\])/g,'\\\\$1');\n    return w.match(/\\s+/) ? `\"${w}\"` : w;\n}\n"]}